ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 1


   1              		.cpu cortex-m3
   2              		.arch armv7-m
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"util.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.BLDC_Init,"ax",%progbits
  18              		.align	1
  19              		.global	BLDC_Init
  20              		.syntax unified
  21              		.thumb
  22              		.thumb_func
  24              	BLDC_Init:
  25              	.LFB66:
  26              		.file 1 "Src/util.c"
   1:Src/util.c    **** /**
   2:Src/util.c    ****   * This file is part of the hoverboard-firmware-hack project.
   3:Src/util.c    ****   *
   4:Src/util.c    ****   * Copyright (C) 2020-2021 Emanuel FERU <aerdronix@gmail.com>
   5:Src/util.c    ****   *
   6:Src/util.c    ****   * This program is free software: you can redistribute it and/or modify
   7:Src/util.c    ****   * it under the terms of the GNU General Public License as published by
   8:Src/util.c    ****   * the Free Software Foundation, either version 3 of the License, or
   9:Src/util.c    ****   * (at your option) any later version.
  10:Src/util.c    ****   *
  11:Src/util.c    ****   * This program is distributed in the hope that it will be useful,
  12:Src/util.c    ****   * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:Src/util.c    ****   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:Src/util.c    ****   * GNU General Public License for more details.
  15:Src/util.c    ****   *
  16:Src/util.c    ****   * You should have received a copy of the GNU General Public License
  17:Src/util.c    ****   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  18:Src/util.c    **** */
  19:Src/util.c    **** 
  20:Src/util.c    **** // Includes
  21:Src/util.c    **** #include <stdio.h>
  22:Src/util.c    **** #include <stdlib.h> // for abs()
  23:Src/util.c    **** #include <string.h>
  24:Src/util.c    **** #include "stm32f1xx_hal.h"
  25:Src/util.c    **** #include "defines.h"
  26:Src/util.c    **** #include "setup.h"
  27:Src/util.c    **** #include "config.h"
  28:Src/util.c    **** #include "eeprom.h"
  29:Src/util.c    **** #include "util.h"
  30:Src/util.c    **** #include "BLDC_controller.h"
  31:Src/util.c    **** #include "rtwtypes.h"
  32:Src/util.c    **** #include "comms.h"
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 2


  33:Src/util.c    **** 
  34:Src/util.c    **** #if defined(DEBUG_I2C_LCD) || defined(SUPPORT_LCD)
  35:Src/util.c    **** #include "hd44780.h"
  36:Src/util.c    **** #endif
  37:Src/util.c    **** 
  38:Src/util.c    **** /* =========================== Variable Definitions =========================== */
  39:Src/util.c    **** 
  40:Src/util.c    **** //------------------------------------------------------------------------
  41:Src/util.c    **** // Global variables set externally
  42:Src/util.c    **** //------------------------------------------------------------------------
  43:Src/util.c    **** extern volatile adc_buf_t adc_buffer;
  44:Src/util.c    **** extern I2C_HandleTypeDef hi2c2;
  45:Src/util.c    **** extern UART_HandleTypeDef huart2;
  46:Src/util.c    **** extern UART_HandleTypeDef huart3;
  47:Src/util.c    **** 
  48:Src/util.c    **** extern int16_t batVoltage;
  49:Src/util.c    **** extern uint8_t backwardDrive;
  50:Src/util.c    **** extern uint8_t buzzerCount;             // global variable for the buzzer counts. can be 1, 2, 3, 4
  51:Src/util.c    **** extern uint8_t buzzerFreq;              // global variable for the buzzer pitch. can be 1, 2, 3, 4,
  52:Src/util.c    **** extern uint8_t buzzerPattern;           // global variable for the buzzer pattern. can be 1, 2, 3, 
  53:Src/util.c    **** 
  54:Src/util.c    **** extern uint8_t enable;                  // global variable for motor enable
  55:Src/util.c    **** 
  56:Src/util.c    **** extern uint8_t nunchuk_data[6];
  57:Src/util.c    **** extern volatile uint32_t timeoutCntGen; // global counter for general timeout counter
  58:Src/util.c    **** extern volatile uint8_t  timeoutFlgGen; // global flag for general timeout counter
  59:Src/util.c    **** extern volatile uint32_t main_loop_counter;
  60:Src/util.c    **** 
  61:Src/util.c    **** #if defined(CONTROL_PPM_LEFT) || defined(CONTROL_PPM_RIGHT)
  62:Src/util.c    **** extern volatile uint16_t ppm_captured_value[PPM_NUM_CHANNELS+1];
  63:Src/util.c    **** #endif
  64:Src/util.c    **** 
  65:Src/util.c    **** #if defined(CONTROL_PWM_LEFT) || defined(CONTROL_PWM_RIGHT)
  66:Src/util.c    **** extern volatile uint16_t pwm_captured_ch1_value;
  67:Src/util.c    **** extern volatile uint16_t pwm_captured_ch2_value;
  68:Src/util.c    **** #endif
  69:Src/util.c    **** 
  70:Src/util.c    **** 
  71:Src/util.c    **** //------------------------------------------------------------------------
  72:Src/util.c    **** // Global variables set here in util.c
  73:Src/util.c    **** //------------------------------------------------------------------------
  74:Src/util.c    **** // Matlab defines - from auto-code generation
  75:Src/util.c    **** //---------------
  76:Src/util.c    **** RT_MODEL rtM_Left_;                     /* Real-time model */
  77:Src/util.c    **** RT_MODEL rtM_Right_;                    /* Real-time model */
  78:Src/util.c    **** RT_MODEL *const rtM_Left  = &rtM_Left_;
  79:Src/util.c    **** RT_MODEL *const rtM_Right = &rtM_Right_;
  80:Src/util.c    **** 
  81:Src/util.c    **** extern P rtP_Left;                      /* Block parameters (auto storage) */
  82:Src/util.c    **** DW       rtDW_Left;                     /* Observable states */
  83:Src/util.c    **** ExtU     rtU_Left;                      /* External inputs */
  84:Src/util.c    **** ExtY     rtY_Left;                      /* External outputs */
  85:Src/util.c    **** 
  86:Src/util.c    **** P        rtP_Right;                     /* Block parameters (auto storage) */
  87:Src/util.c    **** DW       rtDW_Right;                    /* Observable states */
  88:Src/util.c    **** ExtU     rtU_Right;                     /* External inputs */
  89:Src/util.c    **** ExtY     rtY_Right;                     /* External outputs */
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 3


  90:Src/util.c    **** //---------------
  91:Src/util.c    **** 
  92:Src/util.c    **** uint8_t  inIdx      = 0;
  93:Src/util.c    **** uint8_t  inIdx_prev = 0;
  94:Src/util.c    **** #if defined(PRI_INPUT1) && defined(PRI_INPUT2) && defined(AUX_INPUT1) && defined(AUX_INPUT2)
  95:Src/util.c    **** InputStruct input1[INPUTS_NR] = { {0, 0, 0, PRI_INPUT1}, {0, 0, 0, AUX_INPUT1} };
  96:Src/util.c    **** InputStruct input2[INPUTS_NR] = { {0, 0, 0, PRI_INPUT2}, {0, 0, 0, AUX_INPUT2} };
  97:Src/util.c    **** #else
  98:Src/util.c    **** InputStruct input1[INPUTS_NR] = { {0, 0, 0, PRI_INPUT1} };
  99:Src/util.c    **** InputStruct input2[INPUTS_NR] = { {0, 0, 0, PRI_INPUT2} };
 100:Src/util.c    **** #endif
 101:Src/util.c    **** 
 102:Src/util.c    **** int16_t  speedAvg;                      // average measured speed
 103:Src/util.c    **** int16_t  speedAvgAbs;                   // average measured speed in absolute
 104:Src/util.c    **** uint8_t  timeoutFlgADC    = 0;          // Timeout Flag for ADC Protection:    0 = OK, 1 = Problem 
 105:Src/util.c    **** uint8_t  timeoutFlgSerial = 0;          // Timeout Flag for Rx Serial command: 0 = OK, 1 = Problem 
 106:Src/util.c    **** 
 107:Src/util.c    **** uint8_t  ctrlModReqRaw = CTRL_MOD_REQ;
 108:Src/util.c    **** uint8_t  ctrlModReq    = CTRL_MOD_REQ;  // Final control mode request 
 109:Src/util.c    **** 
 110:Src/util.c    **** #if defined(DEBUG_I2C_LCD) || defined(SUPPORT_LCD)
 111:Src/util.c    **** LCD_PCF8574_HandleTypeDef lcd;
 112:Src/util.c    **** #endif
 113:Src/util.c    **** 
 114:Src/util.c    **** #ifdef VARIANT_TRANSPOTTER
 115:Src/util.c    **** float    setDistance;
 116:Src/util.c    **** uint16_t VirtAddVarTab[NB_OF_VAR] = {1337};       // Virtual address defined by the user: 0xFFFF va
 117:Src/util.c    **** static   uint16_t saveValue       = 0;
 118:Src/util.c    **** static   uint8_t  saveValue_valid = 0;
 119:Src/util.c    **** #elif !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 120:Src/util.c    **** uint16_t VirtAddVarTab[NB_OF_VAR] = {1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009,
 121:Src/util.c    ****                                      1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018};
 122:Src/util.c    **** #else
 123:Src/util.c    **** uint16_t VirtAddVarTab[NB_OF_VAR] = {1000};       // Dummy virtual address to avoid warnings
 124:Src/util.c    **** #endif
 125:Src/util.c    **** 
 126:Src/util.c    **** 
 127:Src/util.c    **** //------------------------------------------------------------------------
 128:Src/util.c    **** // Local variables
 129:Src/util.c    **** //------------------------------------------------------------------------
 130:Src/util.c    **** static int16_t INPUT_MAX;             // [-] Input target maximum limitation
 131:Src/util.c    **** static int16_t INPUT_MIN;             // [-] Input target minimum limitation
 132:Src/util.c    **** 
 133:Src/util.c    **** 
 134:Src/util.c    **** #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 135:Src/util.c    ****   static uint8_t  cur_spd_valid  = 0;
 136:Src/util.c    ****   static uint8_t  inp_cal_valid  = 0;
 137:Src/util.c    **** #endif
 138:Src/util.c    **** 
 139:Src/util.c    **** #if defined(CONTROL_ADC)
 140:Src/util.c    **** static uint16_t timeoutCntADC = ADC_PROTECT_TIMEOUT;  // Timeout counter for ADC Protection
 141:Src/util.c    **** #endif
 142:Src/util.c    **** 
 143:Src/util.c    **** #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USAR
 144:Src/util.c    **** static uint8_t  rx_buffer_L[SERIAL_BUFFER_SIZE];      // USART Rx DMA circular buffer
 145:Src/util.c    **** static uint32_t rx_buffer_L_len = ARRAY_LEN(rx_buffer_L);
 146:Src/util.c    **** #endif
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 4


 147:Src/util.c    **** #if defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USART2)
 148:Src/util.c    **** static uint16_t timeoutCntSerial_L = SERIAL_TIMEOUT;  // Timeout counter for Rx Serial command
 149:Src/util.c    **** static uint8_t  timeoutFlgSerial_L = 0;               // Timeout Flag for Rx Serial command: 0 = OK
 150:Src/util.c    **** #endif
 151:Src/util.c    **** #if defined(SIDEBOARD_SERIAL_USART2)
 152:Src/util.c    **** SerialSideboard Sideboard_L;
 153:Src/util.c    **** SerialSideboard Sideboard_L_raw;
 154:Src/util.c    **** static uint32_t Sideboard_L_len = sizeof(Sideboard_L);
 155:Src/util.c    **** #endif
 156:Src/util.c    **** 
 157:Src/util.c    **** #if defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_USAR
 158:Src/util.c    **** static uint8_t  rx_buffer_R[SERIAL_BUFFER_SIZE];      // USART Rx DMA circular buffer
 159:Src/util.c    **** static uint32_t rx_buffer_R_len = ARRAY_LEN(rx_buffer_R);
 160:Src/util.c    **** #endif
 161:Src/util.c    **** #if defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_USART3)
 162:Src/util.c    **** static uint16_t timeoutCntSerial_R = SERIAL_TIMEOUT;  // Timeout counter for Rx Serial command
 163:Src/util.c    **** static uint8_t  timeoutFlgSerial_R = 0;               // Timeout Flag for Rx Serial command: 0 = OK
 164:Src/util.c    **** #endif
 165:Src/util.c    **** #if defined(SIDEBOARD_SERIAL_USART3)
 166:Src/util.c    **** SerialSideboard Sideboard_R;
 167:Src/util.c    **** SerialSideboard Sideboard_R_raw;
 168:Src/util.c    **** static uint32_t Sideboard_R_len = sizeof(Sideboard_R);
 169:Src/util.c    **** #endif
 170:Src/util.c    **** 
 171:Src/util.c    **** #if defined(CONTROL_SERIAL_USART2)
 172:Src/util.c    **** static SerialCommand commandL;
 173:Src/util.c    **** static SerialCommand commandL_raw;
 174:Src/util.c    **** static uint32_t commandL_len = sizeof(commandL);
 175:Src/util.c    ****   #ifdef CONTROL_IBUS
 176:Src/util.c    ****   static uint16_t ibusL_captured_value[IBUS_NUM_CHANNELS];
 177:Src/util.c    ****   #endif
 178:Src/util.c    **** #endif
 179:Src/util.c    **** 
 180:Src/util.c    **** #if defined(CONTROL_SERIAL_USART3)
 181:Src/util.c    **** static SerialCommand commandR;
 182:Src/util.c    **** static SerialCommand commandR_raw;
 183:Src/util.c    **** static uint32_t commandR_len = sizeof(commandR);
 184:Src/util.c    ****   #ifdef CONTROL_IBUS
 185:Src/util.c    ****   static uint16_t ibusR_captured_value[IBUS_NUM_CHANNELS];
 186:Src/util.c    ****   #endif
 187:Src/util.c    **** #endif
 188:Src/util.c    **** 
 189:Src/util.c    **** #if defined(SUPPORT_BUTTONS) || defined(SUPPORT_BUTTONS_LEFT) || defined(SUPPORT_BUTTONS_RIGHT)
 190:Src/util.c    **** static uint8_t button1;                 // Blue
 191:Src/util.c    **** static uint8_t button2;                 // Green
 192:Src/util.c    **** #endif
 193:Src/util.c    **** 
 194:Src/util.c    **** #ifdef VARIANT_HOVERCAR
 195:Src/util.c    **** static uint8_t brakePressed;
 196:Src/util.c    **** #endif
 197:Src/util.c    **** 
 198:Src/util.c    **** #if defined(CRUISE_CONTROL_SUPPORT) || (defined(STANDSTILL_HOLD_ENABLE) && (CTRL_TYP_SEL == FOC_CTR
 199:Src/util.c    **** static uint8_t cruiseCtrlAcv = 0;
 200:Src/util.c    **** static uint8_t standstillAcv = 0;
 201:Src/util.c    **** #endif
 202:Src/util.c    **** 
 203:Src/util.c    **** /* =========================== Retargeting printf =========================== */
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 5


 204:Src/util.c    **** /* retarget the C library printf function to the USART */
 205:Src/util.c    **** #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 206:Src/util.c    ****   #ifdef __GNUC__
 207:Src/util.c    ****     #define PUTCHAR_PROTOTYPE int __io_putchar(int ch)
 208:Src/util.c    ****   #else
 209:Src/util.c    ****     #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)
 210:Src/util.c    ****   #endif
 211:Src/util.c    ****   PUTCHAR_PROTOTYPE {
 212:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2)
 213:Src/util.c    ****       HAL_UART_Transmit(&huart2, (uint8_t *)&ch, 1, 1000);
 214:Src/util.c    ****     #elif defined(DEBUG_SERIAL_USART3)
 215:Src/util.c    ****       HAL_UART_Transmit(&huart3, (uint8_t *)&ch, 1, 1000);
 216:Src/util.c    ****     #endif
 217:Src/util.c    ****     return ch;
 218:Src/util.c    ****   }
 219:Src/util.c    ****   
 220:Src/util.c    ****   #ifdef __GNUC__
 221:Src/util.c    ****     int _write(int file, char *data, int len) {
 222:Src/util.c    ****       int i;
 223:Src/util.c    ****       for (i = 0; i < len; i++) { __io_putchar( *data++ );}
 224:Src/util.c    ****       return len;
 225:Src/util.c    ****     }
 226:Src/util.c    ****   #endif
 227:Src/util.c    **** #endif
 228:Src/util.c    **** 
 229:Src/util.c    ****  
 230:Src/util.c    **** /* =========================== Initialization Functions =========================== */
 231:Src/util.c    **** 
 232:Src/util.c    **** void BLDC_Init(void) {
  27              		.loc 1 232 22 view -0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31 0000 70B5     		push	{r4, r5, r6, lr}
  32              	.LCFI0:
  33              		.cfi_def_cfa_offset 16
  34              		.cfi_offset 4, -16
  35              		.cfi_offset 5, -12
  36              		.cfi_offset 6, -8
  37              		.cfi_offset 14, -4
 233:Src/util.c    ****   /* Set BLDC controller parameters */ 
 234:Src/util.c    ****   rtP_Left.b_angleMeasEna       = 0;            // Motor angle input: 0 = estimated angle, 1 = meas
  38              		.loc 1 234 3 view .LVU1
  39              		.loc 1 234 33 is_stmt 0 view .LVU2
  40 0002 204C     		ldr	r4, .L3
  41 0004 0023     		movs	r3, #0
  42 0006 84F8FB30 		strb	r3, [r4, #251]
 235:Src/util.c    ****   rtP_Left.z_selPhaCurMeasABC   = 0;            // Left motor measured current phases {Green, Blue}
  43              		.loc 1 235 3 is_stmt 1 view .LVU3
  44              		.loc 1 235 33 is_stmt 0 view .LVU4
  45 000a 84F8FA30 		strb	r3, [r4, #250]
 236:Src/util.c    ****   rtP_Left.z_ctrlTypSel         = CTRL_TYP_SEL;
  46              		.loc 1 236 3 is_stmt 1 view .LVU5
  47              		.loc 1 236 33 is_stmt 0 view .LVU6
  48 000e 0222     		movs	r2, #2
  49 0010 84F8F920 		strb	r2, [r4, #249]
 237:Src/util.c    ****   rtP_Left.b_diagEna            = DIAG_ENA;
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 6


  50              		.loc 1 237 3 is_stmt 1 view .LVU7
  51              		.loc 1 237 33 is_stmt 0 view .LVU8
  52 0014 0126     		movs	r6, #1
  53 0016 84F8FD60 		strb	r6, [r4, #253]
 238:Src/util.c    ****   rtP_Left.i_max                = (I_MOT_MAX * A2BIT_CONV) << 4;        // fixdt(1,16,4)
  54              		.loc 1 238 3 is_stmt 1 view .LVU9
  55              		.loc 1 238 33 is_stmt 0 view .LVU10
  56 001a 42F6E062 		movw	r2, #12000
  57 001e A4F8CE20 		strh	r2, [r4, #206]	@ movhi
 239:Src/util.c    ****   rtP_Left.n_max                = N_MOT_MAX << 4;                       // fixdt(1,16,4)
  58              		.loc 1 239 3 is_stmt 1 view .LVU11
  59              		.loc 1 239 33 is_stmt 0 view .LVU12
  60 0022 4FF47A51 		mov	r1, #16000
  61 0026 A4F8DA10 		strh	r1, [r4, #218]	@ movhi
 240:Src/util.c    ****   rtP_Left.b_fieldWeakEna       = FIELD_WEAK_ENA; 
  62              		.loc 1 240 3 is_stmt 1 view .LVU13
  63              		.loc 1 240 33 is_stmt 0 view .LVU14
  64 002a 84F8FE30 		strb	r3, [r4, #254]
 241:Src/util.c    ****   rtP_Left.id_fieldWeakMax      = (FIELD_WEAK_MAX * A2BIT_CONV) << 4;   // fixdt(1,16,4)
  65              		.loc 1 241 3 is_stmt 1 view .LVU15
  66              		.loc 1 241 33 is_stmt 0 view .LVU16
  67 002e 4FF47A63 		mov	r3, #4000
  68 0032 A4F8D030 		strh	r3, [r4, #208]	@ movhi
 242:Src/util.c    ****   rtP_Left.a_phaAdvMax          = PHASE_ADV_MAX << 4;                   // fixdt(1,16,4)
  69              		.loc 1 242 3 is_stmt 1 view .LVU17
  70              		.loc 1 242 33 is_stmt 0 view .LVU18
  71 0036 4FF4C873 		mov	r3, #400
  72 003a A4F8CC30 		strh	r3, [r4, #204]	@ movhi
 243:Src/util.c    ****   rtP_Left.r_fieldWeakHi        = FIELD_WEAK_HI << 4;                   // fixdt(1,16,4)
  73              		.loc 1 243 3 is_stmt 1 view .LVU19
  74              		.loc 1 243 33 is_stmt 0 view .LVU20
  75 003e A4F8E010 		strh	r1, [r4, #224]	@ movhi
 244:Src/util.c    ****   rtP_Left.r_fieldWeakLo        = FIELD_WEAK_LO << 4;                   // fixdt(1,16,4)
  76              		.loc 1 244 3 is_stmt 1 view .LVU21
  77              		.loc 1 244 33 is_stmt 0 view .LVU22
  78 0042 A4F8E220 		strh	r2, [r4, #226]	@ movhi
 245:Src/util.c    **** 
 246:Src/util.c    ****   rtP_Right                     = rtP_Left;     // Copy the Left motor parameters to the Right moto
  79              		.loc 1 246 3 is_stmt 1 view .LVU23
  80              		.loc 1 246 33 is_stmt 0 view .LVU24
  81 0046 104D     		ldr	r5, .L3+4
  82 0048 4FF48072 		mov	r2, #256
  83 004c 2146     		mov	r1, r4
  84 004e 2846     		mov	r0, r5
  85 0050 FFF7FEFF 		bl	memcpy
  86              	.LVL0:
 247:Src/util.c    ****   rtP_Right.z_selPhaCurMeasABC  = 1;            // Right motor measured current phases {Blue, Yello
  87              		.loc 1 247 3 is_stmt 1 view .LVU25
  88              		.loc 1 247 33 is_stmt 0 view .LVU26
  89 0054 85F8FA60 		strb	r6, [r5, #250]
 248:Src/util.c    **** 
 249:Src/util.c    ****   /* Pack LEFT motor data into RTM */
 250:Src/util.c    ****   rtM_Left->defaultParam        = &rtP_Left;
  90              		.loc 1 250 3 is_stmt 1 view .LVU27
  91              		.loc 1 250 33 is_stmt 0 view .LVU28
  92 0058 0C48     		ldr	r0, .L3+8
  93 005a 0460     		str	r4, [r0]
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 7


 251:Src/util.c    ****   rtM_Left->dwork               = &rtDW_Left;
  94              		.loc 1 251 3 is_stmt 1 view .LVU29
  95              		.loc 1 251 33 is_stmt 0 view .LVU30
  96 005c 0C4B     		ldr	r3, .L3+12
  97 005e C360     		str	r3, [r0, #12]
 252:Src/util.c    ****   rtM_Left->inputs              = &rtU_Left;
  98              		.loc 1 252 3 is_stmt 1 view .LVU31
  99              		.loc 1 252 33 is_stmt 0 view .LVU32
 100 0060 0C4B     		ldr	r3, .L3+16
 101 0062 4360     		str	r3, [r0, #4]
 253:Src/util.c    ****   rtM_Left->outputs             = &rtY_Left;
 102              		.loc 1 253 3 is_stmt 1 view .LVU33
 103              		.loc 1 253 33 is_stmt 0 view .LVU34
 104 0064 0C4B     		ldr	r3, .L3+20
 105 0066 8360     		str	r3, [r0, #8]
 254:Src/util.c    **** 
 255:Src/util.c    ****   /* Pack RIGHT motor data into RTM */
 256:Src/util.c    ****   rtM_Right->defaultParam       = &rtP_Right;
 106              		.loc 1 256 3 is_stmt 1 view .LVU35
 107              		.loc 1 256 33 is_stmt 0 view .LVU36
 108 0068 0C4C     		ldr	r4, .L3+24
 109 006a 2560     		str	r5, [r4]
 257:Src/util.c    ****   rtM_Right->dwork              = &rtDW_Right;
 110              		.loc 1 257 3 is_stmt 1 view .LVU37
 111              		.loc 1 257 33 is_stmt 0 view .LVU38
 112 006c 0C4B     		ldr	r3, .L3+28
 113 006e E360     		str	r3, [r4, #12]
 258:Src/util.c    ****   rtM_Right->inputs             = &rtU_Right;
 114              		.loc 1 258 3 is_stmt 1 view .LVU39
 115              		.loc 1 258 33 is_stmt 0 view .LVU40
 116 0070 0C4B     		ldr	r3, .L3+32
 117 0072 6360     		str	r3, [r4, #4]
 259:Src/util.c    ****   rtM_Right->outputs            = &rtY_Right;
 118              		.loc 1 259 3 is_stmt 1 view .LVU41
 119              		.loc 1 259 33 is_stmt 0 view .LVU42
 120 0074 0C4B     		ldr	r3, .L3+36
 121 0076 A360     		str	r3, [r4, #8]
 260:Src/util.c    **** 
 261:Src/util.c    ****   /* Initialize BLDC controllers */
 262:Src/util.c    ****   BLDC_controller_initialize(rtM_Left);
 122              		.loc 1 262 3 is_stmt 1 view .LVU43
 123 0078 FFF7FEFF 		bl	BLDC_controller_initialize
 124              	.LVL1:
 263:Src/util.c    ****   BLDC_controller_initialize(rtM_Right);
 125              		.loc 1 263 3 view .LVU44
 126 007c 2046     		mov	r0, r4
 127 007e FFF7FEFF 		bl	BLDC_controller_initialize
 128              	.LVL2:
 264:Src/util.c    **** }
 129              		.loc 1 264 1 is_stmt 0 view .LVU45
 130 0082 70BD     		pop	{r4, r5, r6, pc}
 131              	.L4:
 132              		.align	2
 133              	.L3:
 134 0084 00000000 		.word	rtP_Left
 135 0088 00000000 		.word	.LANCHOR0
 136 008c 00000000 		.word	.LANCHOR1
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 8


 137 0090 00000000 		.word	.LANCHOR2
 138 0094 00000000 		.word	.LANCHOR3
 139 0098 00000000 		.word	.LANCHOR4
 140 009c 00000000 		.word	.LANCHOR5
 141 00a0 00000000 		.word	.LANCHOR6
 142 00a4 00000000 		.word	.LANCHOR7
 143 00a8 00000000 		.word	.LANCHOR8
 144              		.cfi_endproc
 145              	.LFE66:
 147              		.section	.text.Input_Lim_Init,"ax",%progbits
 148              		.align	1
 149              		.global	Input_Lim_Init
 150              		.syntax unified
 151              		.thumb
 152              		.thumb_func
 154              	Input_Lim_Init:
 155              	.LFB67:
 265:Src/util.c    **** 
 266:Src/util.c    **** void Input_Lim_Init(void) {     // Input Limitations - ! Do NOT touch !
 156              		.loc 1 266 27 is_stmt 1 view -0
 157              		.cfi_startproc
 158              		@ args = 0, pretend = 0, frame = 0
 159              		@ frame_needed = 0, uses_anonymous_args = 0
 160              		@ link register save eliminated.
 267:Src/util.c    ****   if (rtP_Left.b_fieldWeakEna || rtP_Right.b_fieldWeakEna) {
 161              		.loc 1 267 3 view .LVU47
 162              		.loc 1 267 15 is_stmt 0 view .LVU48
 163 0000 0C4B     		ldr	r3, .L9
 164 0002 93F8FE30 		ldrb	r3, [r3, #254]	@ zero_extendqisi2
 165              		.loc 1 267 6 view .LVU49
 166 0006 1BB9     		cbnz	r3, .L6
 167              		.loc 1 267 43 discriminator 1 view .LVU50
 168 0008 0B4B     		ldr	r3, .L9+4
 169 000a 93F8FE30 		ldrb	r3, [r3, #254]	@ zero_extendqisi2
 170              		.loc 1 267 31 discriminator 1 view .LVU51
 171 000e 43B1     		cbz	r3, .L7
 172              	.L6:
 268:Src/util.c    ****     INPUT_MAX = MAX( 1000, FIELD_WEAK_HI);
 173              		.loc 1 268 5 is_stmt 1 view .LVU52
 174              		.loc 1 268 15 is_stmt 0 view .LVU53
 175 0010 0A4B     		ldr	r3, .L9+8
 176 0012 4FF47A72 		mov	r2, #1000
 177 0016 1A80     		strh	r2, [r3]	@ movhi
 269:Src/util.c    ****     INPUT_MIN = MIN(-1000,-FIELD_WEAK_HI);
 178              		.loc 1 269 5 is_stmt 1 view .LVU54
 179              		.loc 1 269 15 is_stmt 0 view .LVU55
 180 0018 094B     		ldr	r3, .L9+12
 181 001a 4FF61842 		movw	r2, #64536
 182 001e 1A80     		strh	r2, [r3]	@ movhi
 183 0020 7047     		bx	lr
 184              	.L7:
 270:Src/util.c    ****   } else {
 271:Src/util.c    ****     INPUT_MAX =  1000;
 185              		.loc 1 271 5 is_stmt 1 view .LVU56
 186              		.loc 1 271 15 is_stmt 0 view .LVU57
 187 0022 064B     		ldr	r3, .L9+8
 188 0024 4FF47A72 		mov	r2, #1000
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 9


 189 0028 1A80     		strh	r2, [r3]	@ movhi
 272:Src/util.c    ****     INPUT_MIN = -1000;
 190              		.loc 1 272 5 is_stmt 1 view .LVU58
 191              		.loc 1 272 15 is_stmt 0 view .LVU59
 192 002a 054B     		ldr	r3, .L9+12
 193 002c 4FF61842 		movw	r2, #64536
 194 0030 1A80     		strh	r2, [r3]	@ movhi
 273:Src/util.c    ****   }
 274:Src/util.c    **** }
 195              		.loc 1 274 1 view .LVU60
 196 0032 7047     		bx	lr
 197              	.L10:
 198              		.align	2
 199              	.L9:
 200 0034 00000000 		.word	rtP_Left
 201 0038 00000000 		.word	.LANCHOR0
 202 003c 00000000 		.word	.LANCHOR9
 203 0040 00000000 		.word	.LANCHOR10
 204              		.cfi_endproc
 205              	.LFE67:
 207              		.section	.text.UART_DisableRxErrors,"ax",%progbits
 208              		.align	1
 209              		.global	UART_DisableRxErrors
 210              		.syntax unified
 211              		.thumb
 212              		.thumb_func
 214              	UART_DisableRxErrors:
 215              	.LVL3:
 216              	.LFB69:
 275:Src/util.c    **** 
 276:Src/util.c    **** void Input_Init(void) {
 277:Src/util.c    ****   #if defined(CONTROL_PPM_LEFT) || defined(CONTROL_PPM_RIGHT)
 278:Src/util.c    ****     PPM_Init();
 279:Src/util.c    ****   #endif
 280:Src/util.c    **** 
 281:Src/util.c    ****  #if defined(CONTROL_PWM_LEFT) || defined(CONTROL_PWM_RIGHT)
 282:Src/util.c    ****     PWM_Init();
 283:Src/util.c    ****   #endif
 284:Src/util.c    **** 
 285:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(FEEDBACK_SERIAL_USA
 286:Src/util.c    ****     UART2_Init();
 287:Src/util.c    ****   #endif
 288:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(FEEDBACK_SERIAL_USA
 289:Src/util.c    ****     UART3_Init();
 290:Src/util.c    ****   #endif
 291:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_US
 292:Src/util.c    ****     HAL_UART_Receive_DMA(&huart2, (uint8_t *)rx_buffer_L, sizeof(rx_buffer_L));
 293:Src/util.c    ****     UART_DisableRxErrors(&huart2);
 294:Src/util.c    ****   #endif
 295:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_US
 296:Src/util.c    ****     HAL_UART_Receive_DMA(&huart3, (uint8_t *)rx_buffer_R, sizeof(rx_buffer_R));
 297:Src/util.c    ****     UART_DisableRxErrors(&huart3);
 298:Src/util.c    ****   #endif
 299:Src/util.c    **** 
 300:Src/util.c    ****   #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 301:Src/util.c    ****     uint16_t writeCheck, readVal;
 302:Src/util.c    ****     HAL_FLASH_Unlock();
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 10


 303:Src/util.c    ****     EE_Init();            /* EEPROM Init */
 304:Src/util.c    ****     EE_ReadVariable(VirtAddVarTab[0], &writeCheck);
 305:Src/util.c    ****     if (writeCheck == FLASH_WRITE_KEY) {
 306:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 307:Src/util.c    ****         printf("Using the configuration from EEprom\r\n");
 308:Src/util.c    ****       #endif
 309:Src/util.c    **** 
 310:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[1] , &readVal); rtP_Left.i_max = rtP_Right.i_max = (int16_t)rea
 311:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[2] , &readVal); rtP_Left.n_max = rtP_Right.n_max = (int16_t)rea
 312:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 313:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 314:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 315:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 316:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 317:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 318:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 319:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 320:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 321:Src/util.c    ****       
 322:Src/util.c    ****         printf("Limits Input1: TYP:%i MIN:%i MID:%i MAX:%i\r\nLimits Input2: TYP:%i MIN:%i MID:%i M
 323:Src/util.c    ****           input1[i].typ, input1[i].min, input1[i].mid, input1[i].max,
 324:Src/util.c    ****           input2[i].typ, input2[i].min, input2[i].mid, input2[i].max);
 325:Src/util.c    ****       }
 326:Src/util.c    ****     } else {
 327:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 328:Src/util.c    ****         printf("Using the configuration from config.h\r\n");
 329:Src/util.c    ****       #endif
 330:Src/util.c    **** 
 331:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 332:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 333:Src/util.c    ****           input1[i].typ = checkInputType(input1[i].min, input1[i].mid, input1[i].max);
 334:Src/util.c    ****         } else {
 335:Src/util.c    ****           input1[i].typ = input1[i].typDef;
 336:Src/util.c    ****         }
 337:Src/util.c    ****         if (input2[i].typDef == 3) {
 338:Src/util.c    ****           input2[i].typ = checkInputType(input2[i].min, input2[i].mid, input2[i].max);
 339:Src/util.c    ****         } else {
 340:Src/util.c    ****           input2[i].typ = input2[i].typDef;
 341:Src/util.c    ****         }
 342:Src/util.c    ****         printf("Limits Input1: TYP:%i MIN:%i MID:%i MAX:%i\r\nLimits Input2: TYP:%i MIN:%i MID:%i M
 343:Src/util.c    ****           input1[i].typ, input1[i].min, input1[i].mid, input1[i].max,
 344:Src/util.c    ****           input2[i].typ, input2[i].min, input2[i].mid, input2[i].max);
 345:Src/util.c    ****       }
 346:Src/util.c    ****     }
 347:Src/util.c    ****     HAL_FLASH_Lock();
 348:Src/util.c    ****   #endif
 349:Src/util.c    **** 
 350:Src/util.c    ****   #ifdef VARIANT_TRANSPOTTER
 351:Src/util.c    ****     enable = 1;
 352:Src/util.c    **** 
 353:Src/util.c    ****     HAL_FLASH_Unlock();
 354:Src/util.c    ****     EE_Init();            /* EEPROM Init */
 355:Src/util.c    ****     EE_ReadVariable(VirtAddVarTab[0], &saveValue);
 356:Src/util.c    ****     HAL_FLASH_Lock();
 357:Src/util.c    **** 
 358:Src/util.c    ****     setDistance = saveValue / 1000.0;
 359:Src/util.c    ****     if (setDistance < 0.2) {
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 11


 360:Src/util.c    ****       setDistance = 1.0;
 361:Src/util.c    ****     }
 362:Src/util.c    ****   #endif
 363:Src/util.c    **** 
 364:Src/util.c    ****   #if defined(DEBUG_I2C_LCD) || defined(SUPPORT_LCD)
 365:Src/util.c    ****     I2C_Init();
 366:Src/util.c    ****     HAL_Delay(50);
 367:Src/util.c    ****     lcd.pcf8574.PCF_I2C_ADDRESS = 0x27;
 368:Src/util.c    ****     lcd.pcf8574.PCF_I2C_TIMEOUT = 5;
 369:Src/util.c    ****     lcd.pcf8574.i2c             = hi2c2;
 370:Src/util.c    ****     lcd.NUMBER_OF_LINES         = NUMBER_OF_LINES_2;
 371:Src/util.c    ****     lcd.type                    = TYPE0;
 372:Src/util.c    **** 
 373:Src/util.c    ****     if(LCD_Init(&lcd)!=LCD_OK) {
 374:Src/util.c    ****         // error occured
 375:Src/util.c    ****         //TODO while(1);
 376:Src/util.c    ****     }
 377:Src/util.c    **** 
 378:Src/util.c    ****     LCD_ClearDisplay(&lcd);
 379:Src/util.c    ****     HAL_Delay(5);
 380:Src/util.c    ****     LCD_SetLocation(&lcd, 0, 0);
 381:Src/util.c    ****     #ifdef VARIANT_TRANSPOTTER
 382:Src/util.c    ****       LCD_WriteString(&lcd, "TranspOtter V2.1");
 383:Src/util.c    ****     #else
 384:Src/util.c    ****       LCD_WriteString(&lcd, "Hover V2.0");
 385:Src/util.c    ****     #endif
 386:Src/util.c    ****     LCD_SetLocation(&lcd,  0, 1); LCD_WriteString(&lcd, "Initializing...");
 387:Src/util.c    ****   #endif
 388:Src/util.c    **** 
 389:Src/util.c    ****   #if defined(VARIANT_TRANSPOTTER) && defined(SUPPORT_LCD)
 390:Src/util.c    ****     LCD_ClearDisplay(&lcd);
 391:Src/util.c    ****     HAL_Delay(5);
 392:Src/util.c    ****     LCD_SetLocation(&lcd,  0, 1); LCD_WriteString(&lcd, "Bat:");
 393:Src/util.c    ****     LCD_SetLocation(&lcd,  8, 1); LCD_WriteString(&lcd, "V");
 394:Src/util.c    ****     LCD_SetLocation(&lcd, 15, 1); LCD_WriteString(&lcd, "A");
 395:Src/util.c    ****     LCD_SetLocation(&lcd,  0, 0); LCD_WriteString(&lcd, "Len:");
 396:Src/util.c    ****     LCD_SetLocation(&lcd,  8, 0); LCD_WriteString(&lcd, "m(");
 397:Src/util.c    ****     LCD_SetLocation(&lcd, 14, 0); LCD_WriteString(&lcd, "m)");
 398:Src/util.c    ****   #endif
 399:Src/util.c    **** }
 400:Src/util.c    **** 
 401:Src/util.c    **** /**
 402:Src/util.c    ****   * @brief  Disable Rx Errors detection interrupts on UART peripheral (since we do not want DMA to 
 403:Src/util.c    ****   *         The incorrect data will be filtered based on the START_FRAME and checksum.
 404:Src/util.c    ****   * @param  huart: UART handle.
 405:Src/util.c    ****   * @retval None
 406:Src/util.c    ****   */
 407:Src/util.c    **** #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USAR
 408:Src/util.c    ****     defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_USAR
 409:Src/util.c    **** void UART_DisableRxErrors(UART_HandleTypeDef *huart)
 410:Src/util.c    **** {  
 217              		.loc 1 410 1 is_stmt 1 view -0
 218              		.cfi_startproc
 219              		@ args = 0, pretend = 0, frame = 0
 220              		@ frame_needed = 0, uses_anonymous_args = 0
 221              		@ link register save eliminated.
 411:Src/util.c    ****   CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);    /* Disable PE (Parity Error) interrupts */  
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 12


 222              		.loc 1 411 3 view .LVU62
 223 0000 0268     		ldr	r2, [r0]
 224 0002 D368     		ldr	r3, [r2, #12]
 225 0004 23F48073 		bic	r3, r3, #256
 226 0008 D360     		str	r3, [r2, #12]
 412:Src/util.c    ****   CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);     /* Disable EIE (Frame error, noise error, ove
 227              		.loc 1 412 3 view .LVU63
 228 000a 0268     		ldr	r2, [r0]
 229 000c 5369     		ldr	r3, [r2, #20]
 230 000e 23F00103 		bic	r3, r3, #1
 231 0012 5361     		str	r3, [r2, #20]
 413:Src/util.c    **** }
 232              		.loc 1 413 1 is_stmt 0 view .LVU64
 233 0014 7047     		bx	lr
 234              		.cfi_endproc
 235              	.LFE69:
 237              		.section	.text.poweronMelody,"ax",%progbits
 238              		.align	1
 239              		.global	poweronMelody
 240              		.syntax unified
 241              		.thumb
 242              		.thumb_func
 244              	poweronMelody:
 245              	.LFB70:
 414:Src/util.c    **** #endif
 415:Src/util.c    **** 
 416:Src/util.c    **** 
 417:Src/util.c    **** /* =========================== General Functions =========================== */
 418:Src/util.c    **** 
 419:Src/util.c    **** void poweronMelody(void) {
 246              		.loc 1 419 26 is_stmt 1 view -0
 247              		.cfi_startproc
 248              		@ args = 0, pretend = 0, frame = 0
 249              		@ frame_needed = 0, uses_anonymous_args = 0
 250 0000 10B5     		push	{r4, lr}
 251              	.LCFI1:
 252              		.cfi_def_cfa_offset 8
 253              		.cfi_offset 4, -8
 254              		.cfi_offset 14, -4
 420:Src/util.c    ****     buzzerCount = 0;  // prevent interraction with beep counter
 255              		.loc 1 420 5 view .LVU66
 256              		.loc 1 420 17 is_stmt 0 view .LVU67
 257 0002 084B     		ldr	r3, .L16
 258 0004 0022     		movs	r2, #0
 259 0006 1A70     		strb	r2, [r3]
 421:Src/util.c    ****     for (int i = 8; i >= 0; i--) {
 260              		.loc 1 421 5 is_stmt 1 view .LVU68
 261              	.LBB2:
 262              		.loc 1 421 10 view .LVU69
 263              	.LVL4:
 264              		.loc 1 421 14 is_stmt 0 view .LVU70
 265 0008 0824     		movs	r4, #8
 266              		.loc 1 421 5 view .LVU71
 267 000a 05E0     		b	.L13
 268              	.LVL5:
 269              	.L14:
 422:Src/util.c    ****       buzzerFreq = (uint8_t)i;
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 13


 270              		.loc 1 422 7 is_stmt 1 discriminator 3 view .LVU72
 271              		.loc 1 422 18 is_stmt 0 discriminator 3 view .LVU73
 272 000c 064B     		ldr	r3, .L16+4
 273 000e 1C70     		strb	r4, [r3]
 423:Src/util.c    ****       HAL_Delay(100);
 274              		.loc 1 423 7 is_stmt 1 discriminator 3 view .LVU74
 275 0010 6420     		movs	r0, #100
 276 0012 FFF7FEFF 		bl	HAL_Delay
 277              	.LVL6:
 421:Src/util.c    ****     for (int i = 8; i >= 0; i--) {
 278              		.loc 1 421 29 discriminator 3 view .LVU75
 421:Src/util.c    ****     for (int i = 8; i >= 0; i--) {
 279              		.loc 1 421 30 is_stmt 0 discriminator 3 view .LVU76
 280 0016 013C     		subs	r4, r4, #1
 281              	.LVL7:
 282              	.L13:
 421:Src/util.c    ****     for (int i = 8; i >= 0; i--) {
 283              		.loc 1 421 21 is_stmt 1 discriminator 1 view .LVU77
 421:Src/util.c    ****     for (int i = 8; i >= 0; i--) {
 284              		.loc 1 421 5 is_stmt 0 discriminator 1 view .LVU78
 285 0018 002C     		cmp	r4, #0
 286 001a F7DA     		bge	.L14
 287              	.LBE2:
 424:Src/util.c    ****     }
 425:Src/util.c    ****     buzzerFreq = 0;
 288              		.loc 1 425 5 is_stmt 1 view .LVU79
 289              		.loc 1 425 16 is_stmt 0 view .LVU80
 290 001c 024B     		ldr	r3, .L16+4
 291 001e 0022     		movs	r2, #0
 292 0020 1A70     		strb	r2, [r3]
 426:Src/util.c    **** }
 293              		.loc 1 426 1 view .LVU81
 294 0022 10BD     		pop	{r4, pc}
 295              	.LVL8:
 296              	.L17:
 297              		.loc 1 426 1 view .LVU82
 298              		.align	2
 299              	.L16:
 300 0024 00000000 		.word	buzzerCount
 301 0028 00000000 		.word	buzzerFreq
 302              		.cfi_endproc
 303              	.LFE70:
 305              		.section	.text.beepCount,"ax",%progbits
 306              		.align	1
 307              		.global	beepCount
 308              		.syntax unified
 309              		.thumb
 310              		.thumb_func
 312              	beepCount:
 313              	.LVL9:
 314              	.LFB71:
 427:Src/util.c    **** 
 428:Src/util.c    **** void beepCount(uint8_t cnt, uint8_t freq, uint8_t pattern) {
 315              		.loc 1 428 60 is_stmt 1 view -0
 316              		.cfi_startproc
 317              		@ args = 0, pretend = 0, frame = 0
 318              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 14


 319              		@ link register save eliminated.
 429:Src/util.c    ****     buzzerCount   = cnt;
 320              		.loc 1 429 5 view .LVU84
 321              		.loc 1 429 19 is_stmt 0 view .LVU85
 322 0000 034B     		ldr	r3, .L19
 323 0002 1870     		strb	r0, [r3]
 430:Src/util.c    ****     buzzerFreq    = freq;
 324              		.loc 1 430 5 is_stmt 1 view .LVU86
 325              		.loc 1 430 19 is_stmt 0 view .LVU87
 326 0004 034B     		ldr	r3, .L19+4
 327 0006 1970     		strb	r1, [r3]
 431:Src/util.c    ****     buzzerPattern = pattern;
 328              		.loc 1 431 5 is_stmt 1 view .LVU88
 329              		.loc 1 431 19 is_stmt 0 view .LVU89
 330 0008 034B     		ldr	r3, .L19+8
 331 000a 1A70     		strb	r2, [r3]
 432:Src/util.c    **** }
 332              		.loc 1 432 1 view .LVU90
 333 000c 7047     		bx	lr
 334              	.L20:
 335 000e 00BF     		.align	2
 336              	.L19:
 337 0010 00000000 		.word	buzzerCount
 338 0014 00000000 		.word	buzzerFreq
 339 0018 00000000 		.word	buzzerPattern
 340              		.cfi_endproc
 341              	.LFE71:
 343              		.section	.text.beepLong,"ax",%progbits
 344              		.align	1
 345              		.global	beepLong
 346              		.syntax unified
 347              		.thumb
 348              		.thumb_func
 350              	beepLong:
 351              	.LVL10:
 352              	.LFB72:
 433:Src/util.c    **** 
 434:Src/util.c    **** void beepLong(uint8_t freq) {
 353              		.loc 1 434 29 is_stmt 1 view -0
 354              		.cfi_startproc
 355              		@ args = 0, pretend = 0, frame = 0
 356              		@ frame_needed = 0, uses_anonymous_args = 0
 357              		.loc 1 434 29 is_stmt 0 view .LVU92
 358 0000 38B5     		push	{r3, r4, r5, lr}
 359              	.LCFI2:
 360              		.cfi_def_cfa_offset 16
 361              		.cfi_offset 3, -16
 362              		.cfi_offset 4, -12
 363              		.cfi_offset 5, -8
 364              		.cfi_offset 14, -4
 435:Src/util.c    ****     buzzerCount = 0;  // prevent interraction with beep counter
 365              		.loc 1 435 5 is_stmt 1 view .LVU93
 366              		.loc 1 435 17 is_stmt 0 view .LVU94
 367 0002 0025     		movs	r5, #0
 368 0004 044B     		ldr	r3, .L23
 369 0006 1D70     		strb	r5, [r3]
 436:Src/util.c    ****     buzzerFreq = freq;
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 15


 370              		.loc 1 436 5 is_stmt 1 view .LVU95
 371              		.loc 1 436 16 is_stmt 0 view .LVU96
 372 0008 044C     		ldr	r4, .L23+4
 373 000a 2070     		strb	r0, [r4]
 437:Src/util.c    ****     HAL_Delay(500);
 374              		.loc 1 437 5 is_stmt 1 view .LVU97
 375 000c 4FF4FA70 		mov	r0, #500
 376              	.LVL11:
 377              		.loc 1 437 5 is_stmt 0 view .LVU98
 378 0010 FFF7FEFF 		bl	HAL_Delay
 379              	.LVL12:
 438:Src/util.c    ****     buzzerFreq = 0;
 380              		.loc 1 438 5 is_stmt 1 view .LVU99
 381              		.loc 1 438 16 is_stmt 0 view .LVU100
 382 0014 2570     		strb	r5, [r4]
 439:Src/util.c    **** }
 383              		.loc 1 439 1 view .LVU101
 384 0016 38BD     		pop	{r3, r4, r5, pc}
 385              	.L24:
 386              		.align	2
 387              	.L23:
 388 0018 00000000 		.word	buzzerCount
 389 001c 00000000 		.word	buzzerFreq
 390              		.cfi_endproc
 391              	.LFE72:
 393              		.section	.text.beepShort,"ax",%progbits
 394              		.align	1
 395              		.global	beepShort
 396              		.syntax unified
 397              		.thumb
 398              		.thumb_func
 400              	beepShort:
 401              	.LVL13:
 402              	.LFB73:
 440:Src/util.c    **** 
 441:Src/util.c    **** void beepShort(uint8_t freq) {
 403              		.loc 1 441 30 is_stmt 1 view -0
 404              		.cfi_startproc
 405              		@ args = 0, pretend = 0, frame = 0
 406              		@ frame_needed = 0, uses_anonymous_args = 0
 407              		.loc 1 441 30 is_stmt 0 view .LVU103
 408 0000 38B5     		push	{r3, r4, r5, lr}
 409              	.LCFI3:
 410              		.cfi_def_cfa_offset 16
 411              		.cfi_offset 3, -16
 412              		.cfi_offset 4, -12
 413              		.cfi_offset 5, -8
 414              		.cfi_offset 14, -4
 442:Src/util.c    ****     buzzerCount = 0;  // prevent interraction with beep counter
 415              		.loc 1 442 5 is_stmt 1 view .LVU104
 416              		.loc 1 442 17 is_stmt 0 view .LVU105
 417 0002 0025     		movs	r5, #0
 418 0004 044B     		ldr	r3, .L27
 419 0006 1D70     		strb	r5, [r3]
 443:Src/util.c    ****     buzzerFreq = freq;
 420              		.loc 1 443 5 is_stmt 1 view .LVU106
 421              		.loc 1 443 16 is_stmt 0 view .LVU107
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 16


 422 0008 044C     		ldr	r4, .L27+4
 423 000a 2070     		strb	r0, [r4]
 444:Src/util.c    ****     HAL_Delay(100);
 424              		.loc 1 444 5 is_stmt 1 view .LVU108
 425 000c 6420     		movs	r0, #100
 426              	.LVL14:
 427              		.loc 1 444 5 is_stmt 0 view .LVU109
 428 000e FFF7FEFF 		bl	HAL_Delay
 429              	.LVL15:
 445:Src/util.c    ****     buzzerFreq = 0;
 430              		.loc 1 445 5 is_stmt 1 view .LVU110
 431              		.loc 1 445 16 is_stmt 0 view .LVU111
 432 0012 2570     		strb	r5, [r4]
 446:Src/util.c    **** }
 433              		.loc 1 446 1 view .LVU112
 434 0014 38BD     		pop	{r3, r4, r5, pc}
 435              	.L28:
 436 0016 00BF     		.align	2
 437              	.L27:
 438 0018 00000000 		.word	buzzerCount
 439 001c 00000000 		.word	buzzerFreq
 440              		.cfi_endproc
 441              	.LFE73:
 443              		.section	.text.beepShortMany,"ax",%progbits
 444              		.align	1
 445              		.global	beepShortMany
 446              		.syntax unified
 447              		.thumb
 448              		.thumb_func
 450              	beepShortMany:
 451              	.LVL16:
 452              	.LFB74:
 447:Src/util.c    **** 
 448:Src/util.c    **** void beepShortMany(uint8_t cnt, int8_t dir) {
 453              		.loc 1 448 45 is_stmt 1 view -0
 454              		.cfi_startproc
 455              		@ args = 0, pretend = 0, frame = 0
 456              		@ frame_needed = 0, uses_anonymous_args = 0
 457              		.loc 1 448 45 is_stmt 0 view .LVU114
 458 0000 38B5     		push	{r3, r4, r5, lr}
 459              	.LCFI4:
 460              		.cfi_def_cfa_offset 16
 461              		.cfi_offset 3, -16
 462              		.cfi_offset 4, -12
 463              		.cfi_offset 5, -8
 464              		.cfi_offset 14, -4
 465 0002 0446     		mov	r4, r0
 449:Src/util.c    ****     if (dir >= 0) {   // increasing tone
 466              		.loc 1 449 5 is_stmt 1 view .LVU115
 467              		.loc 1 449 8 is_stmt 0 view .LVU116
 468 0004 0029     		cmp	r1, #0
 469 0006 15DB     		blt	.L35
 450:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 470              		.loc 1 450 7 is_stmt 1 view .LVU117
 471              	.LBB3:
 472              		.loc 1 450 11 view .LVU118
 473              		.loc 1 450 19 is_stmt 0 view .LVU119
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 17


 474 0008 4400     		lsls	r4, r0, #1
 475 000a E4B2     		uxtb	r4, r4
 476              	.LVL17:
 477              		.loc 1 450 7 view .LVU120
 478 000c 05E0     		b	.L31
 479              	.LVL18:
 480              	.L32:
 451:Src/util.c    ****         beepShort(i + 3);
 481              		.loc 1 451 9 is_stmt 1 discriminator 3 view .LVU121
 482 000e E01C     		adds	r0, r4, #3
 483 0010 C0B2     		uxtb	r0, r0
 484 0012 FFF7FEFF 		bl	beepShort
 485              	.LVL19:
 450:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 486              		.loc 1 450 38 discriminator 3 view .LVU122
 450:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 487              		.loc 1 450 39 is_stmt 0 discriminator 3 view .LVU123
 488 0016 023C     		subs	r4, r4, #2
 489              	.LVL20:
 450:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 490              		.loc 1 450 39 discriminator 3 view .LVU124
 491 0018 E4B2     		uxtb	r4, r4
 492              	.LVL21:
 493              	.L31:
 450:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 494              		.loc 1 450 30 is_stmt 1 discriminator 1 view .LVU125
 450:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 495              		.loc 1 450 7 is_stmt 0 discriminator 1 view .LVU126
 496 001a 012C     		cmp	r4, #1
 497 001c F7D8     		bhi	.L32
 498              	.LVL22:
 499              	.L29:
 450:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 500              		.loc 1 450 7 discriminator 1 view .LVU127
 501              	.LBE3:
 452:Src/util.c    ****       }
 453:Src/util.c    ****     } else {          // decreasing tone
 454:Src/util.c    ****       for(uint8_t i = 2; i <= 2*cnt; i=i+2) {
 455:Src/util.c    ****         beepShort(i + 3);
 456:Src/util.c    ****       }
 457:Src/util.c    ****     }
 458:Src/util.c    **** }
 502              		.loc 1 458 1 view .LVU128
 503 001e 38BD     		pop	{r3, r4, r5, pc}
 504              	.LVL23:
 505              	.L34:
 506              	.LBB4:
 455:Src/util.c    ****       }
 507              		.loc 1 455 9 is_stmt 1 discriminator 3 view .LVU129
 508 0020 E81C     		adds	r0, r5, #3
 509 0022 C0B2     		uxtb	r0, r0
 510 0024 FFF7FEFF 		bl	beepShort
 511              	.LVL24:
 454:Src/util.c    ****         beepShort(i + 3);
 512              		.loc 1 454 38 discriminator 3 view .LVU130
 454:Src/util.c    ****         beepShort(i + 3);
 513              		.loc 1 454 39 is_stmt 0 discriminator 3 view .LVU131
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 18


 514 0028 0235     		adds	r5, r5, #2
 515              	.LVL25:
 454:Src/util.c    ****         beepShort(i + 3);
 516              		.loc 1 454 39 discriminator 3 view .LVU132
 517 002a EDB2     		uxtb	r5, r5
 518              	.LVL26:
 519              	.L30:
 454:Src/util.c    ****         beepShort(i + 3);
 520              		.loc 1 454 26 is_stmt 1 discriminator 1 view .LVU133
 454:Src/util.c    ****         beepShort(i + 3);
 521              		.loc 1 454 7 is_stmt 0 discriminator 1 view .LVU134
 522 002c B5EB440F 		cmp	r5, r4, lsl #1
 523 0030 F6DD     		ble	.L34
 524 0032 F4E7     		b	.L29
 525              	.LVL27:
 526              	.L35:
 454:Src/util.c    ****         beepShort(i + 3);
 527              		.loc 1 454 19 view .LVU135
 528 0034 0225     		movs	r5, #2
 529 0036 F9E7     		b	.L30
 530              	.LBE4:
 531              		.cfi_endproc
 532              	.LFE74:
 534              		.section	.text.calcAvgSpeed,"ax",%progbits
 535              		.align	1
 536              		.global	calcAvgSpeed
 537              		.syntax unified
 538              		.thumb
 539              		.thumb_func
 541              	calcAvgSpeed:
 542              	.LFB75:
 459:Src/util.c    **** 
 460:Src/util.c    **** void calcAvgSpeed(void) {
 543              		.loc 1 460 25 is_stmt 1 view -0
 544              		.cfi_startproc
 545              		@ args = 0, pretend = 0, frame = 0
 546              		@ frame_needed = 0, uses_anonymous_args = 0
 547              		@ link register save eliminated.
 461:Src/util.c    ****     // Calculate measured average speed. The minus sign (-) is because motors spin in opposite dire
 462:Src/util.c    ****     speedAvg = 0;
 548              		.loc 1 462 5 view .LVU137
 549              		.loc 1 462 14 is_stmt 0 view .LVU138
 550 0000 0B4A     		ldr	r2, .L38
 551 0002 0023     		movs	r3, #0
 552 0004 1380     		strh	r3, [r2]	@ movhi
 463:Src/util.c    ****     #if defined(MOTOR_LEFT_ENA)
 464:Src/util.c    ****       #if defined(INVERT_L_DIRECTION)
 465:Src/util.c    ****         speedAvg -= rtY_Left.n_mot;
 466:Src/util.c    ****       #else
 467:Src/util.c    ****         speedAvg += rtY_Left.n_mot;
 553              		.loc 1 467 9 is_stmt 1 view .LVU139
 554              		.loc 1 467 29 is_stmt 0 view .LVU140
 555 0006 0B4B     		ldr	r3, .L38+4
 556 0008 B3F90810 		ldrsh	r1, [r3, #8]
 557 000c 8BB2     		uxth	r3, r1
 558              		.loc 1 467 18 view .LVU141
 559 000e 1180     		strh	r1, [r2]	@ movhi
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 19


 468:Src/util.c    ****       #endif
 469:Src/util.c    ****     #endif
 470:Src/util.c    ****     #if defined(MOTOR_RIGHT_ENA)
 471:Src/util.c    ****       #if defined(INVERT_R_DIRECTION)
 472:Src/util.c    ****         speedAvg += rtY_Right.n_mot;
 473:Src/util.c    ****       #else
 474:Src/util.c    ****         speedAvg -= rtY_Right.n_mot;
 560              		.loc 1 474 9 is_stmt 1 view .LVU142
 561              		.loc 1 474 30 is_stmt 0 view .LVU143
 562 0010 0949     		ldr	r1, .L38+8
 563 0012 0989     		ldrh	r1, [r1, #8]
 564              		.loc 1 474 18 view .LVU144
 565 0014 5B1A     		subs	r3, r3, r1
 566 0016 1BB2     		sxth	r3, r3
 567 0018 1380     		strh	r3, [r2]	@ movhi
 475:Src/util.c    ****       #endif
 476:Src/util.c    **** 
 477:Src/util.c    ****       // Average only if both motors are enabled
 478:Src/util.c    ****       #if defined(MOTOR_LEFT_ENA)
 479:Src/util.c    ****         speedAvg /= 2;
 568              		.loc 1 479 9 is_stmt 1 view .LVU145
 569              		.loc 1 479 18 is_stmt 0 view .LVU146
 570 001a 03EBD373 		add	r3, r3, r3, lsr #31
 571 001e 5B10     		asrs	r3, r3, #1
 572 0020 1380     		strh	r3, [r2]	@ movhi
 480:Src/util.c    ****       #endif  
 481:Src/util.c    ****     #endif
 482:Src/util.c    **** 
 483:Src/util.c    ****     // Handle the case when SPEED_COEFFICIENT sign is negative (which is when most significant bit 
 484:Src/util.c    ****     if (SPEED_COEFFICIENT & (1 << 16)) {
 573              		.loc 1 484 5 is_stmt 1 view .LVU147
 485:Src/util.c    ****       speedAvg    = -speedAvg;
 486:Src/util.c    ****     } 
 487:Src/util.c    ****     speedAvgAbs   = abs(speedAvg);
 574              		.loc 1 487 5 view .LVU148
 575              		.loc 1 487 21 is_stmt 0 view .LVU149
 576 0022 002B     		cmp	r3, #0
 577 0024 B8BF     		it	lt
 578 0026 5B42     		rsblt	r3, r3, #0
 579              		.loc 1 487 19 view .LVU150
 580 0028 044A     		ldr	r2, .L38+12
 581 002a 1380     		strh	r3, [r2]	@ movhi
 488:Src/util.c    **** }
 582              		.loc 1 488 1 view .LVU151
 583 002c 7047     		bx	lr
 584              	.L39:
 585 002e 00BF     		.align	2
 586              	.L38:
 587 0030 00000000 		.word	.LANCHOR11
 588 0034 00000000 		.word	.LANCHOR4
 589 0038 00000000 		.word	.LANCHOR8
 590 003c 00000000 		.word	.LANCHOR12
 591              		.cfi_endproc
 592              	.LFE75:
 594              		.section	.text.standstillHold,"ax",%progbits
 595              		.align	1
 596              		.global	standstillHold
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 20


 597              		.syntax unified
 598              		.thumb
 599              		.thumb_func
 601              	standstillHold:
 602              	.LFB78:
 489:Src/util.c    **** 
 490:Src/util.c    ****  /*
 491:Src/util.c    ****  * Auto-calibration of the ADC Limits
 492:Src/util.c    ****  * This function finds the Minimum, Maximum, and Middle for the ADC input
 493:Src/util.c    ****  * Procedure:
 494:Src/util.c    ****  * - press the power button for more than 5 sec and release after the beep sound
 495:Src/util.c    ****  * - move the potentiometers freely to the min and max limits repeatedly
 496:Src/util.c    ****  * - release potentiometers to the resting postion
 497:Src/util.c    ****  * - press the power button to confirm or wait for the 20 sec timeout
 498:Src/util.c    ****  * The Values will be saved to flash. Values are persistent if you flash with platformio. To erase 
 499:Src/util.c    ****  */
 500:Src/util.c    **** void adcCalibLim(void) {
 501:Src/util.c    **** #ifdef AUTO_CALIBRATION_ENA
 502:Src/util.c    ****   calcAvgSpeed();
 503:Src/util.c    ****   if (speedAvgAbs > 5) {    // do not enter this mode if motors are spinning
 504:Src/util.c    ****     return;
 505:Src/util.c    ****   }
 506:Src/util.c    **** 
 507:Src/util.c    **** #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 508:Src/util.c    **** 
 509:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 510:Src/util.c    ****   printf("Input calibration started...\r\n");
 511:Src/util.c    ****   #endif
 512:Src/util.c    **** 
 513:Src/util.c    ****   readInputRaw();
 514:Src/util.c    ****   // Inititalization: MIN = a high value, MAX = a low value
 515:Src/util.c    ****   int32_t  input1_fixdt = input1[inIdx].raw << 16;
 516:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 517:Src/util.c    ****   int16_t  INPUT1_MIN_temp = MAX_int16_T;
 518:Src/util.c    ****   int16_t  INPUT1_MID_temp = 0;
 519:Src/util.c    ****   int16_t  INPUT1_MAX_temp = MIN_int16_T;
 520:Src/util.c    ****   int16_t  INPUT2_MIN_temp = MAX_int16_T;
 521:Src/util.c    ****   int16_t  INPUT2_MID_temp = 0;
 522:Src/util.c    ****   int16_t  INPUT2_MAX_temp = MIN_int16_T;
 523:Src/util.c    ****   int16_t  input_margin    = 0;
 524:Src/util.c    ****   uint16_t input_cal_timeout = 0;
 525:Src/util.c    ****   
 526:Src/util.c    ****   #ifdef CONTROL_ADC
 527:Src/util.c    ****   if (inIdx == CONTROL_ADC) {
 528:Src/util.c    ****     input_margin = ADC_MARGIN;
 529:Src/util.c    ****   }
 530:Src/util.c    ****   #endif
 531:Src/util.c    **** 
 532:Src/util.c    ****   // Extract MIN, MAX and MID from ADC while the power button is not pressed
 533:Src/util.c    ****   while (!HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN) && input_cal_timeout++ < 4000) {   // 20 sec ti
 534:Src/util.c    ****     readInputRaw();
 535:Src/util.c    ****     filtLowPass32(input1[inIdx].raw, FILTER, &input1_fixdt);
 536:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 537:Src/util.c    ****     
 538:Src/util.c    ****     INPUT1_MID_temp = (int16_t)(input1_fixdt >> 16);// CLAMP(input1_fixdt >> 16, INPUT1_MIN, INPUT1
 539:Src/util.c    ****     INPUT2_MID_temp = (int16_t)(input2_fixdt >> 16);// CLAMP(input2_fixdt >> 16, INPUT2_MIN, INPUT2
 540:Src/util.c    ****     INPUT1_MIN_temp = MIN(INPUT1_MIN_temp, INPUT1_MID_temp);
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 21


 541:Src/util.c    ****     INPUT1_MAX_temp = MAX(INPUT1_MAX_temp, INPUT1_MID_temp);
 542:Src/util.c    ****     INPUT2_MIN_temp = MIN(INPUT2_MIN_temp, INPUT2_MID_temp);
 543:Src/util.c    ****     INPUT2_MAX_temp = MAX(INPUT2_MAX_temp, INPUT2_MID_temp);
 544:Src/util.c    ****     HAL_Delay(5);
 545:Src/util.c    ****   }
 546:Src/util.c    **** 
 547:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 548:Src/util.c    ****   printf("Input1 is ");
 549:Src/util.c    ****   #endif
 550:Src/util.c    ****   uint8_t input1TypTemp = checkInputType(INPUT1_MIN_temp, INPUT1_MID_temp, INPUT1_MAX_temp);
 551:Src/util.c    ****   if (input1TypTemp == input1[inIdx].typDef || input1[inIdx].typDef == 3) {  // Accept calibration 
 552:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 553:Src/util.c    ****     printf("..OK\r\n");
 554:Src/util.c    ****     #endif
 555:Src/util.c    ****   } else {
 556:Src/util.c    ****     input1TypTemp = 0; // Disable input
 557:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 558:Src/util.c    ****     printf("..NOK\r\n");
 559:Src/util.c    ****     #endif
 560:Src/util.c    ****   }
 561:Src/util.c    **** 
 562:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 563:Src/util.c    ****   printf("Input2 is ");
 564:Src/util.c    ****   #endif
 565:Src/util.c    ****   uint8_t input2TypTemp = checkInputType(INPUT2_MIN_temp, INPUT2_MID_temp, INPUT2_MAX_temp);
 566:Src/util.c    ****   if (input2TypTemp == input2[inIdx].typDef || input2[inIdx].typDef == 3) {  // Accept calibration 
 567:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 568:Src/util.c    ****     printf("..OK\r\n");
 569:Src/util.c    ****     #endif
 570:Src/util.c    ****   } else {
 571:Src/util.c    ****     input2TypTemp = 0; // Disable input
 572:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 573:Src/util.c    ****     printf("..NOK\r\n");
 574:Src/util.c    ****     #endif
 575:Src/util.c    ****   }
 576:Src/util.c    **** 
 577:Src/util.c    **** 
 578:Src/util.c    ****   // At least one of the inputs is not ignored
 579:Src/util.c    ****   if (input1TypTemp != 0 || input2TypTemp != 0){
 580:Src/util.c    ****     input1[inIdx].typ = input1TypTemp;
 581:Src/util.c    ****     input1[inIdx].min = INPUT1_MIN_temp + input_margin;
 582:Src/util.c    ****     input1[inIdx].mid = INPUT1_MID_temp;
 583:Src/util.c    ****     input1[inIdx].max = INPUT1_MAX_temp - input_margin;
 584:Src/util.c    **** 
 585:Src/util.c    ****     input2[inIdx].typ = input2TypTemp;
 586:Src/util.c    ****     input2[inIdx].min = INPUT2_MIN_temp + input_margin;
 587:Src/util.c    ****     input2[inIdx].mid = INPUT2_MID_temp;
 588:Src/util.c    ****     input2[inIdx].max = INPUT2_MAX_temp - input_margin;
 589:Src/util.c    **** 
 590:Src/util.c    ****     inp_cal_valid = 1;    // Mark calibration to be saved in Flash at shutdown
 591:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 592:Src/util.c    ****     printf("Limits Input1: TYP:%i MIN:%i MID:%i MAX:%i\r\nLimits Input2: TYP:%i MIN:%i MID:%i MAX:%
 593:Src/util.c    ****             input1[inIdx].typ, input1[inIdx].min, input1[inIdx].mid, input1[inIdx].max,
 594:Src/util.c    ****             input2[inIdx].typ, input2[inIdx].min, input2[inIdx].mid, input2[inIdx].max);
 595:Src/util.c    ****     #endif
 596:Src/util.c    ****   }else{
 597:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 22


 598:Src/util.c    ****     printf("Both inputs cannot be ignored, calibration rejected.\r\n");
 599:Src/util.c    ****     #endif
 600:Src/util.c    ****   }
 601:Src/util.c    **** 
 602:Src/util.c    **** #endif
 603:Src/util.c    **** #endif  // AUTO_CALIBRATION_ENA
 604:Src/util.c    **** }
 605:Src/util.c    ****  /*
 606:Src/util.c    ****  * Update Maximum Motor Current Limit (via ADC1) and Maximum Speed Limit (via ADC2)
 607:Src/util.c    ****  * Procedure:
 608:Src/util.c    ****  * - press the power button for more than 5 sec and immediatelly after the beep sound press one mor
 609:Src/util.c    ****  * - move and hold the pots to a desired limit position for Current and Speed
 610:Src/util.c    ****  * - press the power button to confirm or wait for the 10 sec timeout
 611:Src/util.c    ****  */
 612:Src/util.c    **** void updateCurSpdLim(void) {
 613:Src/util.c    ****   calcAvgSpeed();
 614:Src/util.c    ****   if (speedAvgAbs > 5) {    // do not enter this mode if motors are spinning
 615:Src/util.c    ****     return;
 616:Src/util.c    ****   }
 617:Src/util.c    **** 
 618:Src/util.c    **** #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 619:Src/util.c    **** 
 620:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 621:Src/util.c    ****   printf("Torque and Speed limits update started...\r\n");
 622:Src/util.c    ****   #endif
 623:Src/util.c    **** 
 624:Src/util.c    ****   int32_t  input1_fixdt = input1[inIdx].raw << 16;
 625:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 626:Src/util.c    ****   uint16_t cur_factor;    // fixdt(0,16,16)
 627:Src/util.c    ****   uint16_t spd_factor;    // fixdt(0,16,16)
 628:Src/util.c    ****   uint16_t cur_spd_timeout = 0;
 629:Src/util.c    ****   cur_spd_valid = 0;
 630:Src/util.c    **** 
 631:Src/util.c    ****   // Wait for the power button press
 632:Src/util.c    ****   while (!HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN) && cur_spd_timeout++ < 2000) {  // 10 sec timeo
 633:Src/util.c    ****     readInputRaw();
 634:Src/util.c    ****     filtLowPass32(input1[inIdx].raw, FILTER, &input1_fixdt);
 635:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 636:Src/util.c    ****     HAL_Delay(5);
 637:Src/util.c    ****   }
 638:Src/util.c    ****   // Calculate scaling factors
 639:Src/util.c    ****   cur_factor = CLAMP((input1_fixdt - (input1[inIdx].min << 16)) / (input1[inIdx].max - input1[inIdx
 640:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 641:Src/util.c    ****       
 642:Src/util.c    ****   if (input1[inIdx].typ != 0){
 643:Src/util.c    ****     // Update current limit
 644:Src/util.c    ****     rtP_Left.i_max = rtP_Right.i_max  = (int16_t)((I_MOT_MAX * A2BIT_CONV * cur_factor) >> 12);    
 645:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 646:Src/util.c    ****   }
 647:Src/util.c    **** 
 648:Src/util.c    ****   if (input2[inIdx].typ != 0){
 649:Src/util.c    ****     // Update speed limit
 650:Src/util.c    ****     rtP_Left.n_max = rtP_Right.n_max  = (int16_t)((N_MOT_MAX * spd_factor) >> 12);                 
 651:Src/util.c    ****     cur_spd_valid  += 2;  // Mark update to be saved in Flash at shutdown
 652:Src/util.c    ****   }
 653:Src/util.c    **** 
 654:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 23


 655:Src/util.c    ****   // cur_spd_valid: 0 = No limit changed, 1 = Current limit changed, 2 = Speed limit changed, 3 = B
 656:Src/util.c    ****   printf("Limits (%i)\r\nCurrent: fixdt:%li factor%i i_max:%i \r\nSpeed: fixdt:%li factor:%i n_max:
 657:Src/util.c    ****           cur_spd_valid, input1_fixdt, cur_factor, rtP_Left.i_max, input2_fixdt, spd_factor, rtP_Le
 658:Src/util.c    ****   #endif
 659:Src/util.c    **** 
 660:Src/util.c    **** #endif
 661:Src/util.c    **** }
 662:Src/util.c    **** 
 663:Src/util.c    ****  /*
 664:Src/util.c    ****  * Standstill Hold Function
 665:Src/util.c    ****  * This function uses Cruise Control to provide an anti-roll functionality at standstill.
 666:Src/util.c    ****  * Only available and makes sense for FOC VOLTAGE or FOC TORQUE mode.
 667:Src/util.c    ****  * 
 668:Src/util.c    ****  * Input:  none
 669:Src/util.c    ****  * Output: standstillAcv
 670:Src/util.c    ****  */
 671:Src/util.c    **** void standstillHold(void) {
 603              		.loc 1 671 27 is_stmt 1 view -0
 604              		.cfi_startproc
 605              		@ args = 0, pretend = 0, frame = 0
 606              		@ frame_needed = 0, uses_anonymous_args = 0
 607              		@ link register save eliminated.
 672:Src/util.c    ****   #if defined(STANDSTILL_HOLD_ENABLE) && (CTRL_TYP_SEL == FOC_CTRL) && (CTRL_MOD_REQ != SPD_MODE)
 673:Src/util.c    ****     if (!rtP_Left.b_cruiseCtrlEna) {                                  // If Stanstill in NOT Active
 674:Src/util.c    ****       if (((input1[inIdx].cmd > 50 || input2[inIdx].cmd < -50) && speedAvgAbs < 30) // Check if Bra
 675:Src/util.c    ****           || (input2[inIdx].cmd < 20 && speedAvgAbs < 5)) {           // OR Throttle is small AND m
 676:Src/util.c    ****         rtP_Left.n_cruiseMotTgt   = 0;
 677:Src/util.c    ****         rtP_Right.n_cruiseMotTgt  = 0;
 678:Src/util.c    ****         rtP_Left.b_cruiseCtrlEna  = 1;
 679:Src/util.c    ****         rtP_Right.b_cruiseCtrlEna = 1;
 680:Src/util.c    ****         standstillAcv = 1;
 681:Src/util.c    ****       } 
 682:Src/util.c    ****     }
 683:Src/util.c    ****     else {                                                            // If Stanstill is Active -> 
 684:Src/util.c    ****       if (input1[inIdx].cmd < 20 && input2[inIdx].cmd > 50 && !cruiseCtrlAcv) { // Check if Brake i
 685:Src/util.c    ****         rtP_Left.b_cruiseCtrlEna  = 0;
 686:Src/util.c    ****         rtP_Right.b_cruiseCtrlEna = 0;
 687:Src/util.c    ****         standstillAcv = 0;
 688:Src/util.c    ****       }
 689:Src/util.c    ****     }
 690:Src/util.c    ****   #endif
 691:Src/util.c    **** }
 608              		.loc 1 691 1 view .LVU153
 609 0000 7047     		bx	lr
 610              		.cfi_endproc
 611              	.LFE78:
 613              		.section	.text.electricBrake,"ax",%progbits
 614              		.align	1
 615              		.global	electricBrake
 616              		.syntax unified
 617              		.thumb
 618              		.thumb_func
 620              	electricBrake:
 621              	.LVL28:
 622              	.LFB79:
 692:Src/util.c    **** 
 693:Src/util.c    ****  /*
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 24


 694:Src/util.c    ****  * Electric Brake Function
 695:Src/util.c    ****  * In case of TORQUE mode, this function replaces the motor "freewheel" with a constant braking whe
 696:Src/util.c    ****  * This is useful when a small amount of motor braking is desired instead of "freewheel".
 697:Src/util.c    ****  * 
 698:Src/util.c    ****  * Input: speedBlend = fixdt(0,16,15), reverseDir = {0, 1}
 699:Src/util.c    ****  * Output: input2.cmd (Throtle) with brake component included
 700:Src/util.c    ****  */
 701:Src/util.c    **** void electricBrake(uint16_t speedBlend, uint8_t reverseDir) {
 623              		.loc 1 701 61 view -0
 624              		.cfi_startproc
 625              		@ args = 0, pretend = 0, frame = 0
 626              		@ frame_needed = 0, uses_anonymous_args = 0
 627              		@ link register save eliminated.
 702:Src/util.c    ****   #if defined(ELECTRIC_BRAKE_ENABLE) && (CTRL_TYP_SEL == FOC_CTRL) && (CTRL_MOD_REQ == TRQ_MODE)
 703:Src/util.c    ****     int16_t brakeVal;
 704:Src/util.c    **** 
 705:Src/util.c    ****     // Make sure the Brake pedal is opposite to the direction of motion AND it goes to 0 as we reac
 706:Src/util.c    ****     if (speedAvg > 0) {
 707:Src/util.c    ****       brakeVal = (int16_t)((-ELECTRIC_BRAKE_MAX * speedBlend) >> 15);
 708:Src/util.c    ****     } else {
 709:Src/util.c    ****       brakeVal = (int16_t)(( ELECTRIC_BRAKE_MAX * speedBlend) >> 15);
 710:Src/util.c    ****     }
 711:Src/util.c    **** 
 712:Src/util.c    ****     // Check if direction is reversed
 713:Src/util.c    ****     if (reverseDir) {
 714:Src/util.c    ****       brakeVal = -brakeVal;
 715:Src/util.c    ****     }
 716:Src/util.c    **** 
 717:Src/util.c    ****     // Calculate the new input2.cmd with brake component included
 718:Src/util.c    ****     if (input2[inIdx].cmd >= 0 && input2[inIdx].cmd < ELECTRIC_BRAKE_THRES) {
 719:Src/util.c    ****       input2[inIdx].cmd = MAX(brakeVal, ((ELECTRIC_BRAKE_THRES - input2[inIdx].cmd) * brakeVal) / E
 720:Src/util.c    ****     } else if (input2[inIdx].cmd >= -ELECTRIC_BRAKE_THRES && input2[inIdx].cmd < 0) {
 721:Src/util.c    ****       input2[inIdx].cmd = MIN(brakeVal, ((ELECTRIC_BRAKE_THRES + input2[inIdx].cmd) * brakeVal) / E
 722:Src/util.c    ****     } else if (input2[inIdx].cmd >= ELECTRIC_BRAKE_THRES) {
 723:Src/util.c    ****       input2[inIdx].cmd = MAX(brakeVal, ((input2[inIdx].cmd - ELECTRIC_BRAKE_THRES) * INPUT_MAX) / 
 724:Src/util.c    ****     } else {  // when (input2.cmd < -ELECTRIC_BRAKE_THRES)
 725:Src/util.c    ****       input2[inIdx].cmd = MIN(brakeVal, ((input2[inIdx].cmd + ELECTRIC_BRAKE_THRES) * INPUT_MIN) / 
 726:Src/util.c    ****     }
 727:Src/util.c    ****   #endif
 728:Src/util.c    **** }
 628              		.loc 1 728 1 view .LVU155
 629 0000 7047     		bx	lr
 630              		.cfi_endproc
 631              	.LFE79:
 633              		.section	.text.cruiseControl,"ax",%progbits
 634              		.align	1
 635              		.global	cruiseControl
 636              		.syntax unified
 637              		.thumb
 638              		.thumb_func
 640              	cruiseControl:
 641              	.LVL29:
 642              	.LFB80:
 729:Src/util.c    **** 
 730:Src/util.c    ****  /*
 731:Src/util.c    ****  * Cruise Control Function
 732:Src/util.c    ****  * This function activates/deactivates cruise control.
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 25


 733:Src/util.c    ****  * 
 734:Src/util.c    ****  * Input: button (as a pulse)
 735:Src/util.c    ****  * Output: cruiseCtrlAcv
 736:Src/util.c    ****  */
 737:Src/util.c    **** void cruiseControl(uint8_t button) {
 643              		.loc 1 737 36 view -0
 644              		.cfi_startproc
 645              		@ args = 0, pretend = 0, frame = 0
 646              		@ frame_needed = 0, uses_anonymous_args = 0
 647              		@ link register save eliminated.
 738:Src/util.c    ****   #ifdef CRUISE_CONTROL_SUPPORT
 739:Src/util.c    ****     if (button && !rtP_Left.b_cruiseCtrlEna) {                          // Cruise control activated
 740:Src/util.c    ****       rtP_Left.n_cruiseMotTgt   = rtY_Left.n_mot;
 741:Src/util.c    ****       rtP_Right.n_cruiseMotTgt  = rtY_Right.n_mot;
 742:Src/util.c    ****       rtP_Left.b_cruiseCtrlEna  = 1;
 743:Src/util.c    ****       rtP_Right.b_cruiseCtrlEna = 1;
 744:Src/util.c    ****       cruiseCtrlAcv = 1;
 745:Src/util.c    ****       beepShortMany(2, 1);                                              // 200 ms beep delay. Acts 
 746:Src/util.c    ****     } else if (button && rtP_Left.b_cruiseCtrlEna && !standstillAcv) {  // Cruise control deactivat
 747:Src/util.c    ****       rtP_Left.b_cruiseCtrlEna  = 0;
 748:Src/util.c    ****       rtP_Right.b_cruiseCtrlEna = 0;
 749:Src/util.c    ****       cruiseCtrlAcv = 0;
 750:Src/util.c    ****       beepShortMany(2, -1);
 751:Src/util.c    ****     }
 752:Src/util.c    ****   #endif
 753:Src/util.c    **** }
 648              		.loc 1 753 1 view .LVU157
 649 0000 7047     		bx	lr
 650              		.cfi_endproc
 651              	.LFE80:
 653              		.section	.text.checkInputType,"ax",%progbits
 654              		.align	1
 655              		.global	checkInputType
 656              		.syntax unified
 657              		.thumb
 658              		.thumb_func
 660              	checkInputType:
 661              	.LVL30:
 662              	.LFB81:
 754:Src/util.c    **** 
 755:Src/util.c    ****  /*
 756:Src/util.c    ****  * Check Input Type
 757:Src/util.c    ****  * This function identifies the input type: 0: Disabled, 1: Normal Pot, 2: Middle Resting Pot
 758:Src/util.c    ****  */
 759:Src/util.c    **** int checkInputType(int16_t min, int16_t mid, int16_t max){
 663              		.loc 1 759 58 view -0
 664              		.cfi_startproc
 665              		@ args = 0, pretend = 0, frame = 0
 666              		@ frame_needed = 0, uses_anonymous_args = 0
 667              		.loc 1 759 58 is_stmt 0 view .LVU159
 668 0000 10B5     		push	{r4, lr}
 669              	.LCFI5:
 670              		.cfi_def_cfa_offset 8
 671              		.cfi_offset 4, -8
 672              		.cfi_offset 14, -4
 760:Src/util.c    **** 
 761:Src/util.c    ****   int type = 0;  
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 26


 673              		.loc 1 761 3 is_stmt 1 view .LVU160
 674              	.LVL31:
 762:Src/util.c    ****   #ifdef CONTROL_ADC
 763:Src/util.c    ****   int16_t threshold = 400;      // Threshold to define if values are too close
 764:Src/util.c    ****   #else
 765:Src/util.c    ****   int16_t threshold = 200;
 675              		.loc 1 765 3 view .LVU161
 766:Src/util.c    ****   #endif
 767:Src/util.c    **** 
 768:Src/util.c    ****   if ((min / threshold) == (max / threshold) || (mid / threshold) == (max / threshold) || min > max
 676              		.loc 1 768 3 view .LVU162
 677              		.loc 1 768 12 is_stmt 0 view .LVU163
 678 0002 154B     		ldr	r3, .L52
 679 0004 83FB00C4 		smull	ip, r4, r3, r0
 680 0008 4FEAE07E 		asr	lr, r0, #31
 681 000c CEEBA41E 		rsb	lr, lr, r4, asr #6
 682              		.loc 1 768 33 view .LVU164
 683 0010 83FB0243 		smull	r4, r3, r3, r2
 684 0014 4FEAE27C 		asr	ip, r2, #31
 685 0018 CCEBA313 		rsb	r3, ip, r3, asr #6
 686              		.loc 1 768 6 view .LVU165
 687 001c 9E45     		cmp	lr, r3
 688 001e 12D0     		beq	.L45
 689              		.loc 1 768 54 discriminator 1 view .LVU166
 690 0020 0D4C     		ldr	r4, .L52
 691 0022 84FB01C4 		smull	ip, r4, r4, r1
 692 0026 4FEAE17C 		asr	ip, r1, #31
 693 002a CCEBA41C 		rsb	ip, ip, r4, asr #6
 694              		.loc 1 768 46 discriminator 1 view .LVU167
 695 002e 6345     		cmp	r3, ip
 696 0030 0BD0     		beq	.L46
 697              		.loc 1 768 88 discriminator 2 view .LVU168
 698 0032 9042     		cmp	r0, r2
 699 0034 0BDC     		bgt	.L47
 700              		.loc 1 768 101 discriminator 3 view .LVU169
 701 0036 8A42     		cmp	r2, r1
 702 0038 0BDB     		blt	.L48
 769:Src/util.c    ****     type = 0;
 770:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 771:Src/util.c    ****     printf("ignored");                // (MIN and MAX) OR (MID and MAX) are close, disable input
 772:Src/util.c    ****     #endif
 773:Src/util.c    ****   } else {
 774:Src/util.c    ****     if ((min / threshold) == (mid / threshold)){
 703              		.loc 1 774 5 is_stmt 1 view .LVU170
 704              		.loc 1 774 8 is_stmt 0 view .LVU171
 705 003a E645     		cmp	lr, ip
 706 003c 01D0     		beq	.L51
 775:Src/util.c    ****       type = 1;
 776:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 777:Src/util.c    ****       printf("a normal pot");        // MIN and MID are close, it's a normal pot
 778:Src/util.c    ****       #endif
 779:Src/util.c    ****     } else {
 780:Src/util.c    ****       type = 2;
 707              		.loc 1 780 12 view .LVU172
 708 003e 0220     		movs	r0, #2
 709              	.LVL32:
 781:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 27


 782:Src/util.c    ****       printf("a mid-resting pot");   // it's a mid resting pot
 783:Src/util.c    ****       #endif
 784:Src/util.c    ****     }
 785:Src/util.c    **** 
 786:Src/util.c    ****     #ifdef CONTROL_ADC
 787:Src/util.c    ****     if ((min + ADC_MARGIN - ADC_PROTECT_THRESH) > 0 && (max - ADC_MARGIN + ADC_PROTECT_THRESH) < 40
 788:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 789:Src/util.c    ****       printf(" AND protected");
 790:Src/util.c    ****       #endif
 791:Src/util.c    ****       beepLong(2); // Indicate protection by a beep
 792:Src/util.c    ****     }
 793:Src/util.c    ****     #endif
 794:Src/util.c    ****   }
 795:Src/util.c    **** 
 796:Src/util.c    ****   return type;
 710              		.loc 1 796 3 is_stmt 1 view .LVU173
 711              		.loc 1 796 10 is_stmt 0 view .LVU174
 712 0040 02E0     		b	.L43
 713              	.LVL33:
 714              	.L51:
 775:Src/util.c    ****       type = 1;
 715              		.loc 1 775 12 view .LVU175
 716 0042 0120     		movs	r0, #1
 717              	.LVL34:
 775:Src/util.c    ****       type = 1;
 718              		.loc 1 775 12 view .LVU176
 719 0044 00E0     		b	.L43
 720              	.LVL35:
 721              	.L45:
 769:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 722              		.loc 1 769 10 view .LVU177
 723 0046 0020     		movs	r0, #0
 724              	.LVL36:
 725              	.L43:
 797:Src/util.c    **** }
 726              		.loc 1 797 1 view .LVU178
 727 0048 10BD     		pop	{r4, pc}
 728              	.LVL37:
 729              	.L46:
 769:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 730              		.loc 1 769 10 view .LVU179
 731 004a 0020     		movs	r0, #0
 732              	.LVL38:
 769:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 733              		.loc 1 769 10 view .LVU180
 734 004c FCE7     		b	.L43
 735              	.LVL39:
 736              	.L47:
 769:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 737              		.loc 1 769 10 view .LVU181
 738 004e 0020     		movs	r0, #0
 739              	.LVL40:
 769:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 740              		.loc 1 769 10 view .LVU182
 741 0050 FAE7     		b	.L43
 742              	.LVL41:
 743              	.L48:
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 28


 769:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 744              		.loc 1 769 10 view .LVU183
 745 0052 0020     		movs	r0, #0
 746              	.LVL42:
 769:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 747              		.loc 1 769 10 view .LVU184
 748 0054 F8E7     		b	.L43
 749              	.L53:
 750 0056 00BF     		.align	2
 751              	.L52:
 752 0058 1F85EB51 		.word	1374389535
 753              		.cfi_endproc
 754              	.LFE81:
 756              		.section	.rodata.Input_Init.str1.4,"aMS",%progbits,1
 757              		.align	2
 758              	.LC0:
 759 0000 4C696D69 		.ascii	"Limits Input1: TYP:%i MIN:%i MID:%i MAX:%i\015\012L"
 759      74732049 
 759      6E707574 
 759      313A2054 
 759      59503A25 
 760 002d 696D6974 		.ascii	"imits Input2: TYP:%i MIN:%i MID:%i MAX:%i\015\012\000"
 760      7320496E 
 760      70757432 
 760      3A205459 
 760      503A2569 
 761              		.section	.text.Input_Init,"ax",%progbits
 762              		.align	1
 763              		.global	Input_Init
 764              		.syntax unified
 765              		.thumb
 766              		.thumb_func
 768              	Input_Init:
 769              	.LFB68:
 276:Src/util.c    ****   #if defined(CONTROL_PPM_LEFT) || defined(CONTROL_PPM_RIGHT)
 770              		.loc 1 276 23 is_stmt 1 view -0
 771              		.cfi_startproc
 772              		@ args = 0, pretend = 0, frame = 8
 773              		@ frame_needed = 0, uses_anonymous_args = 0
 774 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 775              	.LCFI6:
 776              		.cfi_def_cfa_offset 32
 777              		.cfi_offset 4, -32
 778              		.cfi_offset 5, -28
 779              		.cfi_offset 6, -24
 780              		.cfi_offset 7, -20
 781              		.cfi_offset 8, -16
 782              		.cfi_offset 9, -12
 783              		.cfi_offset 10, -8
 784              		.cfi_offset 14, -4
 785 0004 88B0     		sub	sp, sp, #32
 786              	.LCFI7:
 787              		.cfi_def_cfa_offset 64
 286:Src/util.c    ****   #endif
 788              		.loc 1 286 5 view .LVU186
 789 0006 FFF7FEFF 		bl	UART2_Init
 790              	.LVL43:
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 29


 292:Src/util.c    ****     UART_DisableRxErrors(&huart2);
 791              		.loc 1 292 5 view .LVU187
 792 000a 854C     		ldr	r4, .L69
 793 000c 4022     		movs	r2, #64
 794 000e 8549     		ldr	r1, .L69+4
 795 0010 2046     		mov	r0, r4
 796 0012 FFF7FEFF 		bl	HAL_UART_Receive_DMA
 797              	.LVL44:
 293:Src/util.c    ****   #endif
 798              		.loc 1 293 5 view .LVU188
 799 0016 2046     		mov	r0, r4
 800 0018 FFF7FEFF 		bl	UART_DisableRxErrors
 801              	.LVL45:
 301:Src/util.c    ****     HAL_FLASH_Unlock();
 802              		.loc 1 301 5 view .LVU189
 302:Src/util.c    ****     EE_Init();            /* EEPROM Init */
 803              		.loc 1 302 5 view .LVU190
 804 001c FFF7FEFF 		bl	HAL_FLASH_Unlock
 805              	.LVL46:
 303:Src/util.c    ****     EE_ReadVariable(VirtAddVarTab[0], &writeCheck);
 806              		.loc 1 303 5 view .LVU191
 807 0020 FFF7FEFF 		bl	EE_Init
 808              	.LVL47:
 304:Src/util.c    ****     if (writeCheck == FLASH_WRITE_KEY) {
 809              		.loc 1 304 5 view .LVU192
 810 0024 0DF11E01 		add	r1, sp, #30
 811 0028 7F4B     		ldr	r3, .L69+8
 812 002a 1888     		ldrh	r0, [r3]
 813 002c FFF7FEFF 		bl	EE_ReadVariable
 814              	.LVL48:
 305:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 815              		.loc 1 305 5 view .LVU193
 305:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 816              		.loc 1 305 20 is_stmt 0 view .LVU194
 817 0030 BDF81E20 		ldrh	r2, [sp, #30]
 305:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 818              		.loc 1 305 8 view .LVU195
 819 0034 41F20203 		movw	r3, #4098
 820 0038 9A42     		cmp	r2, r3
 821 003a 01D0     		beq	.L66
 822              	.LBB5:
 331:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 823              		.loc 1 331 20 view .LVU196
 824 003c 0025     		movs	r5, #0
 825 003e CBE0     		b	.L55
 826              	.L66:
 827              	.LBE5:
 310:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[2] , &readVal); rtP_Left.n_max = rtP_Right.n_max = (int16_t)rea
 828              		.loc 1 310 7 is_stmt 1 view .LVU197
 829 0040 794E     		ldr	r6, .L69+8
 830 0042 07A9     		add	r1, sp, #28
 831 0044 7088     		ldrh	r0, [r6, #2]
 832 0046 FFF7FEFF 		bl	EE_ReadVariable
 833              	.LVL49:
 310:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[2] , &readVal); rtP_Left.n_max = rtP_Right.n_max = (int16_t)rea
 834              		.loc 1 310 53 view .LVU198
 310:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[2] , &readVal); rtP_Left.n_max = rtP_Right.n_max = (int16_t)rea
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 30


 835              		.loc 1 310 88 is_stmt 0 view .LVU199
 836 004a BDF91C30 		ldrsh	r3, [sp, #28]
 310:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[2] , &readVal); rtP_Left.n_max = rtP_Right.n_max = (int16_t)rea
 837              		.loc 1 310 86 view .LVU200
 838 004e 774D     		ldr	r5, .L69+12
 839 0050 A5F8CE30 		strh	r3, [r5, #206]	@ movhi
 310:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[2] , &readVal); rtP_Left.n_max = rtP_Right.n_max = (int16_t)rea
 840              		.loc 1 310 68 view .LVU201
 841 0054 764C     		ldr	r4, .L69+16
 842 0056 A4F8CE30 		strh	r3, [r4, #206]	@ movhi
 311:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 843              		.loc 1 311 7 is_stmt 1 view .LVU202
 844 005a 07A9     		add	r1, sp, #28
 845 005c B088     		ldrh	r0, [r6, #4]
 846 005e FFF7FEFF 		bl	EE_ReadVariable
 847              	.LVL50:
 311:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 848              		.loc 1 311 53 view .LVU203
 311:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 849              		.loc 1 311 88 is_stmt 0 view .LVU204
 850 0062 BDF91C30 		ldrsh	r3, [sp, #28]
 311:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 851              		.loc 1 311 86 view .LVU205
 852 0066 A5F8DA30 		strh	r3, [r5, #218]	@ movhi
 311:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 853              		.loc 1 311 68 view .LVU206
 854 006a A4F8DA30 		strh	r3, [r4, #218]	@ movhi
 312:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 855              		.loc 1 312 7 is_stmt 1 view .LVU207
 856              	.LBB6:
 312:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 857              		.loc 1 312 12 view .LVU208
 858              	.LVL51:
 312:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 859              		.loc 1 312 20 is_stmt 0 view .LVU209
 860 006e 0026     		movs	r6, #0
 861              	.LVL52:
 862              	.L56:
 312:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 863              		.loc 1 312 25 is_stmt 1 discriminator 1 view .LVU210
 312:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 864              		.loc 1 312 7 is_stmt 0 discriminator 1 view .LVU211
 865 0070 002E     		cmp	r6, #0
 866 0072 40F0B380 		bne	.L58
 313:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 867              		.loc 1 313 9 is_stmt 1 discriminator 3 view .LVU212
 313:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 868              		.loc 1 313 43 is_stmt 0 discriminator 3 view .LVU213
 869 0076 F400     		lsls	r4, r6, #3
 313:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 870              		.loc 1 313 41 discriminator 3 view .LVU214
 871 0078 E31C     		adds	r3, r4, #3
 313:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 872              		.loc 1 313 9 discriminator 3 view .LVU215
 873 007a DFF8AC81 		ldr	r8, .L69+8
 874 007e 07A9     		add	r1, sp, #28
 875 0080 38F81300 		ldrh	r0, [r8, r3, lsl #1]
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 31


 876 0084 FFF7FEFF 		bl	EE_ReadVariable
 877              	.LVL53:
 313:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 878              		.loc 1 313 60 is_stmt 1 discriminator 3 view .LVU216
 313:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 879              		.loc 1 313 76 is_stmt 0 discriminator 3 view .LVU217
 880 0088 9DF81C30 		ldrb	r3, [sp, #28]	@ zero_extendqisi2
 313:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 881              		.loc 1 313 74 discriminator 3 view .LVU218
 882 008c A21B     		subs	r2, r4, r6
 883 008e 694D     		ldr	r5, .L69+20
 884 0090 05EB4205 		add	r5, r5, r2, lsl #1
 885 0094 2B71     		strb	r3, [r5, #4]
 314:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 886              		.loc 1 314 9 is_stmt 1 discriminator 3 view .LVU219
 314:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 887              		.loc 1 314 41 is_stmt 0 discriminator 3 view .LVU220
 888 0096 231D     		adds	r3, r4, #4
 314:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 889              		.loc 1 314 9 discriminator 3 view .LVU221
 890 0098 07A9     		add	r1, sp, #28
 891 009a 38F81300 		ldrh	r0, [r8, r3, lsl #1]
 892 009e FFF7FEFF 		bl	EE_ReadVariable
 893              	.LVL54:
 314:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 894              		.loc 1 314 60 is_stmt 1 discriminator 3 view .LVU222
 314:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 895              		.loc 1 314 76 is_stmt 0 discriminator 3 view .LVU223
 896 00a2 BDF91C30 		ldrsh	r3, [sp, #28]
 314:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 897              		.loc 1 314 74 discriminator 3 view .LVU224
 898 00a6 EB80     		strh	r3, [r5, #6]	@ movhi
 315:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 899              		.loc 1 315 9 is_stmt 1 discriminator 3 view .LVU225
 315:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 900              		.loc 1 315 41 is_stmt 0 discriminator 3 view .LVU226
 901 00a8 631D     		adds	r3, r4, #5
 315:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 902              		.loc 1 315 9 discriminator 3 view .LVU227
 903 00aa 07A9     		add	r1, sp, #28
 904 00ac 38F81300 		ldrh	r0, [r8, r3, lsl #1]
 905 00b0 FFF7FEFF 		bl	EE_ReadVariable
 906              	.LVL55:
 315:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 907              		.loc 1 315 60 is_stmt 1 discriminator 3 view .LVU228
 315:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 908              		.loc 1 315 76 is_stmt 0 discriminator 3 view .LVU229
 909 00b4 BDF91C30 		ldrsh	r3, [sp, #28]
 315:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 910              		.loc 1 315 74 discriminator 3 view .LVU230
 911 00b8 2B81     		strh	r3, [r5, #8]	@ movhi
 316:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 912              		.loc 1 316 9 is_stmt 1 discriminator 3 view .LVU231
 316:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 913              		.loc 1 316 41 is_stmt 0 discriminator 3 view .LVU232
 914 00ba A31D     		adds	r3, r4, #6
 316:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 32


 915              		.loc 1 316 9 discriminator 3 view .LVU233
 916 00bc 07A9     		add	r1, sp, #28
 917 00be 38F81300 		ldrh	r0, [r8, r3, lsl #1]
 918 00c2 FFF7FEFF 		bl	EE_ReadVariable
 919              	.LVL56:
 316:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 920              		.loc 1 316 60 is_stmt 1 discriminator 3 view .LVU234
 316:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 921              		.loc 1 316 76 is_stmt 0 discriminator 3 view .LVU235
 922 00c6 BDF91C30 		ldrsh	r3, [sp, #28]
 316:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 923              		.loc 1 316 74 discriminator 3 view .LVU236
 924 00ca 6B81     		strh	r3, [r5, #10]	@ movhi
 317:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 925              		.loc 1 317 9 is_stmt 1 discriminator 3 view .LVU237
 317:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 926              		.loc 1 317 41 is_stmt 0 discriminator 3 view .LVU238
 927 00cc E31D     		adds	r3, r4, #7
 317:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 928              		.loc 1 317 9 discriminator 3 view .LVU239
 929 00ce 07A9     		add	r1, sp, #28
 930 00d0 38F81300 		ldrh	r0, [r8, r3, lsl #1]
 931 00d4 FFF7FEFF 		bl	EE_ReadVariable
 932              	.LVL57:
 317:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 933              		.loc 1 317 60 is_stmt 1 discriminator 3 view .LVU240
 317:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 934              		.loc 1 317 76 is_stmt 0 discriminator 3 view .LVU241
 935 00d8 9DF81C30 		ldrb	r3, [sp, #28]	@ zero_extendqisi2
 317:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 936              		.loc 1 317 74 discriminator 3 view .LVU242
 937 00dc DFF85891 		ldr	r9, .L69+24
 938 00e0 A71B     		subs	r7, r4, r6
 939 00e2 09EB4707 		add	r7, r9, r7, lsl #1
 940 00e6 3B71     		strb	r3, [r7, #4]
 318:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 941              		.loc 1 318 9 is_stmt 1 discriminator 3 view .LVU243
 318:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 942              		.loc 1 318 41 is_stmt 0 discriminator 3 view .LVU244
 943 00e8 06F1010A 		add	r10, r6, #1
 944 00ec 4FEACA03 		lsl	r3, r10, #3
 318:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 945              		.loc 1 318 9 discriminator 3 view .LVU245
 946 00f0 07A9     		add	r1, sp, #28
 947 00f2 38F81300 		ldrh	r0, [r8, r3, lsl #1]
 948 00f6 FFF7FEFF 		bl	EE_ReadVariable
 949              	.LVL58:
 318:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 950              		.loc 1 318 60 is_stmt 1 discriminator 3 view .LVU246
 318:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 951              		.loc 1 318 76 is_stmt 0 discriminator 3 view .LVU247
 952 00fa BDF91C30 		ldrsh	r3, [sp, #28]
 318:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 953              		.loc 1 318 74 discriminator 3 view .LVU248
 954 00fe FB80     		strh	r3, [r7, #6]	@ movhi
 319:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 955              		.loc 1 319 9 is_stmt 1 discriminator 3 view .LVU249
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 33


 319:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 956              		.loc 1 319 41 is_stmt 0 discriminator 3 view .LVU250
 957 0100 04F10903 		add	r3, r4, #9
 319:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 958              		.loc 1 319 9 discriminator 3 view .LVU251
 959 0104 07A9     		add	r1, sp, #28
 960 0106 38F81300 		ldrh	r0, [r8, r3, lsl #1]
 961 010a FFF7FEFF 		bl	EE_ReadVariable
 962              	.LVL59:
 319:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 963              		.loc 1 319 60 is_stmt 1 discriminator 3 view .LVU252
 319:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 964              		.loc 1 319 76 is_stmt 0 discriminator 3 view .LVU253
 965 010e BDF91C30 		ldrsh	r3, [sp, #28]
 319:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 966              		.loc 1 319 74 discriminator 3 view .LVU254
 967 0112 3B81     		strh	r3, [r7, #8]	@ movhi
 320:Src/util.c    ****       
 968              		.loc 1 320 9 is_stmt 1 discriminator 3 view .LVU255
 320:Src/util.c    ****       
 969              		.loc 1 320 41 is_stmt 0 discriminator 3 view .LVU256
 970 0114 04F10A03 		add	r3, r4, #10
 320:Src/util.c    ****       
 971              		.loc 1 320 9 discriminator 3 view .LVU257
 972 0118 07A9     		add	r1, sp, #28
 973 011a 38F81300 		ldrh	r0, [r8, r3, lsl #1]
 974 011e FFF7FEFF 		bl	EE_ReadVariable
 975              	.LVL60:
 320:Src/util.c    ****       
 976              		.loc 1 320 60 is_stmt 1 discriminator 3 view .LVU258
 320:Src/util.c    ****       
 977              		.loc 1 320 76 is_stmt 0 discriminator 3 view .LVU259
 978 0122 BDF91C30 		ldrsh	r3, [sp, #28]
 320:Src/util.c    ****       
 979              		.loc 1 320 74 discriminator 3 view .LVU260
 980 0126 7B81     		strh	r3, [r7, #10]	@ movhi
 322:Src/util.c    ****           input1[i].typ, input1[i].min, input1[i].mid, input1[i].max,
 981              		.loc 1 322 9 is_stmt 1 discriminator 3 view .LVU261
 323:Src/util.c    ****           input2[i].typ, input2[i].min, input2[i].mid, input2[i].max);
 982              		.loc 1 323 65 is_stmt 0 discriminator 3 view .LVU262
 983 0128 B5F90A20 		ldrsh	r2, [r5, #10]
 324:Src/util.c    ****       }
 984              		.loc 1 324 20 discriminator 3 view .LVU263
 985 012c 3979     		ldrb	r1, [r7, #4]	@ zero_extendqisi2
 324:Src/util.c    ****       }
 986              		.loc 1 324 35 discriminator 3 view .LVU264
 987 012e B7F90600 		ldrsh	r0, [r7, #6]
 324:Src/util.c    ****       }
 988              		.loc 1 324 50 discriminator 3 view .LVU265
 989 0132 B7F90840 		ldrsh	r4, [r7, #8]
 322:Src/util.c    ****           input1[i].typ, input1[i].min, input1[i].mid, input1[i].max,
 990              		.loc 1 322 9 discriminator 3 view .LVU266
 991 0136 0493     		str	r3, [sp, #16]
 992 0138 0394     		str	r4, [sp, #12]
 993 013a 0290     		str	r0, [sp, #8]
 994 013c 0191     		str	r1, [sp, #4]
 995 013e 0092     		str	r2, [sp]
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 34


 996 0140 B5F90830 		ldrsh	r3, [r5, #8]
 997 0144 B5F90620 		ldrsh	r2, [r5, #6]
 998 0148 2979     		ldrb	r1, [r5, #4]	@ zero_extendqisi2
 999 014a 3C48     		ldr	r0, .L69+28
 1000 014c FFF7FEFF 		bl	printf
 1001              	.LVL61:
 312:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 1002              		.loc 1 312 38 is_stmt 1 discriminator 3 view .LVU267
 312:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 1003              		.loc 1 312 39 is_stmt 0 discriminator 3 view .LVU268
 1004 0150 5FFA8AF6 		uxtb	r6, r10
 1005              	.LVL62:
 312:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 1006              		.loc 1 312 39 discriminator 3 view .LVU269
 1007 0154 8CE7     		b	.L56
 1008              	.LVL63:
 1009              	.L63:
 312:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 1010              		.loc 1 312 39 discriminator 3 view .LVU270
 1011              	.LBE6:
 1012              	.LBB7:
 332:Src/util.c    ****           input1[i].typ = checkInputType(input1[i].min, input1[i].mid, input1[i].max);
 1013              		.loc 1 332 9 is_stmt 1 view .LVU271
 332:Src/util.c    ****           input1[i].typ = checkInputType(input1[i].min, input1[i].mid, input1[i].max);
 1014              		.loc 1 332 22 is_stmt 0 view .LVU272
 1015 0156 2C46     		mov	r4, r5
 1016 0158 C5EBC503 		rsb	r3, r5, r5, lsl #3
 1017 015c 354A     		ldr	r2, .L69+20
 1018 015e 02EB4303 		add	r3, r2, r3, lsl #1
 1019 0162 5B79     		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 332:Src/util.c    ****           input1[i].typ = checkInputType(input1[i].min, input1[i].mid, input1[i].max);
 1020              		.loc 1 332 12 view .LVU273
 1021 0164 032B     		cmp	r3, #3
 1022 0166 3ED0     		beq	.L67
 335:Src/util.c    ****         }
 1023              		.loc 1 335 11 is_stmt 1 view .LVU274
 335:Src/util.c    ****         }
 1024              		.loc 1 335 25 is_stmt 0 view .LVU275
 1025 0168 C5EBC502 		rsb	r2, r5, r5, lsl #3
 1026 016c 3149     		ldr	r1, .L69+20
 1027 016e 01EB4202 		add	r2, r1, r2, lsl #1
 1028 0172 1371     		strb	r3, [r2, #4]
 1029              	.L60:
 337:Src/util.c    ****           input2[i].typ = checkInputType(input2[i].min, input2[i].mid, input2[i].max);
 1030              		.loc 1 337 9 is_stmt 1 view .LVU276
 337:Src/util.c    ****           input2[i].typ = checkInputType(input2[i].min, input2[i].mid, input2[i].max);
 1031              		.loc 1 337 22 is_stmt 0 view .LVU277
 1032 0174 C4EBC403 		rsb	r3, r4, r4, lsl #3
 1033 0178 2F4A     		ldr	r2, .L69+24
 1034 017a 02EB4303 		add	r3, r2, r3, lsl #1
 1035 017e 5B79     		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 337:Src/util.c    ****           input2[i].typ = checkInputType(input2[i].min, input2[i].mid, input2[i].max);
 1036              		.loc 1 337 12 view .LVU278
 1037 0180 032B     		cmp	r3, #3
 1038 0182 3ED0     		beq	.L68
 340:Src/util.c    ****         }
 1039              		.loc 1 340 11 is_stmt 1 view .LVU279
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 35


 340:Src/util.c    ****         }
 1040              		.loc 1 340 25 is_stmt 0 view .LVU280
 1041 0184 C4EBC402 		rsb	r2, r4, r4, lsl #3
 1042 0188 2B49     		ldr	r1, .L69+24
 1043 018a 01EB4202 		add	r2, r1, r2, lsl #1
 1044 018e 1371     		strb	r3, [r2, #4]
 1045              	.L62:
 342:Src/util.c    ****           input1[i].typ, input1[i].min, input1[i].mid, input1[i].max,
 1046              		.loc 1 342 9 is_stmt 1 discriminator 2 view .LVU281
 343:Src/util.c    ****           input2[i].typ, input2[i].min, input2[i].mid, input2[i].max);
 1047              		.loc 1 343 20 is_stmt 0 discriminator 2 view .LVU282
 1048 0190 C4EBC403 		rsb	r3, r4, r4, lsl #3
 1049 0194 2749     		ldr	r1, .L69+20
 1050 0196 01EB4301 		add	r1, r1, r3, lsl #1
 343:Src/util.c    ****           input2[i].typ, input2[i].min, input2[i].mid, input2[i].max);
 1051              		.loc 1 343 65 discriminator 2 view .LVU283
 1052 019a B1F90A00 		ldrsh	r0, [r1, #10]
 344:Src/util.c    ****       }
 1053              		.loc 1 344 20 discriminator 2 view .LVU284
 1054 019e 264A     		ldr	r2, .L69+24
 1055 01a0 02EB4303 		add	r3, r2, r3, lsl #1
 1056 01a4 1E79     		ldrb	r6, [r3, #4]	@ zero_extendqisi2
 344:Src/util.c    ****       }
 1057              		.loc 1 344 35 discriminator 2 view .LVU285
 1058 01a6 B3F90670 		ldrsh	r7, [r3, #6]
 344:Src/util.c    ****       }
 1059              		.loc 1 344 50 discriminator 2 view .LVU286
 1060 01aa B3F90830 		ldrsh	r3, [r3, #8]
 344:Src/util.c    ****       }
 1061              		.loc 1 344 65 discriminator 2 view .LVU287
 1062 01ae C4EBC404 		rsb	r4, r4, r4, lsl #3
 1063 01b2 02EB4404 		add	r4, r2, r4, lsl #1
 1064 01b6 B4F90A20 		ldrsh	r2, [r4, #10]
 342:Src/util.c    ****           input1[i].typ, input1[i].min, input1[i].mid, input1[i].max,
 1065              		.loc 1 342 9 discriminator 2 view .LVU288
 1066 01ba 0492     		str	r2, [sp, #16]
 1067 01bc 0393     		str	r3, [sp, #12]
 1068 01be 0297     		str	r7, [sp, #8]
 1069 01c0 0196     		str	r6, [sp, #4]
 1070 01c2 0090     		str	r0, [sp]
 1071 01c4 B1F90830 		ldrsh	r3, [r1, #8]
 1072 01c8 B1F90620 		ldrsh	r2, [r1, #6]
 1073 01cc 0979     		ldrb	r1, [r1, #4]	@ zero_extendqisi2
 1074 01ce 1B48     		ldr	r0, .L69+28
 1075 01d0 FFF7FEFF 		bl	printf
 1076              	.LVL64:
 331:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 1077              		.loc 1 331 38 is_stmt 1 discriminator 2 view .LVU289
 331:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 1078              		.loc 1 331 39 is_stmt 0 discriminator 2 view .LVU290
 1079 01d4 0135     		adds	r5, r5, #1
 1080              	.LVL65:
 331:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 1081              		.loc 1 331 39 discriminator 2 view .LVU291
 1082 01d6 EDB2     		uxtb	r5, r5
 1083              	.LVL66:
 1084              	.L55:
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 36


 331:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 1085              		.loc 1 331 25 is_stmt 1 discriminator 1 view .LVU292
 331:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 1086              		.loc 1 331 7 is_stmt 0 discriminator 1 view .LVU293
 1087 01d8 002D     		cmp	r5, #0
 1088 01da BCD0     		beq	.L63
 1089              	.LVL67:
 1090              	.L58:
 331:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 1091              		.loc 1 331 7 discriminator 1 view .LVU294
 1092              	.LBE7:
 347:Src/util.c    ****   #endif
 1093              		.loc 1 347 5 is_stmt 1 view .LVU295
 1094 01dc FFF7FEFF 		bl	HAL_FLASH_Lock
 1095              	.LVL68:
 399:Src/util.c    **** 
 1096              		.loc 1 399 1 is_stmt 0 view .LVU296
 1097 01e0 08B0     		add	sp, sp, #32
 1098              	.LCFI8:
 1099              		.cfi_remember_state
 1100              		.cfi_def_cfa_offset 32
 1101              		@ sp needed
 1102 01e2 BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 1103              	.LVL69:
 1104              	.L67:
 1105              	.LCFI9:
 1106              		.cfi_restore_state
 1107              	.LBB8:
 333:Src/util.c    ****         } else {
 1108              		.loc 1 333 11 is_stmt 1 view .LVU297
 333:Src/util.c    ****         } else {
 1109              		.loc 1 333 27 is_stmt 0 view .LVU298
 1110 01e6 C5EBC506 		rsb	r6, r5, r5, lsl #3
 1111 01ea 02EB4606 		add	r6, r2, r6, lsl #1
 1112 01ee B6F90A20 		ldrsh	r2, [r6, #10]
 1113 01f2 B6F90810 		ldrsh	r1, [r6, #8]
 1114 01f6 B6F90600 		ldrsh	r0, [r6, #6]
 1115 01fa FFF7FEFF 		bl	checkInputType
 1116              	.LVL70:
 333:Src/util.c    ****         } else {
 1117              		.loc 1 333 25 view .LVU299
 1118 01fe 3071     		strb	r0, [r6, #4]
 1119 0200 B8E7     		b	.L60
 1120              	.L68:
 338:Src/util.c    ****         } else {
 1121              		.loc 1 338 11 is_stmt 1 view .LVU300
 338:Src/util.c    ****         } else {
 1122              		.loc 1 338 27 is_stmt 0 view .LVU301
 1123 0202 C4EBC406 		rsb	r6, r4, r4, lsl #3
 1124 0206 02EB4606 		add	r6, r2, r6, lsl #1
 1125 020a B6F90A20 		ldrsh	r2, [r6, #10]
 1126 020e B6F90810 		ldrsh	r1, [r6, #8]
 1127 0212 B6F90600 		ldrsh	r0, [r6, #6]
 1128 0216 FFF7FEFF 		bl	checkInputType
 1129              	.LVL71:
 338:Src/util.c    ****         } else {
 1130              		.loc 1 338 25 view .LVU302
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 37


 1131 021a 3071     		strb	r0, [r6, #4]
 1132 021c B8E7     		b	.L62
 1133              	.L70:
 1134 021e 00BF     		.align	2
 1135              	.L69:
 1136 0220 00000000 		.word	huart2
 1137 0224 00000000 		.word	.LANCHOR13
 1138 0228 00000000 		.word	.LANCHOR14
 1139 022c 00000000 		.word	.LANCHOR0
 1140 0230 00000000 		.word	rtP_Left
 1141 0234 00000000 		.word	.LANCHOR15
 1142 0238 00000000 		.word	.LANCHOR16
 1143 023c 00000000 		.word	.LC0
 1144              	.LBE8:
 1145              		.cfi_endproc
 1146              	.LFE68:
 1148              		.section	.text.calcInputCmd,"ax",%progbits
 1149              		.align	1
 1150              		.global	calcInputCmd
 1151              		.syntax unified
 1152              		.thumb
 1153              		.thumb_func
 1155              	calcInputCmd:
 1156              	.LVL72:
 1157              	.LFB82:
 798:Src/util.c    **** 
 799:Src/util.c    **** 
 800:Src/util.c    **** 
 801:Src/util.c    **** /* =========================== Input Functions =========================== */
 802:Src/util.c    **** 
 803:Src/util.c    ****  /*
 804:Src/util.c    ****  * Calculate Input Command
 805:Src/util.c    ****  * This function realizes dead-band around 0 and scales the input between [out_min, out_max]
 806:Src/util.c    ****  */
 807:Src/util.c    **** void calcInputCmd(InputStruct *in, int16_t out_min, int16_t out_max) {
 1158              		.loc 1 807 70 is_stmt 1 view -0
 1159              		.cfi_startproc
 1160              		@ args = 0, pretend = 0, frame = 0
 1161              		@ frame_needed = 0, uses_anonymous_args = 0
 808:Src/util.c    ****   switch (in->typ){
 1162              		.loc 1 808 3 view .LVU304
 1163              		.loc 1 808 13 is_stmt 0 view .LVU305
 1164 0000 90F804C0 		ldrb	ip, [r0, #4]	@ zero_extendqisi2
 1165              		.loc 1 808 3 view .LVU306
 1166 0004 BCF1010F 		cmp	ip, #1
 1167 0008 05D0     		beq	.L72
 1168 000a BCF1020F 		cmp	ip, #2
 1169 000e 17D0     		beq	.L73
 809:Src/util.c    ****     case 1: // Input is a normal pot
 810:Src/util.c    ****       in->cmd = CLAMP(MAP(in->raw, in->min, in->max, 0, out_max), 0, out_max);
 811:Src/util.c    ****       break;
 812:Src/util.c    ****     case 2: // Input is a mid resting pot
 813:Src/util.c    ****       if( in->raw > in->mid - in->dband && in->raw < in->mid + in->dband ) {
 814:Src/util.c    ****         in->cmd = 0;
 815:Src/util.c    ****       } else if(in->raw > in->mid) {
 816:Src/util.c    ****         in->cmd = CLAMP(MAP(in->raw, in->mid + in->dband, in->max, 0, out_max), 0, out_max);
 817:Src/util.c    ****       } else {
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 38


 818:Src/util.c    ****         in->cmd = CLAMP(MAP(in->raw, in->mid - in->dband, in->min, 0, out_min), out_min, 0);
 819:Src/util.c    ****       }
 820:Src/util.c    ****       break;
 821:Src/util.c    ****     default: // Input is ignored
 822:Src/util.c    ****       in->cmd = 0;
 1170              		.loc 1 822 7 is_stmt 1 view .LVU307
 1171              		.loc 1 822 15 is_stmt 0 view .LVU308
 1172 0010 0023     		movs	r3, #0
 1173 0012 4380     		strh	r3, [r0, #2]	@ movhi
 823:Src/util.c    ****       break;
 1174              		.loc 1 823 7 is_stmt 1 view .LVU309
 1175 0014 7047     		bx	lr
 1176              	.L72:
 810:Src/util.c    ****       break;
 1177              		.loc 1 810 7 view .LVU310
 810:Src/util.c    ****       break;
 1178              		.loc 1 810 17 is_stmt 0 view .LVU311
 1179 0016 B0F90030 		ldrsh	r3, [r0]
 1180 001a B0F906C0 		ldrsh	ip, [r0, #6]
 1181 001e A3EB0C03 		sub	r3, r3, ip
 1182 0022 02FB03F3 		mul	r3, r2, r3
 1183 0026 B0F90A10 		ldrsh	r1, [r0, #10]
 1184              	.LVL73:
 810:Src/util.c    ****       break;
 1185              		.loc 1 810 17 view .LVU312
 1186 002a A1EB0C01 		sub	r1, r1, ip
 1187 002e 93FBF1F3 		sdiv	r3, r3, r1
 810:Src/util.c    ****       break;
 1188              		.loc 1 810 15 view .LVU313
 1189 0032 9A42     		cmp	r2, r3
 1190 0034 02DB     		blt	.L75
 810:Src/util.c    ****       break;
 1191              		.loc 1 810 17 discriminator 1 view .LVU314
 1192 0036 23EAE372 		bic	r2, r3, r3, asr #31
 1193              	.LVL74:
 810:Src/util.c    ****       break;
 1194              		.loc 1 810 15 discriminator 1 view .LVU315
 1195 003a 12B2     		sxth	r2, r2
 1196              	.L75:
 810:Src/util.c    ****       break;
 1197              		.loc 1 810 15 discriminator 4 view .LVU316
 1198 003c 4280     		strh	r2, [r0, #2]	@ movhi
 811:Src/util.c    ****     case 2: // Input is a mid resting pot
 1199              		.loc 1 811 7 is_stmt 1 discriminator 4 view .LVU317
 1200 003e 7047     		bx	lr
 1201              	.LVL75:
 1202              	.L73:
 807:Src/util.c    ****   switch (in->typ){
 1203              		.loc 1 807 70 is_stmt 0 view .LVU318
 1204 0040 30B5     		push	{r4, r5, lr}
 1205              	.LCFI10:
 1206              		.cfi_def_cfa_offset 12
 1207              		.cfi_offset 4, -12
 1208              		.cfi_offset 5, -8
 1209              		.cfi_offset 14, -4
 813:Src/util.c    ****         in->cmd = 0;
 1210              		.loc 1 813 7 is_stmt 1 view .LVU319
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 39


 813:Src/util.c    ****         in->cmd = 0;
 1211              		.loc 1 813 13 is_stmt 0 view .LVU320
 1212 0042 B0F90030 		ldrsh	r3, [r0]
 813:Src/util.c    ****         in->cmd = 0;
 1213              		.loc 1 813 23 view .LVU321
 1214 0046 B0F908C0 		ldrsh	ip, [r0, #8]
 813:Src/util.c    ****         in->cmd = 0;
 1215              		.loc 1 813 33 view .LVU322
 1216 004a B0F90CE0 		ldrsh	lr, [r0, #12]
 813:Src/util.c    ****         in->cmd = 0;
 1217              		.loc 1 813 29 view .LVU323
 1218 004e ACEB0E04 		sub	r4, ip, lr
 813:Src/util.c    ****         in->cmd = 0;
 1219              		.loc 1 813 9 view .LVU324
 1220 0052 A342     		cmp	r3, r4
 1221 0054 06DD     		ble	.L77
 813:Src/util.c    ****         in->cmd = 0;
 1222              		.loc 1 813 62 discriminator 1 view .LVU325
 1223 0056 0CEB0E05 		add	r5, ip, lr
 813:Src/util.c    ****         in->cmd = 0;
 1224              		.loc 1 813 41 discriminator 1 view .LVU326
 1225 005a AB42     		cmp	r3, r5
 1226 005c 02DA     		bge	.L77
 814:Src/util.c    ****       } else if(in->raw > in->mid) {
 1227              		.loc 1 814 9 is_stmt 1 view .LVU327
 814:Src/util.c    ****       } else if(in->raw > in->mid) {
 1228              		.loc 1 814 17 is_stmt 0 view .LVU328
 1229 005e 0023     		movs	r3, #0
 1230 0060 4380     		strh	r3, [r0, #2]	@ movhi
 1231 0062 12E0     		b	.L71
 1232              	.L77:
 815:Src/util.c    ****         in->cmd = CLAMP(MAP(in->raw, in->mid + in->dband, in->max, 0, out_max), 0, out_max);
 1233              		.loc 1 815 14 is_stmt 1 view .LVU329
 815:Src/util.c    ****         in->cmd = CLAMP(MAP(in->raw, in->mid + in->dband, in->max, 0, out_max), 0, out_max);
 1234              		.loc 1 815 16 is_stmt 0 view .LVU330
 1235 0064 6345     		cmp	r3, ip
 1236 0066 11DD     		ble	.L78
 816:Src/util.c    ****       } else {
 1237              		.loc 1 816 9 is_stmt 1 view .LVU331
 816:Src/util.c    ****       } else {
 1238              		.loc 1 816 19 is_stmt 0 view .LVU332
 1239 0068 F444     		add	ip, ip, lr
 1240 006a A3EB0C03 		sub	r3, r3, ip
 1241 006e 02FB03F3 		mul	r3, r2, r3
 1242 0072 B0F90A10 		ldrsh	r1, [r0, #10]
 1243              	.LVL76:
 816:Src/util.c    ****       } else {
 1244              		.loc 1 816 19 view .LVU333
 1245 0076 A1EB0C0C 		sub	ip, r1, ip
 1246 007a 93FBFCF3 		sdiv	r3, r3, ip
 816:Src/util.c    ****       } else {
 1247              		.loc 1 816 17 view .LVU334
 1248 007e 9A42     		cmp	r2, r3
 1249 0080 02DB     		blt	.L79
 816:Src/util.c    ****       } else {
 1250              		.loc 1 816 19 discriminator 1 view .LVU335
 1251 0082 23EAE372 		bic	r2, r3, r3, asr #31
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 40


 1252              	.LVL77:
 816:Src/util.c    ****       } else {
 1253              		.loc 1 816 17 discriminator 1 view .LVU336
 1254 0086 12B2     		sxth	r2, r2
 1255              	.L79:
 816:Src/util.c    ****       } else {
 1256              		.loc 1 816 17 discriminator 4 view .LVU337
 1257 0088 4280     		strh	r2, [r0, #2]	@ movhi
 1258              	.L71:
 824:Src/util.c    ****   }
 825:Src/util.c    **** }
 1259              		.loc 1 825 1 view .LVU338
 1260 008a 30BD     		pop	{r4, r5, pc}
 1261              	.LVL78:
 1262              	.L78:
 818:Src/util.c    ****       }
 1263              		.loc 1 818 9 is_stmt 1 view .LVU339
 818:Src/util.c    ****       }
 1264              		.loc 1 818 19 is_stmt 0 view .LVU340
 1265 008c 1B1B     		subs	r3, r3, r4
 1266 008e 01FB03F3 		mul	r3, r1, r3
 1267 0092 B0F90620 		ldrsh	r2, [r0, #6]
 1268              	.LVL79:
 818:Src/util.c    ****       }
 1269              		.loc 1 818 19 view .LVU341
 1270 0096 141B     		subs	r4, r2, r4
 1271 0098 93FBF4F3 		sdiv	r3, r3, r4
 818:Src/util.c    ****       }
 1272              		.loc 1 818 17 view .LVU342
 1273 009c 002B     		cmp	r3, #0
 1274 009e 02DD     		ble	.L86
 1275 00a0 0021     		movs	r1, #0
 1276              	.LVL80:
 1277              	.L80:
 818:Src/util.c    ****       }
 1278              		.loc 1 818 17 discriminator 4 view .LVU343
 1279 00a2 4180     		strh	r1, [r0, #2]	@ movhi
 1280 00a4 F1E7     		b	.L71
 1281              	.LVL81:
 1282              	.L86:
 818:Src/util.c    ****       }
 1283              		.loc 1 818 19 discriminator 1 view .LVU344
 1284 00a6 9942     		cmp	r1, r3
 1285 00a8 B8BF     		it	lt
 1286 00aa 1946     		movlt	r1, r3
 1287              	.LVL82:
 818:Src/util.c    ****       }
 1288              		.loc 1 818 17 discriminator 1 view .LVU345
 1289 00ac 09B2     		sxth	r1, r1
 1290 00ae F8E7     		b	.L80
 1291              		.cfi_endproc
 1292              	.LFE82:
 1294              		.section	.text.readInputRaw,"ax",%progbits
 1295              		.align	1
 1296              		.global	readInputRaw
 1297              		.syntax unified
 1298              		.thumb
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 41


 1299              		.thumb_func
 1301              	readInputRaw:
 1302              	.LFB83:
 826:Src/util.c    **** 
 827:Src/util.c    ****  /*
 828:Src/util.c    ****  * Function to read the Input Raw values from various input devices
 829:Src/util.c    ****  */
 830:Src/util.c    **** void readInputRaw(void) {
 1303              		.loc 1 830 25 is_stmt 1 view -0
 1304              		.cfi_startproc
 1305              		@ args = 0, pretend = 0, frame = 0
 1306              		@ frame_needed = 0, uses_anonymous_args = 0
 1307              		@ link register save eliminated.
 831:Src/util.c    ****     #ifdef CONTROL_ADC
 832:Src/util.c    ****     if (inIdx == CONTROL_ADC) {
 833:Src/util.c    ****       #ifdef ADC_ALTERNATE_CONNECT
 834:Src/util.c    ****         input1[inIdx].raw = adc_buffer.l_rx2;
 835:Src/util.c    ****         input2[inIdx].raw = adc_buffer.l_tx2;
 836:Src/util.c    ****       #else
 837:Src/util.c    ****         input1[inIdx].raw = adc_buffer.l_tx2;
 838:Src/util.c    ****         input2[inIdx].raw = adc_buffer.l_rx2;
 839:Src/util.c    ****       #endif
 840:Src/util.c    ****     }
 841:Src/util.c    ****     #endif
 842:Src/util.c    **** 
 843:Src/util.c    ****     #if defined(CONTROL_NUNCHUK) || defined(SUPPORT_NUNCHUK)
 844:Src/util.c    ****     if (Nunchuk_Read() == NUNCHUK_CONNECTED) {
 845:Src/util.c    ****       if (inIdx == CONTROL_NUNCHUK) {
 846:Src/util.c    ****         input1[inIdx].raw = (nunchuk_data[0] - 127) * 8; // X axis 0-255
 847:Src/util.c    ****         input2[inIdx].raw = (nunchuk_data[1] - 128) * 8; // Y axis 0-255
 848:Src/util.c    ****       }
 849:Src/util.c    ****       #ifdef SUPPORT_BUTTONS
 850:Src/util.c    ****         button1 = (uint8_t)nunchuk_data[5] & 1;
 851:Src/util.c    ****         button2 = (uint8_t)(nunchuk_data[5] >> 1) & 1;
 852:Src/util.c    ****       #endif
 853:Src/util.c    ****     }
 854:Src/util.c    ****     #endif
 855:Src/util.c    **** 
 856:Src/util.c    ****     #if defined(CONTROL_SERIAL_USART2)
 857:Src/util.c    ****     if (inIdx == CONTROL_SERIAL_USART2) {
 1308              		.loc 1 857 5 view .LVU347
 1309              		.loc 1 857 15 is_stmt 0 view .LVU348
 1310 0000 094B     		ldr	r3, .L89
 1311 0002 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1312              		.loc 1 857 8 view .LVU349
 1313 0004 7BB9     		cbnz	r3, .L87
 858:Src/util.c    ****       #ifdef CONTROL_IBUS
 859:Src/util.c    ****         for (uint8_t i = 0; i < (IBUS_NUM_CHANNELS * 2); i+=2) {
 860:Src/util.c    ****           ibusL_captured_value[(i/2)] = CLAMP(commandL.channels[i] + (commandL.channels[i+1] << 8) 
 861:Src/util.c    ****         }
 862:Src/util.c    ****         input1[inIdx].raw = (ibusL_captured_value[0] - 500) * 2;
 863:Src/util.c    ****         input2[inIdx].raw = (ibusL_captured_value[1] - 500) * 2; 
 864:Src/util.c    ****       #else
 865:Src/util.c    ****         input1[inIdx].raw = commandL.steer;
 1314              		.loc 1 865 9 is_stmt 1 view .LVU350
 1315              		.loc 1 865 37 is_stmt 0 view .LVU351
 1316 0006 094A     		ldr	r2, .L89+4
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 42


 1317 0008 B2F902C0 		ldrsh	ip, [r2, #2]
 1318              		.loc 1 865 27 view .LVU352
 1319 000c C3EBC300 		rsb	r0, r3, r3, lsl #3
 1320 0010 4100     		lsls	r1, r0, #1
 1321 0012 0748     		ldr	r0, .L89+8
 1322 0014 20F801C0 		strh	ip, [r0, r1]	@ movhi
 866:Src/util.c    ****         input2[inIdx].raw = commandL.speed;
 1323              		.loc 1 866 9 is_stmt 1 view .LVU353
 1324              		.loc 1 866 37 is_stmt 0 view .LVU354
 1325 0018 B2F90410 		ldrsh	r1, [r2, #4]
 1326              		.loc 1 866 27 view .LVU355
 1327 001c C3EBC303 		rsb	r3, r3, r3, lsl #3
 1328 0020 5A00     		lsls	r2, r3, #1
 1329 0022 044B     		ldr	r3, .L89+12
 1330 0024 9952     		strh	r1, [r3, r2]	@ movhi
 1331              	.L87:
 867:Src/util.c    ****       #endif
 868:Src/util.c    ****     }
 869:Src/util.c    ****     #endif
 870:Src/util.c    ****     #if defined(CONTROL_SERIAL_USART3)
 871:Src/util.c    ****     if (inIdx == CONTROL_SERIAL_USART3) {
 872:Src/util.c    ****       #ifdef CONTROL_IBUS
 873:Src/util.c    ****         for (uint8_t i = 0; i < (IBUS_NUM_CHANNELS * 2); i+=2) {
 874:Src/util.c    ****           ibusR_captured_value[(i/2)] = CLAMP(commandR.channels[i] + (commandR.channels[i+1] << 8) 
 875:Src/util.c    ****         }
 876:Src/util.c    ****         input1[inIdx].raw = (ibusR_captured_value[0] - 500) * 2;
 877:Src/util.c    ****         input2[inIdx].raw = (ibusR_captured_value[1] - 500) * 2; 
 878:Src/util.c    ****       #else
 879:Src/util.c    ****         input1[inIdx].raw = commandR.steer;
 880:Src/util.c    ****         input2[inIdx].raw = commandR.speed;
 881:Src/util.c    ****       #endif
 882:Src/util.c    ****     }
 883:Src/util.c    ****     #endif
 884:Src/util.c    **** 
 885:Src/util.c    ****     #if defined(SIDEBOARD_SERIAL_USART2)
 886:Src/util.c    ****     if (inIdx == SIDEBOARD_SERIAL_USART2) {
 887:Src/util.c    ****       input1[inIdx].raw = Sideboard_L.cmd1;
 888:Src/util.c    ****       input2[inIdx].raw = Sideboard_L.cmd2;
 889:Src/util.c    ****     }
 890:Src/util.c    ****     #endif
 891:Src/util.c    ****     #if defined(SIDEBOARD_SERIAL_USART3)
 892:Src/util.c    ****     if (inIdx == SIDEBOARD_SERIAL_USART3) {
 893:Src/util.c    ****       input1[inIdx].raw = Sideboard_R.cmd1;
 894:Src/util.c    ****       input2[inIdx].raw = Sideboard_R.cmd2;
 895:Src/util.c    ****     }
 896:Src/util.c    ****     #endif
 897:Src/util.c    **** 
 898:Src/util.c    ****     #if defined(CONTROL_PPM_LEFT)
 899:Src/util.c    ****     if (inIdx == CONTROL_PPM_LEFT) {
 900:Src/util.c    ****       input1[inIdx].raw = (ppm_captured_value[0] - 500) * 2;
 901:Src/util.c    ****       input2[inIdx].raw = (ppm_captured_value[1] - 500) * 2;
 902:Src/util.c    ****     }
 903:Src/util.c    ****     #endif
 904:Src/util.c    ****     #if defined(CONTROL_PPM_RIGHT)
 905:Src/util.c    ****     if (inIdx == CONTROL_PPM_RIGHT) {
 906:Src/util.c    ****       input1[inIdx].raw = (ppm_captured_value[0] - 500) * 2;
 907:Src/util.c    ****       input2[inIdx].raw = (ppm_captured_value[1] - 500) * 2;
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 43


 908:Src/util.c    ****     }
 909:Src/util.c    ****     #endif
 910:Src/util.c    ****     #if (defined(CONTROL_PPM_LEFT) || defined(CONTROL_PPM_RIGHT)) && defined(SUPPORT_BUTTONS)
 911:Src/util.c    ****       button1 = ppm_captured_value[5] > 500;
 912:Src/util.c    ****       button2 = 0;
 913:Src/util.c    ****     #endif
 914:Src/util.c    **** 
 915:Src/util.c    ****     #if defined(CONTROL_PWM_LEFT)
 916:Src/util.c    ****     if (inIdx == CONTROL_PWM_LEFT) {
 917:Src/util.c    ****       input1[inIdx].raw = (pwm_captured_ch1_value - 500) * 2;
 918:Src/util.c    ****       input2[inIdx].raw = (pwm_captured_ch2_value - 500) * 2;
 919:Src/util.c    ****     }
 920:Src/util.c    ****     #endif
 921:Src/util.c    ****     #if defined(CONTROL_PWM_RIGHT)
 922:Src/util.c    ****     if (inIdx == CONTROL_PWM_RIGHT) {
 923:Src/util.c    ****       input1[inIdx].raw = (pwm_captured_ch1_value - 500) * 2;
 924:Src/util.c    ****       input2[inIdx].raw = (pwm_captured_ch2_value - 500) * 2;
 925:Src/util.c    ****     }
 926:Src/util.c    ****     #endif
 927:Src/util.c    **** 
 928:Src/util.c    ****     #ifdef VARIANT_TRANSPOTTER
 929:Src/util.c    ****       #ifdef GAMETRAK_CONNECTION_NORMAL
 930:Src/util.c    ****         input1[inIdx].cmd = adc_buffer.l_rx2;
 931:Src/util.c    ****         input2[inIdx].cmd = adc_buffer.l_tx2;
 932:Src/util.c    ****       #endif
 933:Src/util.c    ****       #ifdef GAMETRAK_CONNECTION_ALTERNATE
 934:Src/util.c    ****         input1[inIdx].cmd = adc_buffer.l_tx2;
 935:Src/util.c    ****         input2[inIdx].cmd = adc_buffer.l_rx2;
 936:Src/util.c    ****       #endif
 937:Src/util.c    ****     #endif
 938:Src/util.c    **** }
 1332              		.loc 1 938 1 view .LVU356
 1333 0026 7047     		bx	lr
 1334              	.L90:
 1335              		.align	2
 1336              	.L89:
 1337 0028 00000000 		.word	.LANCHOR17
 1338 002c 00000000 		.word	.LANCHOR18
 1339 0030 00000000 		.word	.LANCHOR15
 1340 0034 00000000 		.word	.LANCHOR16
 1341              		.cfi_endproc
 1342              	.LFE83:
 1344              		.section	.text.handleTimeout,"ax",%progbits
 1345              		.align	1
 1346              		.global	handleTimeout
 1347              		.syntax unified
 1348              		.thumb
 1349              		.thumb_func
 1351              	handleTimeout:
 1352              	.LFB84:
 939:Src/util.c    **** 
 940:Src/util.c    ****  /*
 941:Src/util.c    ****  * Function to handle the ADC, UART and General timeout (Nunchuk, PPM, PWM)
 942:Src/util.c    ****  */
 943:Src/util.c    **** void handleTimeout(void) {
 1353              		.loc 1 943 26 is_stmt 1 view -0
 1354              		.cfi_startproc
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 44


 1355              		@ args = 0, pretend = 0, frame = 0
 1356              		@ frame_needed = 0, uses_anonymous_args = 0
 1357 0000 08B5     		push	{r3, lr}
 1358              	.LCFI11:
 1359              		.cfi_def_cfa_offset 8
 1360              		.cfi_offset 3, -8
 1361              		.cfi_offset 14, -4
 944:Src/util.c    ****     #ifdef CONTROL_ADC
 945:Src/util.c    ****     if (inIdx == CONTROL_ADC) {
 946:Src/util.c    ****       // If input1 or Input2 is either below MIN - Threshold or above MAX + Threshold, ADC protecti
 947:Src/util.c    ****       if (IN_RANGE(input1[inIdx].raw, input1[inIdx].min - ADC_PROTECT_THRESH, input1[inIdx].max + A
 948:Src/util.c    ****           IN_RANGE(input2[inIdx].raw, input2[inIdx].min - ADC_PROTECT_THRESH, input2[inIdx].max + A
 949:Src/util.c    ****           timeoutFlgADC = 0;                            // Reset the timeout flag
 950:Src/util.c    ****           timeoutCntADC = 0;                            // Reset the timeout counter
 951:Src/util.c    ****       } else {
 952:Src/util.c    ****         if (timeoutCntADC++ >= ADC_PROTECT_TIMEOUT) {   // Timeout qualification
 953:Src/util.c    ****           timeoutFlgADC = 1;                            // Timeout detected
 954:Src/util.c    ****           timeoutCntADC = ADC_PROTECT_TIMEOUT;          // Limit timout counter value
 955:Src/util.c    ****         }
 956:Src/util.c    ****       }
 957:Src/util.c    ****     }
 958:Src/util.c    ****     #endif
 959:Src/util.c    **** 
 960:Src/util.c    ****     #if defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USART2)
 961:Src/util.c    ****       if (timeoutCntSerial_L++ >= SERIAL_TIMEOUT) {     // Timeout qualification
 1362              		.loc 1 961 7 view .LVU358
 1363              		.loc 1 961 29 is_stmt 0 view .LVU359
 1364 0002 1E4A     		ldr	r2, .L101
 1365 0004 1388     		ldrh	r3, [r2]
 1366 0006 591C     		adds	r1, r3, #1
 1367 0008 1180     		strh	r1, [r2]	@ movhi
 1368              		.loc 1 961 10 view .LVU360
 1369 000a 9F2B     		cmp	r3, #159
 1370 000c 05D9     		bls	.L92
 962:Src/util.c    ****         timeoutFlgSerial_L = 1;                         // Timeout detected
 1371              		.loc 1 962 9 is_stmt 1 view .LVU361
 1372              		.loc 1 962 28 is_stmt 0 view .LVU362
 1373 000e 1C4B     		ldr	r3, .L101+4
 1374 0010 0122     		movs	r2, #1
 1375 0012 1A70     		strb	r2, [r3]
 963:Src/util.c    ****         timeoutCntSerial_L = SERIAL_TIMEOUT;            // Limit timout counter value
 1376              		.loc 1 963 9 is_stmt 1 view .LVU363
 1377              		.loc 1 963 28 is_stmt 0 view .LVU364
 1378 0014 194B     		ldr	r3, .L101
 1379 0016 A022     		movs	r2, #160
 1380 0018 1A80     		strh	r2, [r3]	@ movhi
 1381              	.L92:
 964:Src/util.c    ****         #if defined(DUAL_INPUTS) && ((defined(CONTROL_SERIAL_USART2) && CONTROL_SERIAL_USART2 == 1)
 965:Src/util.c    ****           inIdx = 0;                                    // Switch to Primary input in case of Timeo
 966:Src/util.c    ****         #endif
 967:Src/util.c    ****       } else {                                          // No Timeout
 968:Src/util.c    ****         #if defined(DUAL_INPUTS) && defined(SIDEBOARD_SERIAL_USART2)
 969:Src/util.c    ****           if (Sideboard_L.sensors & SWA_SET) {          // If SWA is set, switch to Sideboard contr
 970:Src/util.c    ****             inIdx = SIDEBOARD_SERIAL_USART2;
 971:Src/util.c    ****           } else {
 972:Src/util.c    ****             inIdx = !SIDEBOARD_SERIAL_USART2;
 973:Src/util.c    ****           }
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 45


 974:Src/util.c    ****         #elif defined(DUAL_INPUTS) && (defined(CONTROL_SERIAL_USART2) && CONTROL_SERIAL_USART2 == 1
 975:Src/util.c    ****           inIdx = 1;                                    // Switch to Auxiliary input in case of NO 
 976:Src/util.c    ****         #endif
 977:Src/util.c    ****       }
 1382              		.loc 1 977 7 is_stmt 1 view .LVU365
 978:Src/util.c    ****       #if (defined(CONTROL_SERIAL_USART2) && CONTROL_SERIAL_USART2 == 0) || (defined(SIDEBOARD_SERI
 979:Src/util.c    ****         timeoutFlgSerial = timeoutFlgSerial_L;          // Report Timeout only on the Primary Input
 1383              		.loc 1 979 9 view .LVU366
 1384              		.loc 1 979 26 is_stmt 0 view .LVU367
 1385 001a 194B     		ldr	r3, .L101+4
 1386 001c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1387 001e 194A     		ldr	r2, .L101+8
 1388 0020 1370     		strb	r3, [r2]
 980:Src/util.c    ****       #endif
 981:Src/util.c    ****     #endif
 982:Src/util.c    **** 
 983:Src/util.c    ****     #if defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_USART3)
 984:Src/util.c    ****       if (timeoutCntSerial_R++ >= SERIAL_TIMEOUT) {     // Timeout qualification
 985:Src/util.c    ****         timeoutFlgSerial_R = 1;                         // Timeout detected
 986:Src/util.c    ****         timeoutCntSerial_R = SERIAL_TIMEOUT;            // Limit timout counter value
 987:Src/util.c    ****         #if defined(DUAL_INPUTS) && ((defined(CONTROL_SERIAL_USART3) && CONTROL_SERIAL_USART3 == 1)
 988:Src/util.c    ****           inIdx = 0;                                    // Switch to Primary input in case of Timeo
 989:Src/util.c    ****         #endif
 990:Src/util.c    ****       } else {                                          // No Timeout
 991:Src/util.c    ****         #if defined(DUAL_INPUTS) && defined(SIDEBOARD_SERIAL_USART3)
 992:Src/util.c    ****           if (Sideboard_R.sensors & SWA_SET) {          // If SWA is set, switch to Sideboard contr
 993:Src/util.c    ****             inIdx = SIDEBOARD_SERIAL_USART3;
 994:Src/util.c    ****           } else {
 995:Src/util.c    ****             inIdx = !SIDEBOARD_SERIAL_USART3;
 996:Src/util.c    ****           }
 997:Src/util.c    ****         #elif defined(DUAL_INPUTS) && (defined(CONTROL_SERIAL_USART3) && CONTROL_SERIAL_USART3 == 1
 998:Src/util.c    ****           inIdx = 1;                                    // Switch to Auxiliary input in case of NO 
 999:Src/util.c    ****         #endif
1000:Src/util.c    ****       }
1001:Src/util.c    ****       #if (defined(CONTROL_SERIAL_USART3) && CONTROL_SERIAL_USART3 == 0) || (defined(SIDEBOARD_SERI
1002:Src/util.c    ****         timeoutFlgSerial = timeoutFlgSerial_R;          // Report Timeout only on the Primary Input
1003:Src/util.c    ****       #endif
1004:Src/util.c    ****     #endif
1005:Src/util.c    **** 
1006:Src/util.c    ****     #if defined(SIDEBOARD_SERIAL_USART2) && defined(SIDEBOARD_SERIAL_USART3)
1007:Src/util.c    ****       timeoutFlgSerial = timeoutFlgSerial_L || timeoutFlgSerial_R;
1008:Src/util.c    ****     #endif
1009:Src/util.c    **** 
1010:Src/util.c    ****     #if defined(CONTROL_NUNCHUK) || defined(SUPPORT_NUNCHUK) || defined(VARIANT_TRANSPOTTER) || \
1011:Src/util.c    ****         defined(CONTROL_PPM_LEFT) || defined(CONTROL_PPM_RIGHT) || defined(CONTROL_PWM_LEFT) || def
1012:Src/util.c    ****       if (timeoutCntGen++ >= TIMEOUT) {                 // Timeout qualification
1013:Src/util.c    ****         #if defined(CONTROL_NUNCHUK) || defined(SUPPORT_NUNCHUK) || defined(VARIANT_TRANSPOTTER) ||
1014:Src/util.c    ****             (defined(CONTROL_PPM_LEFT) && CONTROL_PPM_LEFT == 0) || (defined(CONTROL_PPM_RIGHT) && 
1015:Src/util.c    ****             (defined(CONTROL_PWM_LEFT) && CONTROL_PWM_LEFT == 0) || (defined(CONTROL_PWM_RIGHT) && 
1016:Src/util.c    ****           timeoutFlgGen = 1;                            // Report Timeout only on the Primary Input
1017:Src/util.c    ****           timeoutCntGen = TIMEOUT;
1018:Src/util.c    ****         #endif
1019:Src/util.c    ****         #if defined(DUAL_INPUTS) && ((defined(CONTROL_PPM_LEFT)  && CONTROL_PPM_LEFT == 1) || (defi
1020:Src/util.c    ****                                      (defined(CONTROL_PWM_LEFT)  && CONTROL_PWM_LEFT == 1) || (defi
1021:Src/util.c    ****           inIdx = 0;                                    // Switch to Primary input in case of Timeo
1022:Src/util.c    ****         #endif
1023:Src/util.c    ****       } else {
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 46


1024:Src/util.c    ****         #if defined(DUAL_INPUTS) && ((defined(CONTROL_PPM_LEFT)  && CONTROL_PPM_LEFT == 1) || (defi
1025:Src/util.c    ****                                      (defined(CONTROL_PWM_LEFT)  && CONTROL_PWM_LEFT == 1) || (defi
1026:Src/util.c    ****           inIdx = 1;                                    // Switch to Auxiliary input in case of NO 
1027:Src/util.c    ****         #endif
1028:Src/util.c    ****       }
1029:Src/util.c    ****     #endif
1030:Src/util.c    **** 
1031:Src/util.c    ****     // In case of timeout bring the system to a Safe State
1032:Src/util.c    ****     if (timeoutFlgADC || timeoutFlgSerial || timeoutFlgGen) {
 1389              		.loc 1 1032 5 is_stmt 1 view .LVU368
 1390              		.loc 1 1032 9 is_stmt 0 view .LVU369
 1391 0022 194A     		ldr	r2, .L101+12
 1392 0024 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 1393              		.loc 1 1032 8 view .LVU370
 1394 0026 1AB9     		cbnz	r2, .L93
 1395              		.loc 1 1032 23 discriminator 1 view .LVU371
 1396 0028 13B9     		cbnz	r3, .L93
 1397              		.loc 1 1032 43 discriminator 2 view .LVU372
 1398 002a 184B     		ldr	r3, .L101+16
 1399 002c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1400 002e C3B1     		cbz	r3, .L94
 1401              	.L93:
1033:Src/util.c    ****       ctrlModReq  = OPEN_MODE;                                          // Request OPEN_MODE. This 
 1402              		.loc 1 1033 7 is_stmt 1 view .LVU373
 1403              		.loc 1 1033 19 is_stmt 0 view .LVU374
 1404 0030 0022     		movs	r2, #0
 1405 0032 174B     		ldr	r3, .L101+20
 1406 0034 1A70     		strb	r2, [r3]
1034:Src/util.c    ****       input1[inIdx].cmd  = 0;
 1407              		.loc 1 1034 7 is_stmt 1 view .LVU375
 1408              		.loc 1 1034 20 is_stmt 0 view .LVU376
 1409 0036 174B     		ldr	r3, .L101+24
 1410 0038 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1411              		.loc 1 1034 26 view .LVU377
 1412 003a C3EBC301 		rsb	r1, r3, r3, lsl #3
 1413 003e 4800     		lsls	r0, r1, #1
 1414 0040 1549     		ldr	r1, .L101+28
 1415 0042 0144     		add	r1, r1, r0
 1416 0044 4A80     		strh	r2, [r1, #2]	@ movhi
1035:Src/util.c    ****       input2[inIdx].cmd  = 0;
 1417              		.loc 1 1035 7 is_stmt 1 view .LVU378
 1418              		.loc 1 1035 26 is_stmt 0 view .LVU379
 1419 0046 154B     		ldr	r3, .L101+32
 1420 0048 0344     		add	r3, r3, r0
 1421 004a 5A80     		strh	r2, [r3, #2]	@ movhi
 1422              	.L95:
1036:Src/util.c    ****     } else {
1037:Src/util.c    ****       ctrlModReq  = ctrlModReqRaw;                                      // Follow the Mode request
1038:Src/util.c    ****     }
1039:Src/util.c    **** 
1040:Src/util.c    ****     // Beep in case of Input index change
1041:Src/util.c    ****     if (inIdx && !inIdx_prev) {                                         // rising edge
 1423              		.loc 1 1041 5 is_stmt 1 view .LVU380
 1424              		.loc 1 1041 9 is_stmt 0 view .LVU381
 1425 004c 114B     		ldr	r3, .L101+24
 1426 004e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1427              		.loc 1 1041 8 view .LVU382
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 47


 1428 0050 13B1     		cbz	r3, .L96
 1429              		.loc 1 1041 18 discriminator 1 view .LVU383
 1430 0052 134A     		ldr	r2, .L101+36
 1431 0054 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 1432              		.loc 1 1041 15 discriminator 1 view .LVU384
 1433 0056 4AB1     		cbz	r2, .L99
 1434              	.L96:
1042:Src/util.c    ****       beepShort(8);
1043:Src/util.c    ****     } else if (!inIdx && inIdx_prev) {                                  // falling edge
 1435              		.loc 1 1043 12 is_stmt 1 view .LVU385
 1436              		.loc 1 1043 15 is_stmt 0 view .LVU386
 1437 0058 13B9     		cbnz	r3, .L91
 1438              		.loc 1 1043 23 discriminator 1 view .LVU387
 1439 005a 114B     		ldr	r3, .L101+36
 1440 005c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1441 005e 4BB9     		cbnz	r3, .L100
 1442              	.L91:
1044:Src/util.c    ****       beepShort(18);
1045:Src/util.c    ****     }
1046:Src/util.c    **** }
 1443              		.loc 1 1046 1 view .LVU388
 1444 0060 08BD     		pop	{r3, pc}
 1445              	.L94:
1037:Src/util.c    ****     }
 1446              		.loc 1 1037 7 is_stmt 1 view .LVU389
1037:Src/util.c    ****     }
 1447              		.loc 1 1037 19 is_stmt 0 view .LVU390
 1448 0062 104B     		ldr	r3, .L101+40
 1449 0064 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 1450 0066 0A4B     		ldr	r3, .L101+20
 1451 0068 1A70     		strb	r2, [r3]
 1452 006a EFE7     		b	.L95
 1453              	.L99:
1042:Src/util.c    ****       beepShort(8);
 1454              		.loc 1 1042 7 is_stmt 1 view .LVU391
 1455 006c 0820     		movs	r0, #8
 1456 006e FFF7FEFF 		bl	beepShort
 1457              	.LVL83:
 1458 0072 F5E7     		b	.L91
 1459              	.L100:
1044:Src/util.c    ****       beepShort(18);
 1460              		.loc 1 1044 7 view .LVU392
 1461 0074 1220     		movs	r0, #18
 1462 0076 FFF7FEFF 		bl	beepShort
 1463              	.LVL84:
 1464              		.loc 1 1046 1 is_stmt 0 view .LVU393
 1465 007a F1E7     		b	.L91
 1466              	.L102:
 1467              		.align	2
 1468              	.L101:
 1469 007c 00000000 		.word	.LANCHOR19
 1470 0080 00000000 		.word	.LANCHOR20
 1471 0084 00000000 		.word	.LANCHOR21
 1472 0088 00000000 		.word	.LANCHOR22
 1473 008c 00000000 		.word	timeoutFlgGen
 1474 0090 00000000 		.word	.LANCHOR23
 1475 0094 00000000 		.word	.LANCHOR17
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 48


 1476 0098 00000000 		.word	.LANCHOR15
 1477 009c 00000000 		.word	.LANCHOR16
 1478 00a0 00000000 		.word	.LANCHOR25
 1479 00a4 00000000 		.word	.LANCHOR24
 1480              		.cfi_endproc
 1481              	.LFE84:
 1483              		.section	.text.readCommand,"ax",%progbits
 1484              		.align	1
 1485              		.global	readCommand
 1486              		.syntax unified
 1487              		.thumb
 1488              		.thumb_func
 1490              	readCommand:
 1491              	.LFB85:
1047:Src/util.c    **** 
1048:Src/util.c    ****  /*
1049:Src/util.c    ****  * Function to calculate the command to the motors. This function also manages:
1050:Src/util.c    ****  * - timeout detection
1051:Src/util.c    ****  * - MIN/MAX limitations and deadband
1052:Src/util.c    ****  */
1053:Src/util.c    **** void readCommand(void) {
 1492              		.loc 1 1053 24 is_stmt 1 view -0
 1493              		.cfi_startproc
 1494              		@ args = 0, pretend = 0, frame = 0
 1495              		@ frame_needed = 0, uses_anonymous_args = 0
 1496 0000 70B5     		push	{r4, r5, r6, lr}
 1497              	.LCFI12:
 1498              		.cfi_def_cfa_offset 16
 1499              		.cfi_offset 4, -16
 1500              		.cfi_offset 5, -12
 1501              		.cfi_offset 6, -8
 1502              		.cfi_offset 14, -4
1054:Src/util.c    ****     readInputRaw();
 1503              		.loc 1 1054 5 view .LVU395
 1504 0002 FFF7FEFF 		bl	readInputRaw
 1505              	.LVL85:
1055:Src/util.c    **** 
1056:Src/util.c    ****     #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
1057:Src/util.c    ****       calcInputCmd(&input1[inIdx], INPUT_MIN, INPUT_MAX);
 1506              		.loc 1 1057 7 view .LVU396
 1507              		.loc 1 1057 27 is_stmt 0 view .LVU397
 1508 0006 0F4E     		ldr	r6, .L105
 1509 0008 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 1510              		.loc 1 1057 7 view .LVU398
 1511 000a 0F4D     		ldr	r5, .L105+4
 1512 000c 0F4C     		ldr	r4, .L105+8
 1513 000e C3EBC303 		rsb	r3, r3, r3, lsl #3
 1514 0012 5800     		lsls	r0, r3, #1
 1515 0014 B5F90020 		ldrsh	r2, [r5]
 1516 0018 B4F90010 		ldrsh	r1, [r4]
 1517 001c 0C4B     		ldr	r3, .L105+12
 1518 001e 1844     		add	r0, r0, r3
 1519 0020 FFF7FEFF 		bl	calcInputCmd
 1520              	.LVL86:
1058:Src/util.c    ****       #if !defined(VARIANT_SKATEBOARD)
1059:Src/util.c    ****         calcInputCmd(&input2[inIdx], INPUT_MIN, INPUT_MAX);
 1521              		.loc 1 1059 9 is_stmt 1 view .LVU399
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 49


 1522              		.loc 1 1059 29 is_stmt 0 view .LVU400
 1523 0024 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 1524              		.loc 1 1059 9 view .LVU401
 1525 0026 C3EBC303 		rsb	r3, r3, r3, lsl #3
 1526 002a 5800     		lsls	r0, r3, #1
 1527 002c B5F90020 		ldrsh	r2, [r5]
 1528 0030 B4F90010 		ldrsh	r1, [r4]
 1529 0034 074B     		ldr	r3, .L105+16
 1530 0036 1844     		add	r0, r0, r3
 1531 0038 FFF7FEFF 		bl	calcInputCmd
 1532              	.LVL87:
1060:Src/util.c    ****       #else
1061:Src/util.c    ****         calcInputCmd(&input2[inIdx], INPUT_BRK, INPUT_MAX);
1062:Src/util.c    ****       #endif
1063:Src/util.c    ****     #endif
1064:Src/util.c    **** 
1065:Src/util.c    ****     handleTimeout();
 1533              		.loc 1 1065 5 is_stmt 1 view .LVU402
 1534 003c FFF7FEFF 		bl	handleTimeout
 1535              	.LVL88:
1066:Src/util.c    **** 
1067:Src/util.c    ****     #ifdef VARIANT_HOVERCAR
1068:Src/util.c    ****     if (inIdx == CONTROL_ADC) {
1069:Src/util.c    ****       brakePressed = (uint8_t)(input1[inIdx].cmd > 50);
1070:Src/util.c    ****     }
1071:Src/util.c    ****     else {
1072:Src/util.c    ****       brakePressed = (uint8_t)(input2[inIdx].cmd < -50);
1073:Src/util.c    ****     }
1074:Src/util.c    ****     #endif
1075:Src/util.c    **** 
1076:Src/util.c    ****     #if defined(SUPPORT_BUTTONS_LEFT) || defined(SUPPORT_BUTTONS_RIGHT)
1077:Src/util.c    ****       button1 = !HAL_GPIO_ReadPin(BUTTON1_PORT, BUTTON1_PIN);
1078:Src/util.c    ****       button2 = !HAL_GPIO_ReadPin(BUTTON2_PORT, BUTTON2_PIN);
1079:Src/util.c    ****     #endif
1080:Src/util.c    **** 
1081:Src/util.c    ****     #if defined(CRUISE_CONTROL_SUPPORT) && (defined(SUPPORT_BUTTONS) || defined(SUPPORT_BUTTONS_LEF
1082:Src/util.c    ****         cruiseControl(button1);                                           // Cruise control activat
1083:Src/util.c    ****     #endif
1084:Src/util.c    **** }
 1536              		.loc 1 1084 1 is_stmt 0 view .LVU403
 1537 0040 70BD     		pop	{r4, r5, r6, pc}
 1538              	.L106:
 1539 0042 00BF     		.align	2
 1540              	.L105:
 1541 0044 00000000 		.word	.LANCHOR17
 1542 0048 00000000 		.word	.LANCHOR9
 1543 004c 00000000 		.word	.LANCHOR10
 1544 0050 00000000 		.word	.LANCHOR15
 1545 0054 00000000 		.word	.LANCHOR16
 1546              		.cfi_endproc
 1547              	.LFE85:
 1549              		.section	.text.usart3_rx_check,"ax",%progbits
 1550              		.align	1
 1551              		.global	usart3_rx_check
 1552              		.syntax unified
 1553              		.thumb
 1554              		.thumb_func
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 50


 1556              	usart3_rx_check:
 1557              	.LFB87:
1085:Src/util.c    **** 
1086:Src/util.c    **** 
1087:Src/util.c    **** /*
1088:Src/util.c    ****  * Check for new data received on USART2 with DMA: refactored function from https://github.com/MaJe
1089:Src/util.c    ****  * - this function is called for every USART IDLE line detection, in the USART interrupt handler
1090:Src/util.c    ****  */
1091:Src/util.c    **** void usart2_rx_check(void)
1092:Src/util.c    **** {
1093:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_US
1094:Src/util.c    ****   static uint32_t old_pos;
1095:Src/util.c    ****   uint32_t pos;
1096:Src/util.c    ****   pos = rx_buffer_L_len - __HAL_DMA_GET_COUNTER(huart2.hdmarx);         // Calculate current positi
1097:Src/util.c    ****   #endif
1098:Src/util.c    **** 
1099:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2)
1100:Src/util.c    ****   uint8_t ptr_debug[SERIAL_BUFFER_SIZE];
1101:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
1102:Src/util.c    ****     if (pos > old_pos) {                                                // "Linear" buffer mode: ch
1103:Src/util.c    ****       usart_process_debug(&rx_buffer_L[old_pos], pos - old_pos);        // Process data
1104:Src/util.c    ****     } else {                                                            // "Overflow" buffer mode
1105:Src/util.c    ****       memcpy(&ptr_debug[0], &rx_buffer_L[old_pos], rx_buffer_L_len - old_pos);    // First copy dat
1106:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
1107:Src/util.c    ****         memcpy(&ptr_debug[rx_buffer_L_len - old_pos], &rx_buffer_L[0], pos);                       
1108:Src/util.c    ****       }
1109:Src/util.c    ****       usart_process_debug(ptr_debug, rx_buffer_L_len - old_pos + pos);        // Process data
1110:Src/util.c    ****     }
1111:Src/util.c    ****   }
1112:Src/util.c    ****   #endif // DEBUG_SERIAL_USART2
1113:Src/util.c    **** 
1114:Src/util.c    ****   #ifdef CONTROL_SERIAL_USART2
1115:Src/util.c    ****   uint8_t *ptr;	
1116:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
1117:Src/util.c    ****     ptr = (uint8_t *)&commandL_raw;                                     // Initialize the pointer w
1118:Src/util.c    ****     if (pos > old_pos && (pos - old_pos) == commandL_len) {             // "Linear" buffer mode: ch
1119:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], commandL_len);                 // Copy data. This is possi
1120:Src/util.c    ****       usart_process_command(&commandL_raw, &commandL, 2);               // Process data
1121:Src/util.c    ****     } else if ((rx_buffer_L_len - old_pos + pos) == commandL_len) {     // "Overflow" buffer mode: 
1122:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], rx_buffer_L_len - old_pos);    // First copy data from the
1123:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
1124:Src/util.c    ****         ptr += rx_buffer_L_len - old_pos;                               // Move to correct position
1125:Src/util.c    ****         memcpy(ptr, &rx_buffer_L[0], pos);                              // Copy remaining data
1126:Src/util.c    ****       }
1127:Src/util.c    ****       usart_process_command(&commandL_raw, &commandL, 2);               // Process data
1128:Src/util.c    ****     }
1129:Src/util.c    ****   }
1130:Src/util.c    ****   #endif // CONTROL_SERIAL_USART2
1131:Src/util.c    **** 
1132:Src/util.c    ****   #ifdef SIDEBOARD_SERIAL_USART2
1133:Src/util.c    ****   uint8_t *ptr;	
1134:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
1135:Src/util.c    ****     ptr = (uint8_t *)&Sideboard_L_raw;                                  // Initialize the pointer w
1136:Src/util.c    ****     if (pos > old_pos && (pos - old_pos) == Sideboard_L_len) {          // "Linear" buffer mode: ch
1137:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], Sideboard_L_len);              // Copy data. This is possi
1138:Src/util.c    ****       usart_process_sideboard(&Sideboard_L_raw, &Sideboard_L, 2);       // Process data
1139:Src/util.c    ****     } else if ((rx_buffer_L_len - old_pos + pos) == Sideboard_L_len) {  // "Overflow" buffer mode: 
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 51


1140:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], rx_buffer_L_len - old_pos);    // First copy data from the
1141:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
1142:Src/util.c    ****         ptr += rx_buffer_L_len - old_pos;                               // Move to correct position
1143:Src/util.c    ****         memcpy(ptr, &rx_buffer_L[0], pos);                              // Copy remaining data
1144:Src/util.c    ****       }
1145:Src/util.c    ****       usart_process_sideboard(&Sideboard_L_raw, &Sideboard_L, 2);       // Process data
1146:Src/util.c    ****     }
1147:Src/util.c    ****   }
1148:Src/util.c    ****   #endif // SIDEBOARD_SERIAL_USART2
1149:Src/util.c    **** 
1150:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_US
1151:Src/util.c    ****   old_pos = pos;                                                        // Update old position
1152:Src/util.c    ****   if (old_pos == rx_buffer_L_len) {                                     // Check and manually updat
1153:Src/util.c    ****     old_pos = 0;
1154:Src/util.c    ****   }
1155:Src/util.c    **** 	#endif
1156:Src/util.c    **** }
1157:Src/util.c    **** 
1158:Src/util.c    **** 
1159:Src/util.c    **** /*
1160:Src/util.c    ****  * Check for new data received on USART3 with DMA: refactored function from https://github.com/MaJe
1161:Src/util.c    ****  * - this function is called for every USART IDLE line detection, in the USART interrupt handler
1162:Src/util.c    ****  */
1163:Src/util.c    **** void usart3_rx_check(void)
1164:Src/util.c    **** {
 1558              		.loc 1 1164 1 is_stmt 1 view -0
 1559              		.cfi_startproc
 1560              		@ args = 0, pretend = 0, frame = 0
 1561              		@ frame_needed = 0, uses_anonymous_args = 0
 1562              		@ link register save eliminated.
1165:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_US
1166:Src/util.c    ****   static uint32_t old_pos;
1167:Src/util.c    ****   uint32_t pos;  
1168:Src/util.c    ****   pos = rx_buffer_R_len - __HAL_DMA_GET_COUNTER(huart3.hdmarx);         // Calculate current positi
1169:Src/util.c    ****   #endif
1170:Src/util.c    **** 
1171:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART3)
1172:Src/util.c    ****   uint8_t ptr_debug[SERIAL_BUFFER_SIZE];
1173:Src/util.c    **** 
1174:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
1175:Src/util.c    ****     if (pos > old_pos) {                                                // "Linear" buffer mode: ch
1176:Src/util.c    ****       usart_process_debug(&rx_buffer_R[old_pos], pos - old_pos);        // Process data
1177:Src/util.c    ****     } else {                                                            // "Overflow" buffer mode
1178:Src/util.c    ****       memcpy(&ptr_debug[0], &rx_buffer_R[old_pos], rx_buffer_R_len - old_pos);    // First copy dat
1179:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
1180:Src/util.c    ****         memcpy(&ptr_debug[rx_buffer_R_len - old_pos], &rx_buffer_R[0], pos);                       
1181:Src/util.c    ****       }
1182:Src/util.c    ****       usart_process_debug(ptr_debug, rx_buffer_R_len - old_pos + pos);        // Process data
1183:Src/util.c    ****     }
1184:Src/util.c    ****   }
1185:Src/util.c    ****   #endif // DEBUG_SERIAL_USART3
1186:Src/util.c    **** 
1187:Src/util.c    ****   #ifdef CONTROL_SERIAL_USART3
1188:Src/util.c    ****   uint8_t *ptr;
1189:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
1190:Src/util.c    ****     ptr = (uint8_t *)&commandR_raw;                                     // Initialize the pointer w
1191:Src/util.c    ****     if (pos > old_pos && (pos - old_pos) == commandR_len) {             // "Linear" buffer mode: ch
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 52


1192:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], commandR_len);                 // Copy data. This is possi
1193:Src/util.c    ****       usart_process_command(&commandR_raw, &commandR, 3);               // Process data
1194:Src/util.c    ****     } else if ((rx_buffer_R_len - old_pos + pos) == commandR_len) {     // "Overflow" buffer mode: 
1195:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], rx_buffer_R_len - old_pos);    // First copy data from the
1196:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
1197:Src/util.c    ****         ptr += rx_buffer_R_len - old_pos;                               // Move to correct position
1198:Src/util.c    ****         memcpy(ptr, &rx_buffer_R[0], pos);                              // Copy remaining data
1199:Src/util.c    ****       }
1200:Src/util.c    ****       usart_process_command(&commandR_raw, &commandR, 3);               // Process data
1201:Src/util.c    ****     }
1202:Src/util.c    ****   }
1203:Src/util.c    ****   #endif // CONTROL_SERIAL_USART3
1204:Src/util.c    **** 
1205:Src/util.c    ****   #ifdef SIDEBOARD_SERIAL_USART3
1206:Src/util.c    ****   uint8_t *ptr;
1207:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
1208:Src/util.c    ****     ptr = (uint8_t *)&Sideboard_R_raw;                                  // Initialize the pointer w
1209:Src/util.c    ****     if (pos > old_pos && (pos - old_pos) == Sideboard_R_len) {          // "Linear" buffer mode: ch
1210:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], Sideboard_R_len);              // Copy data. This is possi
1211:Src/util.c    ****       usart_process_sideboard(&Sideboard_R_raw, &Sideboard_R, 3);       // Process data
1212:Src/util.c    ****     } else if ((rx_buffer_R_len - old_pos + pos) == Sideboard_R_len) {  // "Overflow" buffer mode: 
1213:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], rx_buffer_R_len - old_pos);    // First copy data from the
1214:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
1215:Src/util.c    ****         ptr += rx_buffer_R_len - old_pos;                               // Move to correct position
1216:Src/util.c    ****         memcpy(ptr, &rx_buffer_R[0], pos);                              // Copy remaining data
1217:Src/util.c    ****       }
1218:Src/util.c    ****       usart_process_sideboard(&Sideboard_R_raw, &Sideboard_R, 3);       // Process data
1219:Src/util.c    ****     }
1220:Src/util.c    ****   }
1221:Src/util.c    ****   #endif // SIDEBOARD_SERIAL_USART3
1222:Src/util.c    **** 
1223:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_US
1224:Src/util.c    ****   old_pos = pos;                                                        // Update old position
1225:Src/util.c    ****   if (old_pos == rx_buffer_R_len) {                                     // Check and manually updat
1226:Src/util.c    ****     old_pos = 0;
1227:Src/util.c    ****   }
1228:Src/util.c    ****   #endif
1229:Src/util.c    **** }
 1563              		.loc 1 1229 1 view .LVU405
 1564 0000 7047     		bx	lr
 1565              		.cfi_endproc
 1566              	.LFE87:
 1568              		.section	.text.usart_process_command,"ax",%progbits
 1569              		.align	1
 1570              		.global	usart_process_command
 1571              		.syntax unified
 1572              		.thumb
 1573              		.thumb_func
 1575              	usart_process_command:
 1576              	.LVL89:
 1577              	.LFB88:
1230:Src/util.c    **** 
1231:Src/util.c    **** /*
1232:Src/util.c    ****  * Process Rx debug user command input
1233:Src/util.c    ****  */
1234:Src/util.c    **** #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
1235:Src/util.c    **** void usart_process_debug(uint8_t *userCommand, uint32_t len)
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 53


1236:Src/util.c    **** {
1237:Src/util.c    ****   #ifdef DEBUG_SERIAL_PROTOCOL
1238:Src/util.c    ****     handle_input(userCommand, len);
1239:Src/util.c    ****   #endif
1240:Src/util.c    **** }
1241:Src/util.c    **** 
1242:Src/util.c    **** #endif // SERIAL_DEBUG
1243:Src/util.c    **** 
1244:Src/util.c    **** /*
1245:Src/util.c    ****  * Process command Rx data
1246:Src/util.c    ****  * - if the command_in data is valid (correct START_FRAME and checksum) copy the command_in to comm
1247:Src/util.c    ****  */
1248:Src/util.c    **** #if defined(CONTROL_SERIAL_USART2) || defined(CONTROL_SERIAL_USART3)
1249:Src/util.c    **** void usart_process_command(SerialCommand *command_in, SerialCommand *command_out, uint8_t usart_idx
1250:Src/util.c    **** {
 1578              		.loc 1 1250 1 view -0
 1579              		.cfi_startproc
 1580              		@ args = 0, pretend = 0, frame = 0
 1581              		@ frame_needed = 0, uses_anonymous_args = 0
 1582              		@ link register save eliminated.
1251:Src/util.c    ****   #ifdef CONTROL_IBUS
1252:Src/util.c    ****     uint16_t ibus_chksum;
1253:Src/util.c    ****     if (command_in->start == IBUS_LENGTH && command_in->type == IBUS_COMMAND) {
1254:Src/util.c    ****       ibus_chksum = 0xFFFF - IBUS_LENGTH - IBUS_COMMAND;
1255:Src/util.c    ****       for (uint8_t i = 0; i < (IBUS_NUM_CHANNELS * 2); i++) {
1256:Src/util.c    ****         ibus_chksum -= command_in->channels[i];
1257:Src/util.c    ****       }
1258:Src/util.c    ****       if (ibus_chksum == (uint16_t)((command_in->checksumh << 8) + command_in->checksuml)) {
1259:Src/util.c    ****         *command_out = *command_in;
1260:Src/util.c    ****         if (usart_idx == 2) {             // Sideboard USART2
1261:Src/util.c    ****           #ifdef CONTROL_SERIAL_USART2
1262:Src/util.c    ****           timeoutFlgSerial_L = 0;         // Clear timeout flag
1263:Src/util.c    ****           timeoutCntSerial_L = 0;         // Reset timeout counter
1264:Src/util.c    ****           #endif
1265:Src/util.c    ****         } else if (usart_idx == 3) {      // Sideboard USART3
1266:Src/util.c    ****           #ifdef CONTROL_SERIAL_USART3
1267:Src/util.c    ****           timeoutFlgSerial_R = 0;         // Clear timeout flag
1268:Src/util.c    ****           timeoutCntSerial_R = 0;         // Reset timeout counter
1269:Src/util.c    ****           #endif
1270:Src/util.c    ****         }
1271:Src/util.c    ****       }
1272:Src/util.c    ****     }
1273:Src/util.c    ****   #else
1274:Src/util.c    ****   uint16_t checksum;
 1583              		.loc 1 1274 3 view .LVU407
1275:Src/util.c    ****   if (command_in->start == SERIAL_START_FRAME) {
 1584              		.loc 1 1275 3 view .LVU408
 1585              		.loc 1 1275 17 is_stmt 0 view .LVU409
 1586 0000 0388     		ldrh	r3, [r0]
 1587              		.loc 1 1275 6 view .LVU410
 1588 0002 4AF6CD3C 		movw	ip, #43981
 1589 0006 6345     		cmp	r3, ip
 1590 0008 00D0     		beq	.L110
 1591              	.LVL90:
 1592              	.L108:
1276:Src/util.c    ****     checksum = (uint16_t)(command_in->start ^ command_in->steer ^ command_in->speed);
1277:Src/util.c    ****     if (command_in->checksum == checksum) {
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 54


1278:Src/util.c    ****       *command_out = *command_in;
1279:Src/util.c    ****       if (usart_idx == 2) {             // Sideboard USART2
1280:Src/util.c    ****         #ifdef CONTROL_SERIAL_USART2
1281:Src/util.c    ****         timeoutFlgSerial_L = 0;         // Clear timeout flag
1282:Src/util.c    ****         timeoutCntSerial_L = 0;         // Reset timeout counter
1283:Src/util.c    ****         #endif
1284:Src/util.c    ****       } else if (usart_idx == 3) {      // Sideboard USART3
1285:Src/util.c    ****         #ifdef CONTROL_SERIAL_USART3
1286:Src/util.c    ****         timeoutFlgSerial_R = 0;         // Clear timeout flag
1287:Src/util.c    ****         timeoutCntSerial_R = 0;         // Reset timeout counter
1288:Src/util.c    ****         #endif
1289:Src/util.c    ****       }
1290:Src/util.c    ****     }
1291:Src/util.c    ****   }
1292:Src/util.c    ****   #endif
1293:Src/util.c    **** }
 1593              		.loc 1 1293 1 view .LVU411
 1594 000a 7047     		bx	lr
 1595              	.LVL91:
 1596              	.L110:
1276:Src/util.c    ****     checksum = (uint16_t)(command_in->start ^ command_in->steer ^ command_in->speed);
 1597              		.loc 1 1276 5 is_stmt 1 view .LVU412
1276:Src/util.c    ****     checksum = (uint16_t)(command_in->start ^ command_in->steer ^ command_in->speed);
 1598              		.loc 1 1276 37 is_stmt 0 view .LVU413
 1599 000c 1BB2     		sxth	r3, r3
1276:Src/util.c    ****     checksum = (uint16_t)(command_in->start ^ command_in->steer ^ command_in->speed);
 1600              		.loc 1 1276 57 view .LVU414
 1601 000e B0F902C0 		ldrsh	ip, [r0, #2]
1276:Src/util.c    ****     checksum = (uint16_t)(command_in->start ^ command_in->steer ^ command_in->speed);
 1602              		.loc 1 1276 45 view .LVU415
 1603 0012 83EA0C03 		eor	r3, r3, ip
1276:Src/util.c    ****     checksum = (uint16_t)(command_in->start ^ command_in->steer ^ command_in->speed);
 1604              		.loc 1 1276 77 view .LVU416
 1605 0016 B0F904C0 		ldrsh	ip, [r0, #4]
1276:Src/util.c    ****     checksum = (uint16_t)(command_in->start ^ command_in->steer ^ command_in->speed);
 1606              		.loc 1 1276 65 view .LVU417
 1607 001a 83EA0C03 		eor	r3, r3, ip
1276:Src/util.c    ****     checksum = (uint16_t)(command_in->start ^ command_in->steer ^ command_in->speed);
 1608              		.loc 1 1276 14 view .LVU418
 1609 001e 9BB2     		uxth	r3, r3
 1610              	.LVL92:
1277:Src/util.c    ****       *command_out = *command_in;
 1611              		.loc 1 1277 5 is_stmt 1 view .LVU419
1277:Src/util.c    ****       *command_out = *command_in;
 1612              		.loc 1 1277 19 is_stmt 0 view .LVU420
 1613 0020 B0F806C0 		ldrh	ip, [r0, #6]
1277:Src/util.c    ****       *command_out = *command_in;
 1614              		.loc 1 1277 8 view .LVU421
 1615 0024 9C45     		cmp	ip, r3
 1616 0026 F0D1     		bne	.L108
1278:Src/util.c    ****       if (usart_idx == 2) {             // Sideboard USART2
 1617              		.loc 1 1278 7 is_stmt 1 view .LVU422
1278:Src/util.c    ****       if (usart_idx == 2) {             // Sideboard USART2
 1618              		.loc 1 1278 20 is_stmt 0 view .LVU423
 1619 0028 D0F800C0 		ldr	ip, [r0]	@ unaligned
 1620 002c 4368     		ldr	r3, [r0, #4]	@ unaligned
 1621              	.LVL93:
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 55


1278:Src/util.c    ****       if (usart_idx == 2) {             // Sideboard USART2
 1622              		.loc 1 1278 20 view .LVU424
 1623 002e C1F800C0 		str	ip, [r1]	@ unaligned
 1624 0032 4B60     		str	r3, [r1, #4]	@ unaligned
1279:Src/util.c    ****         #ifdef CONTROL_SERIAL_USART2
 1625              		.loc 1 1279 7 is_stmt 1 view .LVU425
1279:Src/util.c    ****         #ifdef CONTROL_SERIAL_USART2
 1626              		.loc 1 1279 10 is_stmt 0 view .LVU426
 1627 0034 022A     		cmp	r2, #2
 1628 0036 E8D1     		bne	.L108
1281:Src/util.c    ****         timeoutCntSerial_L = 0;         // Reset timeout counter
 1629              		.loc 1 1281 9 is_stmt 1 view .LVU427
1281:Src/util.c    ****         timeoutCntSerial_L = 0;         // Reset timeout counter
 1630              		.loc 1 1281 28 is_stmt 0 view .LVU428
 1631 0038 0023     		movs	r3, #0
 1632 003a 024A     		ldr	r2, .L111
 1633              	.LVL94:
1281:Src/util.c    ****         timeoutCntSerial_L = 0;         // Reset timeout counter
 1634              		.loc 1 1281 28 view .LVU429
 1635 003c 1370     		strb	r3, [r2]
1282:Src/util.c    ****         #endif
 1636              		.loc 1 1282 9 is_stmt 1 view .LVU430
1282:Src/util.c    ****         #endif
 1637              		.loc 1 1282 28 is_stmt 0 view .LVU431
 1638 003e 024A     		ldr	r2, .L111+4
 1639 0040 1380     		strh	r3, [r2]	@ movhi
1289:Src/util.c    ****     }
 1640              		.loc 1 1289 7 is_stmt 1 view .LVU432
 1641              		.loc 1 1293 1 is_stmt 0 view .LVU433
 1642 0042 E2E7     		b	.L108
 1643              	.L112:
 1644              		.align	2
 1645              	.L111:
 1646 0044 00000000 		.word	.LANCHOR20
 1647 0048 00000000 		.word	.LANCHOR19
 1648              		.cfi_endproc
 1649              	.LFE88:
 1651              		.section	.text.usart2_rx_check,"ax",%progbits
 1652              		.align	1
 1653              		.global	usart2_rx_check
 1654              		.syntax unified
 1655              		.thumb
 1656              		.thumb_func
 1658              	usart2_rx_check:
 1659              	.LFB86:
1092:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_US
 1660              		.loc 1 1092 1 is_stmt 1 view -0
 1661              		.cfi_startproc
 1662              		@ args = 0, pretend = 0, frame = 0
 1663              		@ frame_needed = 0, uses_anonymous_args = 0
 1664 0000 38B5     		push	{r3, r4, r5, lr}
 1665              	.LCFI13:
 1666              		.cfi_def_cfa_offset 16
 1667              		.cfi_offset 3, -16
 1668              		.cfi_offset 4, -12
 1669              		.cfi_offset 5, -8
 1670              		.cfi_offset 14, -4
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 56


1094:Src/util.c    ****   uint32_t pos;
 1671              		.loc 1 1094 3 view .LVU435
1095:Src/util.c    ****   pos = rx_buffer_L_len - __HAL_DMA_GET_COUNTER(huart2.hdmarx);         // Calculate current positi
 1672              		.loc 1 1095 3 view .LVU436
1096:Src/util.c    ****   #endif
 1673              		.loc 1 1096 3 view .LVU437
1096:Src/util.c    ****   #endif
 1674              		.loc 1 1096 27 is_stmt 0 view .LVU438
 1675 0002 1F4B     		ldr	r3, .L123
 1676 0004 5B6B     		ldr	r3, [r3, #52]
 1677 0006 1B68     		ldr	r3, [r3]
 1678 0008 5C68     		ldr	r4, [r3, #4]
1096:Src/util.c    ****   #endif
 1679              		.loc 1 1096 7 view .LVU439
 1680 000a C4F14004 		rsb	r4, r4, #64
 1681              	.LVL95:
1115:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
 1682              		.loc 1 1115 3 is_stmt 1 view .LVU440
1116:Src/util.c    ****     ptr = (uint8_t *)&commandL_raw;                                     // Initialize the pointer w
 1683              		.loc 1 1116 3 view .LVU441
1116:Src/util.c    ****     ptr = (uint8_t *)&commandL_raw;                                     // Initialize the pointer w
 1684              		.loc 1 1116 11 is_stmt 0 view .LVU442
 1685 000e 1D4B     		ldr	r3, .L123+4
 1686 0010 1B68     		ldr	r3, [r3]
1116:Src/util.c    ****     ptr = (uint8_t *)&commandL_raw;                                     // Initialize the pointer w
 1687              		.loc 1 1116 6 view .LVU443
 1688 0012 A342     		cmp	r3, r4
 1689 0014 08D0     		beq	.L114
1117:Src/util.c    ****     if (pos > old_pos && (pos - old_pos) == commandL_len) {             // "Linear" buffer mode: ch
 1690              		.loc 1 1117 5 is_stmt 1 view .LVU444
 1691              	.LVL96:
1118:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], commandL_len);                 // Copy data. This is possi
 1692              		.loc 1 1118 5 view .LVU445
1118:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], commandL_len);                 // Copy data. This is possi
 1693              		.loc 1 1118 8 is_stmt 0 view .LVU446
 1694 0016 02D2     		bcs	.L115
1118:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], commandL_len);                 // Copy data. This is possi
 1695              		.loc 1 1118 31 discriminator 1 view .LVU447
 1696 0018 E21A     		subs	r2, r4, r3
1118:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], commandL_len);                 // Copy data. This is possi
 1697              		.loc 1 1118 23 discriminator 1 view .LVU448
 1698 001a 082A     		cmp	r2, #8
 1699 001c 09D0     		beq	.L119
 1700              	.L115:
1121:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], rx_buffer_L_len - old_pos);    // First copy data from the
 1701              		.loc 1 1121 12 is_stmt 1 view .LVU449
1121:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], rx_buffer_L_len - old_pos);    // First copy data from the
 1702              		.loc 1 1121 33 is_stmt 0 view .LVU450
 1703 001e C3F14005 		rsb	r5, r3, #64
1121:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], rx_buffer_L_len - old_pos);    // First copy data from the
 1704              		.loc 1 1121 43 view .LVU451
 1705 0022 2A19     		adds	r2, r5, r4
1121:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], rx_buffer_L_len - old_pos);    // First copy data from the
 1706              		.loc 1 1121 15 view .LVU452
 1707 0024 082A     		cmp	r2, #8
 1708 0026 13D0     		beq	.L120
 1709              	.LVL97:
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 57


 1710              	.L114:
1151:Src/util.c    ****   if (old_pos == rx_buffer_L_len) {                                     // Check and manually updat
 1711              		.loc 1 1151 3 is_stmt 1 view .LVU453
1151:Src/util.c    ****   if (old_pos == rx_buffer_L_len) {                                     // Check and manually updat
 1712              		.loc 1 1151 11 is_stmt 0 view .LVU454
 1713 0028 164B     		ldr	r3, .L123+4
 1714 002a 1C60     		str	r4, [r3]
1152:Src/util.c    ****     old_pos = 0;
 1715              		.loc 1 1152 3 is_stmt 1 view .LVU455
1152:Src/util.c    ****     old_pos = 0;
 1716              		.loc 1 1152 6 is_stmt 0 view .LVU456
 1717 002c 402C     		cmp	r4, #64
 1718 002e 23D0     		beq	.L121
 1719              	.L113:
1156:Src/util.c    **** 
 1720              		.loc 1 1156 1 view .LVU457
 1721 0030 38BD     		pop	{r3, r4, r5, pc}
 1722              	.LVL98:
 1723              	.L119:
1119:Src/util.c    ****       usart_process_command(&commandL_raw, &commandL, 2);               // Process data
 1724              		.loc 1 1119 7 is_stmt 1 view .LVU458
1119:Src/util.c    ****       usart_process_command(&commandL_raw, &commandL, 2);               // Process data
 1725              		.loc 1 1119 19 is_stmt 0 view .LVU459
 1726 0032 1549     		ldr	r1, .L123+8
 1727 0034 01EB030C 		add	ip, r1, r3
1119:Src/util.c    ****       usart_process_command(&commandL_raw, &commandL, 2);               // Process data
 1728              		.loc 1 1119 7 view .LVU460
 1729 0038 144D     		ldr	r5, .L123+12
 1730 003a 2A46     		mov	r2, r5
 1731 003c C858     		ldr	r0, [r1, r3]	@ unaligned
 1732 003e DCF80410 		ldr	r1, [ip, #4]	@ unaligned
 1733 0042 03C2     		stmia	r2!, {r0, r1}
1120:Src/util.c    ****     } else if ((rx_buffer_L_len - old_pos + pos) == commandL_len) {     // "Overflow" buffer mode: 
 1734              		.loc 1 1120 7 is_stmt 1 view .LVU461
 1735 0044 0222     		movs	r2, #2
 1736 0046 1249     		ldr	r1, .L123+16
 1737 0048 2846     		mov	r0, r5
 1738 004a FFF7FEFF 		bl	usart_process_command
 1739              	.LVL99:
 1740 004e EBE7     		b	.L114
 1741              	.L120:
1122:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
 1742              		.loc 1 1122 7 view .LVU462
 1743 0050 2A46     		mov	r2, r5
 1744 0052 0D49     		ldr	r1, .L123+8
 1745 0054 1944     		add	r1, r1, r3
 1746 0056 0D48     		ldr	r0, .L123+12
 1747 0058 FFF7FEFF 		bl	memcpy
 1748              	.LVL100:
1123:Src/util.c    ****         ptr += rx_buffer_L_len - old_pos;                               // Move to correct position
 1749              		.loc 1 1123 7 view .LVU463
1123:Src/util.c    ****         ptr += rx_buffer_L_len - old_pos;                               // Move to correct position
 1750              		.loc 1 1123 10 is_stmt 0 view .LVU464
 1751 005c 2CB9     		cbnz	r4, .L122
 1752              	.LVL101:
 1753              	.L116:
1127:Src/util.c    ****     }
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 58


 1754              		.loc 1 1127 7 is_stmt 1 view .LVU465
 1755 005e 0222     		movs	r2, #2
 1756 0060 0B49     		ldr	r1, .L123+16
 1757 0062 0A48     		ldr	r0, .L123+12
 1758 0064 FFF7FEFF 		bl	usart_process_command
 1759              	.LVL102:
 1760 0068 DEE7     		b	.L114
 1761              	.LVL103:
 1762              	.L122:
1124:Src/util.c    ****         memcpy(ptr, &rx_buffer_L[0], pos);                              // Copy remaining data
 1763              		.loc 1 1124 9 view .LVU466
1125:Src/util.c    ****       }
 1764              		.loc 1 1125 9 view .LVU467
 1765 006a 2246     		mov	r2, r4
 1766 006c 0649     		ldr	r1, .L123+8
 1767 006e 0748     		ldr	r0, .L123+12
 1768 0070 2844     		add	r0, r0, r5
 1769              	.LVL104:
1125:Src/util.c    ****       }
 1770              		.loc 1 1125 9 is_stmt 0 view .LVU468
 1771 0072 FFF7FEFF 		bl	memcpy
 1772              	.LVL105:
1125:Src/util.c    ****       }
 1773              		.loc 1 1125 9 view .LVU469
 1774 0076 F2E7     		b	.L116
 1775              	.LVL106:
 1776              	.L121:
1153:Src/util.c    ****   }
 1777              		.loc 1 1153 5 is_stmt 1 view .LVU470
1153:Src/util.c    ****   }
 1778              		.loc 1 1153 13 is_stmt 0 view .LVU471
 1779 0078 0022     		movs	r2, #0
 1780 007a 1A60     		str	r2, [r3]
1156:Src/util.c    **** 
 1781              		.loc 1 1156 1 view .LVU472
 1782 007c D8E7     		b	.L113
 1783              	.L124:
 1784 007e 00BF     		.align	2
 1785              	.L123:
 1786 0080 00000000 		.word	huart2
 1787 0084 00000000 		.word	.LANCHOR26
 1788 0088 00000000 		.word	.LANCHOR13
 1789 008c 00000000 		.word	.LANCHOR27
 1790 0090 00000000 		.word	.LANCHOR18
 1791              		.cfi_endproc
 1792              	.LFE86:
 1794              		.section	.text.sideboardLeds,"ax",%progbits
 1795              		.align	1
 1796              		.global	sideboardLeds
 1797              		.syntax unified
 1798              		.thumb
 1799              		.thumb_func
 1801              	sideboardLeds:
 1802              	.LVL107:
 1803              	.LFB89:
1294:Src/util.c    **** #endif
1295:Src/util.c    **** 
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 59


1296:Src/util.c    **** /*
1297:Src/util.c    ****  * Process Sideboard Rx data
1298:Src/util.c    ****  * - if the Sideboard_in data is valid (correct START_FRAME and checksum) copy the Sideboard_in to 
1299:Src/util.c    ****  */
1300:Src/util.c    **** #if defined(SIDEBOARD_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USART3)
1301:Src/util.c    **** void usart_process_sideboard(SerialSideboard *Sideboard_in, SerialSideboard *Sideboard_out, uint8_t
1302:Src/util.c    **** {
1303:Src/util.c    ****   uint16_t checksum;
1304:Src/util.c    ****   if (Sideboard_in->start == SERIAL_START_FRAME) {
1305:Src/util.c    ****     checksum = (uint16_t)(Sideboard_in->start ^ Sideboard_in->pitch ^ Sideboard_in->dPitch ^ Sidebo
1306:Src/util.c    ****     if (Sideboard_in->checksum == checksum) {
1307:Src/util.c    ****       *Sideboard_out = *Sideboard_in;
1308:Src/util.c    ****       if (usart_idx == 2) {             // Sideboard USART2
1309:Src/util.c    ****         #ifdef SIDEBOARD_SERIAL_USART2
1310:Src/util.c    ****         timeoutCntSerial_L  = 0;        // Reset timeout counter
1311:Src/util.c    ****         timeoutFlgSerial_L = 0;         // Clear timeout flag
1312:Src/util.c    ****         #endif
1313:Src/util.c    ****       } else if (usart_idx == 3) {      // Sideboard USART3
1314:Src/util.c    ****         #ifdef SIDEBOARD_SERIAL_USART3
1315:Src/util.c    ****         timeoutCntSerial_R = 0;         // Reset timeout counter
1316:Src/util.c    ****         timeoutFlgSerial_R = 0;         // Clear timeout flag
1317:Src/util.c    ****         #endif
1318:Src/util.c    ****       }
1319:Src/util.c    ****     }
1320:Src/util.c    ****   }
1321:Src/util.c    **** }
1322:Src/util.c    **** #endif
1323:Src/util.c    **** 
1324:Src/util.c    **** 
1325:Src/util.c    **** /* =========================== Sideboard Functions =========================== */
1326:Src/util.c    **** 
1327:Src/util.c    **** /*
1328:Src/util.c    ****  * Sideboard LEDs Handling
1329:Src/util.c    ****  * This function manages the leds behavior connected to the sideboard
1330:Src/util.c    ****  */
1331:Src/util.c    **** void sideboardLeds(uint8_t *leds) {
 1804              		.loc 1 1331 35 is_stmt 1 view -0
 1805              		.cfi_startproc
 1806              		@ args = 0, pretend = 0, frame = 0
 1807              		@ frame_needed = 0, uses_anonymous_args = 0
 1808              		@ link register save eliminated.
1332:Src/util.c    ****   #if defined(SIDEBOARD_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USART3)
1333:Src/util.c    ****     // Enable flag: use LED4 (bottom Blue)
1334:Src/util.c    ****     // enable == 1, turn on led
1335:Src/util.c    ****     // enable == 0, blink led
1336:Src/util.c    ****     if (enable) {
1337:Src/util.c    ****       *leds |= LED4_SET;
1338:Src/util.c    ****     } else if (!enable && (main_loop_counter % 20 == 0)) {
1339:Src/util.c    ****       *leds ^= LED4_SET;
1340:Src/util.c    ****     }
1341:Src/util.c    **** 
1342:Src/util.c    ****     // Backward Drive: use LED5 (upper Blue)
1343:Src/util.c    ****     // backwardDrive == 1, blink led
1344:Src/util.c    ****     // backwardDrive == 0, turn off led
1345:Src/util.c    ****     if (backwardDrive && (main_loop_counter % 50 == 0)) {
1346:Src/util.c    ****       *leds ^= LED5_SET;
1347:Src/util.c    ****     }
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 60


1348:Src/util.c    **** 
1349:Src/util.c    ****     // Brake: use LED5 (upper Blue)
1350:Src/util.c    ****     // brakePressed == 1, turn on led
1351:Src/util.c    ****     // brakePressed == 0, turn off led
1352:Src/util.c    ****     #ifdef VARIANT_HOVERCAR
1353:Src/util.c    ****       if (brakePressed) {
1354:Src/util.c    ****         *leds |= LED5_SET;
1355:Src/util.c    ****       } else if (!brakePressed && !backwardDrive) {
1356:Src/util.c    ****         *leds &= ~LED5_SET;
1357:Src/util.c    ****       }
1358:Src/util.c    ****     #endif
1359:Src/util.c    **** 
1360:Src/util.c    ****     // Battery Level Indicator: use LED1, LED2, LED3
1361:Src/util.c    ****     if (main_loop_counter % BAT_BLINK_INTERVAL == 0) {              //  | RED (LED1) | YELLOW (LED3
1362:Src/util.c    ****       if (batVoltage < BAT_DEAD) {                                  //  |     0      |       0     
1363:Src/util.c    ****         *leds &= ~LED1_SET & ~LED3_SET & ~LED2_SET;
1364:Src/util.c    ****       } else if (batVoltage < BAT_LVL1) {                           //  |     B      |       0     
1365:Src/util.c    ****         *leds ^= LED1_SET;
1366:Src/util.c    ****         *leds &= ~LED3_SET & ~LED2_SET;
1367:Src/util.c    ****       } else if (batVoltage < BAT_LVL2) {                           //  |     1      |       0     
1368:Src/util.c    ****         *leds |= LED1_SET;
1369:Src/util.c    ****         *leds &= ~LED3_SET & ~LED2_SET;
1370:Src/util.c    ****       } else if (batVoltage < BAT_LVL3) {                           //  |     0      |       B     
1371:Src/util.c    ****         *leds ^= LED3_SET;
1372:Src/util.c    ****         *leds &= ~LED1_SET & ~LED2_SET;
1373:Src/util.c    ****       } else if (batVoltage < BAT_LVL4) {                           //  |     0      |       1     
1374:Src/util.c    ****         *leds |= LED3_SET;
1375:Src/util.c    ****         *leds &= ~LED1_SET & ~LED2_SET;
1376:Src/util.c    ****       } else if (batVoltage < BAT_LVL5) {                           //  |     0      |       0     
1377:Src/util.c    ****         *leds ^= LED2_SET;
1378:Src/util.c    ****         *leds &= ~LED1_SET & ~LED3_SET;
1379:Src/util.c    ****       } else {                                                      //  |     0      |       0     
1380:Src/util.c    ****         *leds |= LED2_SET;
1381:Src/util.c    ****         *leds &= ~LED1_SET & ~LED3_SET;
1382:Src/util.c    ****       }
1383:Src/util.c    ****     }
1384:Src/util.c    **** 
1385:Src/util.c    ****     // Error handling
1386:Src/util.c    ****     // Critical error:  LED1 on (RED)     + high pitch beep (hadled in main)
1387:Src/util.c    ****     // Soft error:      LED3 on (YELLOW)  + low  pitch beep (hadled in main)
1388:Src/util.c    ****     if (rtY_Left.z_errCode || rtY_Right.z_errCode) {
1389:Src/util.c    ****       *leds |= LED1_SET;
1390:Src/util.c    ****       *leds &= ~LED3_SET & ~LED2_SET;
1391:Src/util.c    ****     }
1392:Src/util.c    ****     if (timeoutFlgADC || timeoutFlgSerial) {
1393:Src/util.c    ****       *leds |= LED3_SET;
1394:Src/util.c    ****       *leds &= ~LED1_SET & ~LED2_SET;
1395:Src/util.c    ****     }
1396:Src/util.c    ****   #endif
1397:Src/util.c    **** }
 1809              		.loc 1 1397 1 view .LVU474
 1810 0000 7047     		bx	lr
 1811              		.cfi_endproc
 1812              	.LFE89:
 1814              		.section	.text.sideboardSensors,"ax",%progbits
 1815              		.align	1
 1816              		.global	sideboardSensors
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 61


 1817              		.syntax unified
 1818              		.thumb
 1819              		.thumb_func
 1821              	sideboardSensors:
 1822              	.LVL108:
 1823              	.LFB90:
1398:Src/util.c    **** 
1399:Src/util.c    **** /*
1400:Src/util.c    ****  * Sideboard Sensor Handling
1401:Src/util.c    ****  * This function manages the sideboards photo sensors.
1402:Src/util.c    ****  * In non-hoverboard variants, the sensors are used as push buttons.
1403:Src/util.c    ****  */
1404:Src/util.c    **** void sideboardSensors(uint8_t sensors) {
 1824              		.loc 1 1404 40 view -0
 1825              		.cfi_startproc
 1826              		@ args = 0, pretend = 0, frame = 0
 1827              		@ frame_needed = 0, uses_anonymous_args = 0
 1828              		@ link register save eliminated.
1405:Src/util.c    ****   #if !defined(VARIANT_HOVERBOARD) && (defined(SIDEBOARD_SERIAL_USART2) || defined(SIDEBOARD_SERIAL
1406:Src/util.c    ****     static uint8_t sensor1_index;                                 // holds the press index number f
1407:Src/util.c    ****     static uint8_t sensor1_prev,  sensor2_prev;
1408:Src/util.c    ****     uint8_t sensor1_trig = 0, sensor2_trig = 0;
1409:Src/util.c    ****     #if defined(SIDEBOARD_SERIAL_USART2)
1410:Src/util.c    ****     uint8_t  sideboardIdx = SIDEBOARD_SERIAL_USART2;
1411:Src/util.c    ****     uint16_t sideboardSns = Sideboard_L.sensors;
1412:Src/util.c    ****     #else
1413:Src/util.c    ****     uint8_t  sideboardIdx = SIDEBOARD_SERIAL_USART3;
1414:Src/util.c    ****     uint16_t sideboardSns = Sideboard_R.sensors;
1415:Src/util.c    ****     #endif
1416:Src/util.c    **** 
1417:Src/util.c    ****     if (inIdx == sideboardIdx) {                                  // Use Sideboard data
1418:Src/util.c    ****       sensor1_index = 2 + ((sideboardSns & SWB_SET) >> 9);        // SWB on RC transmitter is used 
1419:Src/util.c    ****       if (sensor1_index == 2) {                                   // FOC control Type
1420:Src/util.c    ****         sensor1_index = (sideboardSns & SWC_SET) >> 11;           // SWC on RC transmitter is used 
1421:Src/util.c    ****       }
1422:Src/util.c    ****       sensor1_trig  = sensor1_index != sensor1_prev;              // rising or falling edge change 
1423:Src/util.c    ****       if (inIdx != inIdx_prev) {                                  // Force one update at Input idx 
1424:Src/util.c    ****         sensor1_trig  = 1;
1425:Src/util.c    ****       }
1426:Src/util.c    ****       sensor1_prev  = sensor1_index;
1427:Src/util.c    ****     } else {                                                      // Use Optical switches
1428:Src/util.c    ****       sensor1_trig  = (sensors & SENSOR1_SET) && !sensor1_prev;   // rising edge detection
1429:Src/util.c    ****       sensor1_prev  =  sensors & SENSOR1_SET;
1430:Src/util.c    ****     }
1431:Src/util.c    **** 
1432:Src/util.c    ****     // Control MODE and Control Type Handling
1433:Src/util.c    ****     if (sensor1_trig) {
1434:Src/util.c    ****       switch (sensor1_index) {
1435:Src/util.c    ****         case 0:     // FOC VOLTAGE
1436:Src/util.c    ****           rtP_Left.z_ctrlTypSel = rtP_Right.z_ctrlTypSel = FOC_CTRL;
1437:Src/util.c    ****           ctrlModReqRaw         = VLT_MODE;
1438:Src/util.c    ****           break;
1439:Src/util.c    ****         case 1:     // FOC SPEED
1440:Src/util.c    ****           rtP_Left.z_ctrlTypSel = rtP_Right.z_ctrlTypSel = FOC_CTRL;
1441:Src/util.c    ****           ctrlModReqRaw         = SPD_MODE;
1442:Src/util.c    ****           break;
1443:Src/util.c    ****         case 2:     // FOC TORQUE
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 62


1444:Src/util.c    ****           rtP_Left.z_ctrlTypSel = rtP_Right.z_ctrlTypSel = FOC_CTRL;
1445:Src/util.c    ****           ctrlModReqRaw         = TRQ_MODE;
1446:Src/util.c    ****           break;
1447:Src/util.c    ****         case 3:     // SINUSOIDAL
1448:Src/util.c    ****           rtP_Left.z_ctrlTypSel = rtP_Right.z_ctrlTypSel = SIN_CTRL;
1449:Src/util.c    ****           break;
1450:Src/util.c    ****         case 4:     // COMMUTATION
1451:Src/util.c    ****           rtP_Left.z_ctrlTypSel = rtP_Right.z_ctrlTypSel = COM_CTRL;
1452:Src/util.c    ****           break;
1453:Src/util.c    ****       }
1454:Src/util.c    ****       if (inIdx == inIdx_prev) { beepShortMany(sensor1_index + 1, 1); }
1455:Src/util.c    ****       if (++sensor1_index > 4) { sensor1_index = 0; }
1456:Src/util.c    ****     }
1457:Src/util.c    **** 
1458:Src/util.c    ****                                                              // Field Weakening Activation/Deactiva
1459:Src/util.c    ****       static uint8_t  sensor2_index = 1;                          // holds the press index number f
1460:Src/util.c    **** 
1461:Src/util.c    ****       // Override in case the Sideboard control is Active
1462:Src/util.c    ****       if (inIdx == sideboardIdx) {                                // Use Sideboard data
1463:Src/util.c    ****         sensor2_index = (sideboardSns & SWD_SET) >> 13;           // SWD on RC transmitter is used 
1464:Src/util.c    ****         sensor2_trig  = sensor2_index != sensor2_prev;            // rising or falling edge change 
1465:Src/util.c    ****         if (inIdx != inIdx_prev) {                                // Force one update at Input idx 
1466:Src/util.c    ****           sensor2_trig  = 1;
1467:Src/util.c    ****         }
1468:Src/util.c    ****         sensor2_prev  = sensor2_index;
1469:Src/util.c    ****       }else{
1470:Src/util.c    ****         sensor2_trig  = (sensors & SENSOR2_SET) && !sensor2_prev;   // rising edge detection
1471:Src/util.c    ****         sensor2_prev  =  sensors & SENSOR2_SET;
1472:Src/util.c    ****       }
1473:Src/util.c    **** 
1474:Src/util.c    ****       #ifdef CRUISE_CONTROL_SUPPORT                                 // Cruise Control Activation/De
1475:Src/util.c    ****         if (sensor2_trig) {
1476:Src/util.c    ****           cruiseControl(sensor2_trig);
1477:Src/util.c    ****         }
1478:Src/util.c    ****       #else
1479:Src/util.c    ****         if (sensor2_trig) {
1480:Src/util.c    ****           switch (sensor2_index) {
1481:Src/util.c    ****             case 0:     // FW Disabled
1482:Src/util.c    ****               rtP_Left.b_fieldWeakEna  = 0; 
1483:Src/util.c    ****               rtP_Right.b_fieldWeakEna = 0;
1484:Src/util.c    ****               Input_Lim_Init();
1485:Src/util.c    ****               break;
1486:Src/util.c    ****             case 1:     // FW Enabled
1487:Src/util.c    ****               rtP_Left.b_fieldWeakEna  = 1; 
1488:Src/util.c    ****               rtP_Right.b_fieldWeakEna = 1;
1489:Src/util.c    ****               Input_Lim_Init();
1490:Src/util.c    ****               break; 
1491:Src/util.c    ****           }
1492:Src/util.c    ****           if (inIdx == inIdx_prev) { beepShortMany(sensor2_index + 1, 1); }
1493:Src/util.c    ****           if (++sensor2_index > 1) { sensor2_index = 0; }
1494:Src/util.c    ****         }
1495:Src/util.c    ****       #endif  // CRUISE_CONTROL_SUPPORT
1496:Src/util.c    ****   #endif
1497:Src/util.c    **** }
 1829              		.loc 1 1497 1 view .LVU476
 1830 0000 7047     		bx	lr
 1831              		.cfi_endproc
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 63


 1832              	.LFE90:
 1834              		.section	.text.saveConfig,"ax",%progbits
 1835              		.align	1
 1836              		.global	saveConfig
 1837              		.syntax unified
 1838              		.thumb
 1839              		.thumb_func
 1841              	saveConfig:
 1842              	.LFB91:
1498:Src/util.c    **** 
1499:Src/util.c    **** 
1500:Src/util.c    **** 
1501:Src/util.c    **** /* =========================== Poweroff Functions =========================== */
1502:Src/util.c    **** 
1503:Src/util.c    ****  /*
1504:Src/util.c    ****  * Save Configuration to Flash
1505:Src/util.c    ****  * This function makes sure data is not lost after power-off
1506:Src/util.c    ****  */
1507:Src/util.c    **** void saveConfig() {
 1843              		.loc 1 1507 19 view -0
 1844              		.cfi_startproc
 1845              		@ args = 0, pretend = 0, frame = 0
 1846              		@ frame_needed = 0, uses_anonymous_args = 0
 1847 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 1848              	.LCFI14:
 1849              		.cfi_def_cfa_offset 32
 1850              		.cfi_offset 3, -32
 1851              		.cfi_offset 4, -28
 1852              		.cfi_offset 5, -24
 1853              		.cfi_offset 6, -20
 1854              		.cfi_offset 7, -16
 1855              		.cfi_offset 8, -12
 1856              		.cfi_offset 9, -8
 1857              		.cfi_offset 14, -4
1508:Src/util.c    ****   #ifdef VARIANT_TRANSPOTTER
1509:Src/util.c    ****     if (saveValue_valid) {
1510:Src/util.c    ****       HAL_FLASH_Unlock();
1511:Src/util.c    ****       EE_WriteVariable(VirtAddVarTab[0], saveValue);
1512:Src/util.c    ****       HAL_FLASH_Lock();
1513:Src/util.c    ****     }
1514:Src/util.c    ****   #endif
1515:Src/util.c    ****   #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
1516:Src/util.c    ****     if (inp_cal_valid || cur_spd_valid) {
 1858              		.loc 1 1516 5 view .LVU478
 1859              		.loc 1 1516 9 is_stmt 0 view .LVU479
 1860 0004 374B     		ldr	r3, .L133
 1861 0006 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1862              		.loc 1 1516 8 view .LVU480
 1863 0008 13B9     		cbnz	r3, .L128
 1864              		.loc 1 1516 23 discriminator 1 view .LVU481
 1865 000a 374B     		ldr	r3, .L133+4
 1866 000c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1867 000e C3B1     		cbz	r3, .L127
 1868              	.L128:
1517:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
1518:Src/util.c    ****         printf("Saving configuration to EEprom\r\n");
1519:Src/util.c    ****       #endif
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 64


1520:Src/util.c    **** 
1521:Src/util.c    ****       HAL_FLASH_Unlock();
 1869              		.loc 1 1521 7 is_stmt 1 view .LVU482
 1870 0010 FFF7FEFF 		bl	HAL_FLASH_Unlock
 1871              	.LVL109:
1522:Src/util.c    ****       EE_WriteVariable(VirtAddVarTab[0] , (uint16_t)FLASH_WRITE_KEY);
 1872              		.loc 1 1522 7 view .LVU483
 1873 0014 354C     		ldr	r4, .L133+8
 1874 0016 41F20201 		movw	r1, #4098
 1875 001a 2088     		ldrh	r0, [r4]
 1876 001c FFF7FEFF 		bl	EE_WriteVariable
 1877              	.LVL110:
1523:Src/util.c    ****       EE_WriteVariable(VirtAddVarTab[1] , (uint16_t)rtP_Left.i_max);
 1878              		.loc 1 1523 7 view .LVU484
 1879              		.loc 1 1523 61 is_stmt 0 view .LVU485
 1880 0020 334D     		ldr	r5, .L133+12
 1881 0022 B5F9CE10 		ldrsh	r1, [r5, #206]
 1882              		.loc 1 1523 7 view .LVU486
 1883 0026 89B2     		uxth	r1, r1
 1884 0028 6088     		ldrh	r0, [r4, #2]
 1885 002a FFF7FEFF 		bl	EE_WriteVariable
 1886              	.LVL111:
1524:Src/util.c    ****       EE_WriteVariable(VirtAddVarTab[2] , (uint16_t)rtP_Left.n_max);
 1887              		.loc 1 1524 7 is_stmt 1 view .LVU487
 1888              		.loc 1 1524 61 is_stmt 0 view .LVU488
 1889 002e B5F9DA10 		ldrsh	r1, [r5, #218]
 1890              		.loc 1 1524 7 view .LVU489
 1891 0032 89B2     		uxth	r1, r1
 1892 0034 A088     		ldrh	r0, [r4, #4]
 1893 0036 FFF7FEFF 		bl	EE_WriteVariable
 1894              	.LVL112:
1525:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 1895              		.loc 1 1525 7 is_stmt 1 view .LVU490
 1896              	.LBB9:
 1897              		.loc 1 1525 12 view .LVU491
 1898              		.loc 1 1525 20 is_stmt 0 view .LVU492
 1899 003a 0025     		movs	r5, #0
 1900              	.LVL113:
 1901              	.L130:
 1902              		.loc 1 1525 25 is_stmt 1 discriminator 1 view .LVU493
 1903              		.loc 1 1525 7 is_stmt 0 discriminator 1 view .LVU494
 1904 003c 1DB1     		cbz	r5, .L131
 1905              	.LBE9:
1526:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
1527:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 4+8*i] , (uint16_t)input1[i].min);
1528:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 5+8*i] , (uint16_t)input1[i].mid);
1529:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 6+8*i] , (uint16_t)input1[i].max);
1530:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 7+8*i] , (uint16_t)input2[i].typ);
1531:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 8+8*i] , (uint16_t)input2[i].min);
1532:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 9+8*i] , (uint16_t)input2[i].mid);
1533:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[10+8*i] , (uint16_t)input2[i].max);
1534:Src/util.c    ****       }
1535:Src/util.c    ****       HAL_FLASH_Lock();
 1906              		.loc 1 1535 7 is_stmt 1 view .LVU495
 1907 003e FFF7FEFF 		bl	HAL_FLASH_Lock
 1908              	.LVL114:
 1909              	.L127:
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 65


1536:Src/util.c    ****     }
1537:Src/util.c    ****   #endif 
1538:Src/util.c    **** }
 1910              		.loc 1 1538 1 is_stmt 0 view .LVU496
 1911 0042 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 1912              	.LVL115:
 1913              	.L131:
 1914              	.LBB10:
1526:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 1915              		.loc 1 1526 9 is_stmt 1 discriminator 3 view .LVU497
1526:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 1916              		.loc 1 1526 44 is_stmt 0 discriminator 3 view .LVU498
 1917 0046 EC00     		lsls	r4, r5, #3
1526:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 1918              		.loc 1 1526 42 discriminator 3 view .LVU499
 1919 0048 E01C     		adds	r0, r4, #3
1526:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 1920              		.loc 1 1526 69 discriminator 3 view .LVU500
 1921 004a 621B     		subs	r2, r4, r5
 1922 004c 5300     		lsls	r3, r2, #1
 1923 004e 294F     		ldr	r7, .L133+16
 1924 0050 1F44     		add	r7, r7, r3
1526:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 1925              		.loc 1 1526 9 discriminator 3 view .LVU501
 1926 0052 264E     		ldr	r6, .L133+8
 1927 0054 3979     		ldrb	r1, [r7, #4]	@ zero_extendqisi2
 1928 0056 36F81000 		ldrh	r0, [r6, r0, lsl #1]
 1929 005a FFF7FEFF 		bl	EE_WriteVariable
 1930              	.LVL116:
1527:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 5+8*i] , (uint16_t)input1[i].mid);
 1931              		.loc 1 1527 9 is_stmt 1 discriminator 3 view .LVU502
1527:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 5+8*i] , (uint16_t)input1[i].mid);
 1932              		.loc 1 1527 42 is_stmt 0 discriminator 3 view .LVU503
 1933 005e 231D     		adds	r3, r4, #4
1527:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 5+8*i] , (uint16_t)input1[i].mid);
 1934              		.loc 1 1527 69 discriminator 3 view .LVU504
 1935 0060 B7F90610 		ldrsh	r1, [r7, #6]
1527:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 5+8*i] , (uint16_t)input1[i].mid);
 1936              		.loc 1 1527 9 discriminator 3 view .LVU505
 1937 0064 89B2     		uxth	r1, r1
 1938 0066 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 1939 006a FFF7FEFF 		bl	EE_WriteVariable
 1940              	.LVL117:
1528:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 6+8*i] , (uint16_t)input1[i].max);
 1941              		.loc 1 1528 9 is_stmt 1 discriminator 3 view .LVU506
1528:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 6+8*i] , (uint16_t)input1[i].max);
 1942              		.loc 1 1528 42 is_stmt 0 discriminator 3 view .LVU507
 1943 006e 631D     		adds	r3, r4, #5
1528:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 6+8*i] , (uint16_t)input1[i].max);
 1944              		.loc 1 1528 69 discriminator 3 view .LVU508
 1945 0070 B7F90810 		ldrsh	r1, [r7, #8]
1528:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 6+8*i] , (uint16_t)input1[i].max);
 1946              		.loc 1 1528 9 discriminator 3 view .LVU509
 1947 0074 89B2     		uxth	r1, r1
 1948 0076 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 1949 007a FFF7FEFF 		bl	EE_WriteVariable
 1950              	.LVL118:
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 66


1529:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 7+8*i] , (uint16_t)input2[i].typ);
 1951              		.loc 1 1529 9 is_stmt 1 discriminator 3 view .LVU510
1529:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 7+8*i] , (uint16_t)input2[i].typ);
 1952              		.loc 1 1529 42 is_stmt 0 discriminator 3 view .LVU511
 1953 007e A31D     		adds	r3, r4, #6
1529:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 7+8*i] , (uint16_t)input2[i].typ);
 1954              		.loc 1 1529 69 discriminator 3 view .LVU512
 1955 0080 B7F90A10 		ldrsh	r1, [r7, #10]
1529:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 7+8*i] , (uint16_t)input2[i].typ);
 1956              		.loc 1 1529 9 discriminator 3 view .LVU513
 1957 0084 89B2     		uxth	r1, r1
 1958 0086 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 1959 008a FFF7FEFF 		bl	EE_WriteVariable
 1960              	.LVL119:
1530:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 8+8*i] , (uint16_t)input2[i].min);
 1961              		.loc 1 1530 9 is_stmt 1 discriminator 3 view .LVU514
1530:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 8+8*i] , (uint16_t)input2[i].min);
 1962              		.loc 1 1530 42 is_stmt 0 discriminator 3 view .LVU515
 1963 008e E21D     		adds	r2, r4, #7
1530:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 8+8*i] , (uint16_t)input2[i].min);
 1964              		.loc 1 1530 69 discriminator 3 view .LVU516
 1965 0090 DFF86480 		ldr	r8, .L133+20
 1966 0094 631B     		subs	r3, r4, r5
 1967 0096 5F00     		lsls	r7, r3, #1
 1968 0098 4744     		add	r7, r7, r8
1530:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 8+8*i] , (uint16_t)input2[i].min);
 1969              		.loc 1 1530 9 discriminator 3 view .LVU517
 1970 009a 3979     		ldrb	r1, [r7, #4]	@ zero_extendqisi2
 1971 009c 36F81200 		ldrh	r0, [r6, r2, lsl #1]
 1972 00a0 FFF7FEFF 		bl	EE_WriteVariable
 1973              	.LVL120:
1531:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 9+8*i] , (uint16_t)input2[i].mid);
 1974              		.loc 1 1531 9 is_stmt 1 discriminator 3 view .LVU518
1531:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 9+8*i] , (uint16_t)input2[i].mid);
 1975              		.loc 1 1531 42 is_stmt 0 discriminator 3 view .LVU519
 1976 00a4 05F10109 		add	r9, r5, #1
 1977 00a8 4FEAC903 		lsl	r3, r9, #3
1531:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 9+8*i] , (uint16_t)input2[i].mid);
 1978              		.loc 1 1531 69 discriminator 3 view .LVU520
 1979 00ac B7F90610 		ldrsh	r1, [r7, #6]
1531:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 9+8*i] , (uint16_t)input2[i].mid);
 1980              		.loc 1 1531 9 discriminator 3 view .LVU521
 1981 00b0 89B2     		uxth	r1, r1
 1982 00b2 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 1983 00b6 FFF7FEFF 		bl	EE_WriteVariable
 1984              	.LVL121:
1532:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[10+8*i] , (uint16_t)input2[i].max);
 1985              		.loc 1 1532 9 is_stmt 1 discriminator 3 view .LVU522
1532:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[10+8*i] , (uint16_t)input2[i].max);
 1986              		.loc 1 1532 42 is_stmt 0 discriminator 3 view .LVU523
 1987 00ba 04F10903 		add	r3, r4, #9
1532:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[10+8*i] , (uint16_t)input2[i].max);
 1988              		.loc 1 1532 69 discriminator 3 view .LVU524
 1989 00be B7F90810 		ldrsh	r1, [r7, #8]
1532:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[10+8*i] , (uint16_t)input2[i].max);
 1990              		.loc 1 1532 9 discriminator 3 view .LVU525
 1991 00c2 89B2     		uxth	r1, r1
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 67


 1992 00c4 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 1993 00c8 FFF7FEFF 		bl	EE_WriteVariable
 1994              	.LVL122:
1533:Src/util.c    ****       }
 1995              		.loc 1 1533 9 is_stmt 1 discriminator 3 view .LVU526
1533:Src/util.c    ****       }
 1996              		.loc 1 1533 42 is_stmt 0 discriminator 3 view .LVU527
 1997 00cc 04F10A02 		add	r2, r4, #10
1533:Src/util.c    ****       }
 1998              		.loc 1 1533 69 discriminator 3 view .LVU528
 1999 00d0 B7F90A10 		ldrsh	r1, [r7, #10]
1533:Src/util.c    ****       }
 2000              		.loc 1 1533 9 discriminator 3 view .LVU529
 2001 00d4 89B2     		uxth	r1, r1
 2002 00d6 36F81200 		ldrh	r0, [r6, r2, lsl #1]
 2003 00da FFF7FEFF 		bl	EE_WriteVariable
 2004              	.LVL123:
1525:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 2005              		.loc 1 1525 38 is_stmt 1 discriminator 3 view .LVU530
1525:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 2006              		.loc 1 1525 39 is_stmt 0 discriminator 3 view .LVU531
 2007 00de 5FFA89F5 		uxtb	r5, r9
 2008              	.LVL124:
1525:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 2009              		.loc 1 1525 39 discriminator 3 view .LVU532
 2010 00e2 ABE7     		b	.L130
 2011              	.L134:
 2012              		.align	2
 2013              	.L133:
 2014 00e4 00000000 		.word	.LANCHOR28
 2015 00e8 00000000 		.word	.LANCHOR29
 2016 00ec 00000000 		.word	.LANCHOR14
 2017 00f0 00000000 		.word	rtP_Left
 2018 00f4 00000000 		.word	.LANCHOR15
 2019 00f8 00000000 		.word	.LANCHOR16
 2020              	.LBE10:
 2021              		.cfi_endproc
 2022              	.LFE91:
 2024              		.section	.text.poweroff,"ax",%progbits
 2025              		.align	1
 2026              		.global	poweroff
 2027              		.syntax unified
 2028              		.thumb
 2029              		.thumb_func
 2031              	poweroff:
 2032              	.LFB92:
1539:Src/util.c    **** 
1540:Src/util.c    **** 
1541:Src/util.c    **** void poweroff(void) {
 2033              		.loc 1 1541 21 is_stmt 1 view -0
 2034              		.cfi_startproc
 2035              		@ args = 0, pretend = 0, frame = 0
 2036              		@ frame_needed = 0, uses_anonymous_args = 0
 2037 0000 10B5     		push	{r4, lr}
 2038              	.LCFI15:
 2039              		.cfi_def_cfa_offset 8
 2040              		.cfi_offset 4, -8
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 68


 2041              		.cfi_offset 14, -4
1542:Src/util.c    ****   enable = 0;
 2042              		.loc 1 1542 3 view .LVU534
 2043              		.loc 1 1542 10 is_stmt 0 view .LVU535
 2044 0002 0024     		movs	r4, #0
 2045 0004 0B4B     		ldr	r3, .L140
 2046 0006 1C70     		strb	r4, [r3]
1543:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
1544:Src/util.c    ****   printf("-- Motors disabled --\r\n");
1545:Src/util.c    ****   #endif
1546:Src/util.c    ****   buzzerCount = 0;  // prevent interraction with beep counter
 2047              		.loc 1 1546 3 is_stmt 1 view .LVU536
 2048              		.loc 1 1546 15 is_stmt 0 view .LVU537
 2049 0008 0B4B     		ldr	r3, .L140+4
 2050 000a 1C70     		strb	r4, [r3]
1547:Src/util.c    ****   buzzerPattern = 0;
 2051              		.loc 1 1547 3 is_stmt 1 view .LVU538
 2052              		.loc 1 1547 17 is_stmt 0 view .LVU539
 2053 000c 0B4B     		ldr	r3, .L140+8
 2054 000e 1C70     		strb	r4, [r3]
1548:Src/util.c    ****   for (int i = 0; i < 8; i++) {
 2055              		.loc 1 1548 3 is_stmt 1 view .LVU540
 2056              	.LBB11:
 2057              		.loc 1 1548 8 view .LVU541
 2058              	.LVL125:
 2059              		.loc 1 1548 3 is_stmt 0 view .LVU542
 2060 0010 05E0     		b	.L136
 2061              	.LVL126:
 2062              	.L137:
1549:Src/util.c    ****     buzzerFreq = (uint8_t)i;
 2063              		.loc 1 1549 5 is_stmt 1 discriminator 3 view .LVU543
 2064              		.loc 1 1549 16 is_stmt 0 discriminator 3 view .LVU544
 2065 0012 0B4B     		ldr	r3, .L140+12
 2066 0014 1C70     		strb	r4, [r3]
1550:Src/util.c    ****     HAL_Delay(100);
 2067              		.loc 1 1550 5 is_stmt 1 discriminator 3 view .LVU545
 2068 0016 6420     		movs	r0, #100
 2069 0018 FFF7FEFF 		bl	HAL_Delay
 2070              	.LVL127:
1548:Src/util.c    ****   for (int i = 0; i < 8; i++) {
 2071              		.loc 1 1548 26 discriminator 3 view .LVU546
1548:Src/util.c    ****   for (int i = 0; i < 8; i++) {
 2072              		.loc 1 1548 27 is_stmt 0 discriminator 3 view .LVU547
 2073 001c 0134     		adds	r4, r4, #1
 2074              	.LVL128:
 2075              	.L136:
1548:Src/util.c    ****   for (int i = 0; i < 8; i++) {
 2076              		.loc 1 1548 19 is_stmt 1 discriminator 1 view .LVU548
1548:Src/util.c    ****   for (int i = 0; i < 8; i++) {
 2077              		.loc 1 1548 3 is_stmt 0 discriminator 1 view .LVU549
 2078 001e 072C     		cmp	r4, #7
 2079 0020 F7DD     		ble	.L137
 2080              	.LBE11:
1551:Src/util.c    ****   }
1552:Src/util.c    ****   saveConfig();
 2081              		.loc 1 1552 3 is_stmt 1 view .LVU550
 2082 0022 FFF7FEFF 		bl	saveConfig
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 69


 2083              	.LVL129:
1553:Src/util.c    ****   HAL_GPIO_WritePin(OFF_PORT, OFF_PIN, GPIO_PIN_RESET);
 2084              		.loc 1 1553 3 view .LVU551
 2085 0026 0022     		movs	r2, #0
 2086 0028 2021     		movs	r1, #32
 2087 002a 0648     		ldr	r0, .L140+16
 2088 002c FFF7FEFF 		bl	HAL_GPIO_WritePin
 2089              	.LVL130:
 2090              	.L138:
1554:Src/util.c    ****   while(1) {}
 2091              		.loc 1 1554 3 discriminator 1 view .LVU552
 2092              		.loc 1 1554 13 discriminator 1 view .LVU553
 2093              		.loc 1 1554 8 discriminator 1 view .LVU554
 2094 0030 FEE7     		b	.L138
 2095              	.L141:
 2096 0032 00BF     		.align	2
 2097              	.L140:
 2098 0034 00000000 		.word	enable
 2099 0038 00000000 		.word	buzzerCount
 2100 003c 00000000 		.word	buzzerPattern
 2101 0040 00000000 		.word	buzzerFreq
 2102 0044 00080140 		.word	1073809408
 2103              		.cfi_endproc
 2104              	.LFE92:
 2106              		.section	.text.filtLowPass32,"ax",%progbits
 2107              		.align	1
 2108              		.global	filtLowPass32
 2109              		.syntax unified
 2110              		.thumb
 2111              		.thumb_func
 2113              	filtLowPass32:
 2114              	.LVL131:
 2115              	.LFB94:
1555:Src/util.c    **** }
1556:Src/util.c    **** 
1557:Src/util.c    **** 
1558:Src/util.c    **** void poweroffPressCheck(void) {
1559:Src/util.c    ****   #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
1560:Src/util.c    ****     if(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
1561:Src/util.c    ****       uint16_t cnt_press = 0;
1562:Src/util.c    ****       while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
1563:Src/util.c    ****         HAL_Delay(10);
1564:Src/util.c    ****         if (cnt_press++ == 5 * 100) { beepShort(5); }
1565:Src/util.c    ****       }
1566:Src/util.c    **** 
1567:Src/util.c    ****       if (cnt_press > 8) enable = 0;
1568:Src/util.c    **** 
1569:Src/util.c    ****       if (cnt_press >= 5 * 100) {                         // Check if press is more than 5 sec
1570:Src/util.c    ****         HAL_Delay(1000);
1571:Src/util.c    ****         if (HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {  // Double press: Adjust Max Current, Max 
1572:Src/util.c    ****           while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
1573:Src/util.c    ****           beepLong(8);
1574:Src/util.c    ****           updateCurSpdLim();
1575:Src/util.c    ****           beepShort(5);
1576:Src/util.c    ****         } else {                                          // Long press: Calibrate ADC Limits
1577:Src/util.c    ****           #ifdef AUTO_CALIBRATION_ENA
1578:Src/util.c    ****           beepLong(16); 
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 70


1579:Src/util.c    ****           adcCalibLim();
1580:Src/util.c    ****           beepShort(5);
1581:Src/util.c    ****           #endif
1582:Src/util.c    ****         }
1583:Src/util.c    ****       } else if (cnt_press > 8) {                         // Short press: power off (80 ms debounce
1584:Src/util.c    ****         #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
1585:Src/util.c    ****           printf("Powering off, button has been pressed\r\n");
1586:Src/util.c    ****         #endif
1587:Src/util.c    ****       poweroff();
1588:Src/util.c    ****       }
1589:Src/util.c    ****     }
1590:Src/util.c    ****   #elif defined(VARIANT_TRANSPOTTER)
1591:Src/util.c    ****     if(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
1592:Src/util.c    ****       enable = 0;
1593:Src/util.c    ****       while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
1594:Src/util.c    ****       beepShort(5);
1595:Src/util.c    ****       HAL_Delay(300);
1596:Src/util.c    ****       if (HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
1597:Src/util.c    ****         while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
1598:Src/util.c    ****         beepLong(5);
1599:Src/util.c    ****         HAL_Delay(350);
1600:Src/util.c    ****         poweroff();
1601:Src/util.c    ****       } else {
1602:Src/util.c    ****         setDistance += 0.25;
1603:Src/util.c    ****         if (setDistance > 2.6) {
1604:Src/util.c    ****           setDistance = 0.5;
1605:Src/util.c    ****         }
1606:Src/util.c    ****         beepShort(setDistance / 0.25);
1607:Src/util.c    ****         saveValue = setDistance * 1000;
1608:Src/util.c    ****         saveValue_valid = 1;
1609:Src/util.c    ****       }
1610:Src/util.c    ****     }
1611:Src/util.c    ****   #else
1612:Src/util.c    ****     if (HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
1613:Src/util.c    ****       enable = 0;                                             // disable motors
1614:Src/util.c    ****       while (HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {}    // wait until button is released
1615:Src/util.c    ****       poweroff();                                             // release power-latch
1616:Src/util.c    ****     }
1617:Src/util.c    ****   #endif
1618:Src/util.c    **** }
1619:Src/util.c    **** 
1620:Src/util.c    **** 
1621:Src/util.c    **** 
1622:Src/util.c    **** /* =========================== Filtering Functions =========================== */
1623:Src/util.c    **** 
1624:Src/util.c    ****   /* Low pass filter fixed-point 32 bits: fixdt(1,32,16)
1625:Src/util.c    ****   * Max:  32767.99998474121
1626:Src/util.c    ****   * Min: -32768
1627:Src/util.c    ****   * Res:  1.52587890625e-05
1628:Src/util.c    ****   * 
1629:Src/util.c    ****   * Inputs:       u     = int16 or int32
1630:Src/util.c    ****   * Outputs:      y     = fixdt(1,32,16)
1631:Src/util.c    ****   * Parameters:   coef  = fixdt(0,16,16) = [0,65535U]
1632:Src/util.c    ****   * 
1633:Src/util.c    ****   * Example: 
1634:Src/util.c    ****   * If coef = 0.8 (in floating point), then coef = 0.8 * 2^16 = 52429 (in fixed-point)
1635:Src/util.c    ****   * filtLowPass16(u, 52429, &y);
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 71


1636:Src/util.c    ****   * yint = (int16_t)(y >> 16); // the integer output is the fixed-point ouput shifted by 16 bits
1637:Src/util.c    ****   */
1638:Src/util.c    **** void filtLowPass32(int32_t u, uint16_t coef, int32_t *y) {
 2116              		.loc 1 1638 58 view -0
 2117              		.cfi_startproc
 2118              		@ args = 0, pretend = 0, frame = 0
 2119              		@ frame_needed = 0, uses_anonymous_args = 0
 2120              		@ link register save eliminated.
 2121              		.loc 1 1638 58 is_stmt 0 view .LVU556
 2122 0000 10B4     		push	{r4}
 2123              	.LCFI16:
 2124              		.cfi_def_cfa_offset 4
 2125              		.cfi_offset 4, -4
1639:Src/util.c    ****   int64_t tmp;  
 2126              		.loc 1 1639 3 is_stmt 1 view .LVU557
1640:Src/util.c    ****   tmp = ((int64_t)((u << 4) - (*y >> 12)) * coef) >> 4;
 2127              		.loc 1 1640 3 view .LVU558
 2128              		.loc 1 1640 32 is_stmt 0 view .LVU559
 2129 0002 1468     		ldr	r4, [r2]
 2130              		.loc 1 1640 35 view .LVU560
 2131 0004 2313     		asrs	r3, r4, #12
 2132              		.loc 1 1640 29 view .LVU561
 2133 0006 C3EB0010 		rsb	r0, r3, r0, lsl #4
 2134              	.LVL132:
 2135              		.loc 1 1640 10 view .LVU562
 2136 000a 4FEAE07C 		asr	ip, r0, #31
 2137              		.loc 1 1640 43 view .LVU563
 2138 000e A1FB0003 		umull	r0, r3, r1, r0
 2139 0012 01FB0C31 		mla	r1, r1, ip, r3
 2140              	.LVL133:
 2141              		.loc 1 1640 7 view .LVU564
 2142 0016 0009     		lsrs	r0, r0, #4
 2143 0018 40EA0170 		orr	r0, r0, r1, lsl #28
 2144 001c 0911     		asrs	r1, r1, #4
 2145              	.LVL134:
1641:Src/util.c    ****   tmp = CLAMP(tmp, -2147483648LL, 2147483647LL);  // Overflow protection: 2147483647LL = 2^31 - 1
 2146              		.loc 1 1641 3 is_stmt 1 view .LVU565
 2147              		.loc 1 1641 9 is_stmt 0 view .LVU566
 2148 001e B0F1004F 		cmp	r0, #-2147483648
 2149 0022 71F10003 		sbcs	r3, r1, #0
 2150 0026 08DA     		bge	.L145
 2151              		.loc 1 1641 9 discriminator 1 view .LVU567
 2152 0028 0346     		mov	r3, r0
 2153 002a B0F1004F 		cmp	r0, #-2147483648
 2154 002e 71F1FF31 		sbcs	r1, r1, #-1
 2155              	.LVL135:
 2156              		.loc 1 1641 9 discriminator 1 view .LVU568
 2157 0032 04DA     		bge	.L143
 2158 0034 4FF00043 		mov	r3, #-2147483648
 2159 0038 01E0     		b	.L143
 2160              	.LVL136:
 2161              	.L145:
 2162              		.loc 1 1641 9 view .LVU569
 2163 003a 6FF00043 		mvn	r3, #-2147483648
 2164              	.LVL137:
 2165              	.L143:
1642:Src/util.c    ****   *y = (int32_t)tmp + (*y);
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 72


 2166              		.loc 1 1642 3 is_stmt 1 discriminator 4 view .LVU570
 2167              		.loc 1 1642 21 is_stmt 0 discriminator 4 view .LVU571
 2168 003e 1C44     		add	r4, r4, r3
 2169              		.loc 1 1642 6 discriminator 4 view .LVU572
 2170 0040 1460     		str	r4, [r2]
1643:Src/util.c    **** }
 2171              		.loc 1 1643 1 discriminator 4 view .LVU573
 2172 0042 10BC     		pop	{r4}
 2173              	.LCFI17:
 2174              		.cfi_restore 4
 2175              		.cfi_def_cfa_offset 0
 2176 0044 7047     		bx	lr
 2177              		.cfi_endproc
 2178              	.LFE94:
 2180              		.section	.text.adcCalibLim,"ax",%progbits
 2181              		.align	1
 2182              		.global	adcCalibLim
 2183              		.syntax unified
 2184              		.thumb
 2185              		.thumb_func
 2187              	adcCalibLim:
 2188              	.LFB76:
 500:Src/util.c    **** #ifdef AUTO_CALIBRATION_ENA
 2189              		.loc 1 500 24 is_stmt 1 view -0
 2190              		.cfi_startproc
 2191              		@ args = 0, pretend = 0, frame = 8
 2192              		@ frame_needed = 0, uses_anonymous_args = 0
 2193 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 2194              	.LCFI18:
 2195              		.cfi_def_cfa_offset 36
 2196              		.cfi_offset 4, -36
 2197              		.cfi_offset 5, -32
 2198              		.cfi_offset 6, -28
 2199              		.cfi_offset 7, -24
 2200              		.cfi_offset 8, -20
 2201              		.cfi_offset 9, -16
 2202              		.cfi_offset 10, -12
 2203              		.cfi_offset 11, -8
 2204              		.cfi_offset 14, -4
 2205 0004 83B0     		sub	sp, sp, #12
 2206              	.LCFI19:
 2207              		.cfi_def_cfa_offset 48
 502:Src/util.c    ****   if (speedAvgAbs > 5) {    // do not enter this mode if motors are spinning
 2208              		.loc 1 502 3 view .LVU575
 2209 0006 FFF7FEFF 		bl	calcAvgSpeed
 2210              	.LVL138:
 503:Src/util.c    ****     return;
 2211              		.loc 1 503 3 view .LVU576
 503:Src/util.c    ****     return;
 2212              		.loc 1 503 19 is_stmt 0 view .LVU577
 2213 000a 514B     		ldr	r3, .L161
 2214 000c B3F90030 		ldrsh	r3, [r3]
 503:Src/util.c    ****     return;
 2215              		.loc 1 503 6 view .LVU578
 2216 0010 052B     		cmp	r3, #5
 2217 0012 02DD     		ble	.L160
 2218              	.L147:
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 73


 604:Src/util.c    ****  /*
 2219              		.loc 1 604 1 view .LVU579
 2220 0014 03B0     		add	sp, sp, #12
 2221              	.LCFI20:
 2222              		.cfi_remember_state
 2223              		.cfi_def_cfa_offset 36
 2224              		@ sp needed
 2225 0016 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2226              	.L160:
 2227              	.LCFI21:
 2228              		.cfi_restore_state
 513:Src/util.c    ****   // Inititalization: MIN = a high value, MAX = a low value
 2229              		.loc 1 513 3 is_stmt 1 view .LVU580
 2230 001a FFF7FEFF 		bl	readInputRaw
 2231              	.LVL139:
 515:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2232              		.loc 1 515 3 view .LVU581
 515:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2233              		.loc 1 515 40 is_stmt 0 view .LVU582
 2234 001e 4D4B     		ldr	r3, .L161+4
 2235 0020 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2236 0022 C3EBC301 		rsb	r1, r3, r3, lsl #3
 2237 0026 4C4A     		ldr	r2, .L161+8
 2238 0028 32F91120 		ldrsh	r2, [r2, r1, lsl #1]
 515:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2239              		.loc 1 515 45 view .LVU583
 2240 002c 1204     		lsls	r2, r2, #16
 515:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2241              		.loc 1 515 12 view .LVU584
 2242 002e 0192     		str	r2, [sp, #4]
 516:Src/util.c    ****   int16_t  INPUT1_MIN_temp = MAX_int16_T;
 2243              		.loc 1 516 3 is_stmt 1 view .LVU585
 516:Src/util.c    ****   int16_t  INPUT1_MIN_temp = MAX_int16_T;
 2244              		.loc 1 516 40 is_stmt 0 view .LVU586
 2245 0030 4A4A     		ldr	r2, .L161+12
 2246 0032 32F91130 		ldrsh	r3, [r2, r1, lsl #1]
 516:Src/util.c    ****   int16_t  INPUT1_MIN_temp = MAX_int16_T;
 2247              		.loc 1 516 45 view .LVU587
 2248 0036 1B04     		lsls	r3, r3, #16
 516:Src/util.c    ****   int16_t  INPUT1_MIN_temp = MAX_int16_T;
 2249              		.loc 1 516 12 view .LVU588
 2250 0038 0093     		str	r3, [sp]
 517:Src/util.c    ****   int16_t  INPUT1_MID_temp = 0;
 2251              		.loc 1 517 3 is_stmt 1 view .LVU589
 2252              	.LVL140:
 518:Src/util.c    ****   int16_t  INPUT1_MAX_temp = MIN_int16_T;
 2253              		.loc 1 518 3 view .LVU590
 519:Src/util.c    ****   int16_t  INPUT2_MIN_temp = MAX_int16_T;
 2254              		.loc 1 519 3 view .LVU591
 520:Src/util.c    ****   int16_t  INPUT2_MID_temp = 0;
 2255              		.loc 1 520 3 view .LVU592
 521:Src/util.c    ****   int16_t  INPUT2_MAX_temp = MIN_int16_T;
 2256              		.loc 1 521 3 view .LVU593
 522:Src/util.c    ****   int16_t  input_margin    = 0;
 2257              		.loc 1 522 3 view .LVU594
 523:Src/util.c    ****   uint16_t input_cal_timeout = 0;
 2258              		.loc 1 523 3 view .LVU595
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 74


 524:Src/util.c    ****   
 2259              		.loc 1 524 3 view .LVU596
 533:Src/util.c    ****     readInputRaw();
 2260              		.loc 1 533 3 view .LVU597
 524:Src/util.c    ****   
 2261              		.loc 1 524 12 is_stmt 0 view .LVU598
 2262 003a 4FF00009 		mov	r9, #0
 522:Src/util.c    ****   int16_t  input_margin    = 0;
 2263              		.loc 1 522 12 view .LVU599
 2264 003e 484D     		ldr	r5, .L161+16
 521:Src/util.c    ****   int16_t  INPUT2_MAX_temp = MIN_int16_T;
 2265              		.loc 1 521 12 view .LVU600
 2266 0040 CA46     		mov	r10, r9
 520:Src/util.c    ****   int16_t  INPUT2_MID_temp = 0;
 2267              		.loc 1 520 12 view .LVU601
 2268 0042 47F6FF76 		movw	r6, #32767
 519:Src/util.c    ****   int16_t  INPUT2_MIN_temp = MAX_int16_T;
 2269              		.loc 1 519 12 view .LVU602
 2270 0046 2F46     		mov	r7, r5
 518:Src/util.c    ****   int16_t  INPUT1_MAX_temp = MIN_int16_T;
 2271              		.loc 1 518 12 view .LVU603
 2272 0048 CB46     		mov	fp, r9
 517:Src/util.c    ****   int16_t  INPUT1_MID_temp = 0;
 2273              		.loc 1 517 12 view .LVU604
 2274 004a B046     		mov	r8, r6
 533:Src/util.c    ****     readInputRaw();
 2275              		.loc 1 533 9 view .LVU605
 2276 004c 2FE0     		b	.L150
 2277              	.LVL141:
 2278              	.L152:
 534:Src/util.c    ****     filtLowPass32(input1[inIdx].raw, FILTER, &input1_fixdt);
 2279              		.loc 1 534 5 is_stmt 1 view .LVU606
 2280 004e FFF7FEFF 		bl	readInputRaw
 2281              	.LVL142:
 535:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 2282              		.loc 1 535 5 view .LVU607
 535:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 2283              		.loc 1 535 32 is_stmt 0 view .LVU608
 2284 0052 DFF80091 		ldr	r9, .L161+4
 2285 0056 99F80030 		ldrb	r3, [r9]	@ zero_extendqisi2
 2286 005a C3EBC303 		rsb	r3, r3, r3, lsl #3
 535:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 2287              		.loc 1 535 5 view .LVU609
 2288 005e 01AA     		add	r2, sp, #4
 2289 0060 41F69911 		movw	r1, #6553
 2290 0064 3C48     		ldr	r0, .L161+8
 2291 0066 30F91300 		ldrsh	r0, [r0, r3, lsl #1]
 2292 006a FFF7FEFF 		bl	filtLowPass32
 2293              	.LVL143:
 536:Src/util.c    ****     
 2294              		.loc 1 536 5 is_stmt 1 view .LVU610
 536:Src/util.c    ****     
 2295              		.loc 1 536 32 is_stmt 0 view .LVU611
 2296 006e 99F80030 		ldrb	r3, [r9]	@ zero_extendqisi2
 2297 0072 C3EBC303 		rsb	r3, r3, r3, lsl #3
 536:Src/util.c    ****     
 2298              		.loc 1 536 5 view .LVU612
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 75


 2299 0076 6A46     		mov	r2, sp
 2300 0078 41F69911 		movw	r1, #6553
 2301 007c 3748     		ldr	r0, .L161+12
 2302 007e 30F91300 		ldrsh	r0, [r0, r3, lsl #1]
 2303 0082 FFF7FEFF 		bl	filtLowPass32
 2304              	.LVL144:
 538:Src/util.c    ****     INPUT2_MID_temp = (int16_t)(input2_fixdt >> 16);// CLAMP(input2_fixdt >> 16, INPUT2_MIN, INPUT2
 2305              		.loc 1 538 5 is_stmt 1 view .LVU613
 538:Src/util.c    ****     INPUT2_MID_temp = (int16_t)(input2_fixdt >> 16);// CLAMP(input2_fixdt >> 16, INPUT2_MIN, INPUT2
 2306              		.loc 1 538 21 is_stmt 0 view .LVU614
 2307 0086 BDF906B0 		ldrsh	fp, [sp, #6]
 2308              	.LVL145:
 539:Src/util.c    ****     INPUT1_MIN_temp = MIN(INPUT1_MIN_temp, INPUT1_MID_temp);
 2309              		.loc 1 539 5 is_stmt 1 view .LVU615
 539:Src/util.c    ****     INPUT1_MIN_temp = MIN(INPUT1_MIN_temp, INPUT1_MID_temp);
 2310              		.loc 1 539 21 is_stmt 0 view .LVU616
 2311 008a BDF902A0 		ldrsh	r10, [sp, #2]
 2312              	.LVL146:
 540:Src/util.c    ****     INPUT1_MAX_temp = MAX(INPUT1_MAX_temp, INPUT1_MID_temp);
 2313              		.loc 1 540 5 is_stmt 1 view .LVU617
 540:Src/util.c    ****     INPUT1_MAX_temp = MAX(INPUT1_MAX_temp, INPUT1_MID_temp);
 2314              		.loc 1 540 21 is_stmt 0 view .LVU618
 2315 008e D845     		cmp	r8, fp
 2316 0090 A8BF     		it	ge
 2317 0092 D846     		movge	r8, fp
 2318              	.LVL147:
 541:Src/util.c    ****     INPUT2_MIN_temp = MIN(INPUT2_MIN_temp, INPUT2_MID_temp);
 2319              		.loc 1 541 5 is_stmt 1 view .LVU619
 541:Src/util.c    ****     INPUT2_MIN_temp = MIN(INPUT2_MIN_temp, INPUT2_MID_temp);
 2320              		.loc 1 541 21 is_stmt 0 view .LVU620
 2321 0094 5F45     		cmp	r7, fp
 2322 0096 B8BF     		it	lt
 2323 0098 5F46     		movlt	r7, fp
 2324              	.LVL148:
 542:Src/util.c    ****     INPUT2_MAX_temp = MAX(INPUT2_MAX_temp, INPUT2_MID_temp);
 2325              		.loc 1 542 5 is_stmt 1 view .LVU621
 542:Src/util.c    ****     INPUT2_MAX_temp = MAX(INPUT2_MAX_temp, INPUT2_MID_temp);
 2326              		.loc 1 542 21 is_stmt 0 view .LVU622
 2327 009a 5645     		cmp	r6, r10
 2328 009c A8BF     		it	ge
 2329 009e 5646     		movge	r6, r10
 2330              	.LVL149:
 543:Src/util.c    ****     HAL_Delay(5);
 2331              		.loc 1 543 5 is_stmt 1 view .LVU623
 543:Src/util.c    ****     HAL_Delay(5);
 2332              		.loc 1 543 21 is_stmt 0 view .LVU624
 2333 00a0 5545     		cmp	r5, r10
 2334 00a2 B8BF     		it	lt
 2335 00a4 5546     		movlt	r5, r10
 2336              	.LVL150:
 544:Src/util.c    ****   }
 2337              		.loc 1 544 5 is_stmt 1 view .LVU625
 2338 00a6 0520     		movs	r0, #5
 2339 00a8 FFF7FEFF 		bl	HAL_Delay
 2340              	.LVL151:
 533:Src/util.c    ****     readInputRaw();
 2341              		.loc 1 533 73 is_stmt 0 view .LVU626
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 76


 2342 00ac A146     		mov	r9, r4
 2343              	.LVL152:
 2344              	.L150:
 533:Src/util.c    ****     readInputRaw();
 2345              		.loc 1 533 9 is_stmt 1 view .LVU627
 533:Src/util.c    ****     readInputRaw();
 2346              		.loc 1 533 11 is_stmt 0 view .LVU628
 2347 00ae 0221     		movs	r1, #2
 2348 00b0 2C48     		ldr	r0, .L161+20
 2349 00b2 FFF7FEFF 		bl	HAL_GPIO_ReadPin
 2350              	.LVL153:
 533:Src/util.c    ****     readInputRaw();
 2351              		.loc 1 533 9 view .LVU629
 2352 00b6 28B9     		cbnz	r0, .L151
 533:Src/util.c    ****     readInputRaw();
 2353              		.loc 1 533 73 discriminator 1 view .LVU630
 2354 00b8 09F10104 		add	r4, r9, #1
 2355 00bc A4B2     		uxth	r4, r4
 2356              	.LVL154:
 533:Src/util.c    ****     readInputRaw();
 2357              		.loc 1 533 53 discriminator 1 view .LVU631
 2358 00be B9F57A6F 		cmp	r9, #4000
 2359 00c2 C4D3     		bcc	.L152
 2360              	.LVL155:
 2361              	.L151:
 550:Src/util.c    ****   if (input1TypTemp == input1[inIdx].typDef || input1[inIdx].typDef == 3) {  // Accept calibration 
 2362              		.loc 1 550 3 is_stmt 1 view .LVU632
 550:Src/util.c    ****   if (input1TypTemp == input1[inIdx].typDef || input1[inIdx].typDef == 3) {  // Accept calibration 
 2363              		.loc 1 550 27 is_stmt 0 view .LVU633
 2364 00c4 3A46     		mov	r2, r7
 2365 00c6 5946     		mov	r1, fp
 2366 00c8 4046     		mov	r0, r8
 2367 00ca FFF7FEFF 		bl	checkInputType
 2368              	.LVL156:
 550:Src/util.c    ****   if (input1TypTemp == input1[inIdx].typDef || input1[inIdx].typDef == 3) {  // Accept calibration 
 2369              		.loc 1 550 11 view .LVU634
 2370 00ce 5FFA80F9 		uxtb	r9, r0
 2371              	.LVL157:
 551:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2372              		.loc 1 551 3 is_stmt 1 view .LVU635
 551:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2373              		.loc 1 551 37 is_stmt 0 view .LVU636
 2374 00d2 204B     		ldr	r3, .L161+4
 2375 00d4 1C78     		ldrb	r4, [r3]	@ zero_extendqisi2
 2376 00d6 C4EBC402 		rsb	r2, r4, r4, lsl #3
 2377 00da 1F4B     		ldr	r3, .L161+8
 2378 00dc 03EB4203 		add	r3, r3, r2, lsl #1
 2379 00e0 5B79     		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 551:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2380              		.loc 1 551 6 view .LVU637
 2381 00e2 4B45     		cmp	r3, r9
 2382 00e4 03D0     		beq	.L153
 551:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2383              		.loc 1 551 45 discriminator 1 view .LVU638
 2384 00e6 032B     		cmp	r3, #3
 2385 00e8 01D0     		beq	.L153
 556:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 77


 2386              		.loc 1 556 19 view .LVU639
 2387 00ea 4FF00009 		mov	r9, #0
 2388              	.LVL158:
 2389              	.L153:
 565:Src/util.c    ****   if (input2TypTemp == input2[inIdx].typDef || input2[inIdx].typDef == 3) {  // Accept calibration 
 2390              		.loc 1 565 3 is_stmt 1 view .LVU640
 565:Src/util.c    ****   if (input2TypTemp == input2[inIdx].typDef || input2[inIdx].typDef == 3) {  // Accept calibration 
 2391              		.loc 1 565 27 is_stmt 0 view .LVU641
 2392 00ee 2A46     		mov	r2, r5
 2393 00f0 5146     		mov	r1, r10
 2394 00f2 3046     		mov	r0, r6
 2395 00f4 FFF7FEFF 		bl	checkInputType
 2396              	.LVL159:
 565:Src/util.c    ****   if (input2TypTemp == input2[inIdx].typDef || input2[inIdx].typDef == 3) {  // Accept calibration 
 2397              		.loc 1 565 11 view .LVU642
 2398 00f8 C0B2     		uxtb	r0, r0
 2399              	.LVL160:
 566:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2400              		.loc 1 566 3 is_stmt 1 view .LVU643
 566:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2401              		.loc 1 566 37 is_stmt 0 view .LVU644
 2402 00fa C4EBC403 		rsb	r3, r4, r4, lsl #3
 2403 00fe 174A     		ldr	r2, .L161+12
 2404 0100 02EB4303 		add	r3, r2, r3, lsl #1
 2405 0104 5B79     		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 566:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2406              		.loc 1 566 6 view .LVU645
 2407 0106 8342     		cmp	r3, r0
 2408 0108 02D0     		beq	.L154
 566:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2409              		.loc 1 566 45 discriminator 1 view .LVU646
 2410 010a 032B     		cmp	r3, #3
 2411 010c 00D0     		beq	.L154
 571:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2412              		.loc 1 571 19 view .LVU647
 2413 010e 0020     		movs	r0, #0
 2414              	.LVL161:
 2415              	.L154:
 579:Src/util.c    ****     input1[inIdx].typ = input1TypTemp;
 2416              		.loc 1 579 3 is_stmt 1 view .LVU648
 579:Src/util.c    ****     input1[inIdx].typ = input1TypTemp;
 2417              		.loc 1 579 6 is_stmt 0 view .LVU649
 2418 0110 B9F1000F 		cmp	r9, #0
 2419 0114 02D1     		bne	.L155
 579:Src/util.c    ****     input1[inIdx].typ = input1TypTemp;
 2420              		.loc 1 579 26 discriminator 1 view .LVU650
 2421 0116 0028     		cmp	r0, #0
 2422 0118 3FF47CAF 		beq	.L147
 2423              	.L155:
 580:Src/util.c    ****     input1[inIdx].min = INPUT1_MIN_temp + input_margin;
 2424              		.loc 1 580 5 is_stmt 1 view .LVU651
 580:Src/util.c    ****     input1[inIdx].min = INPUT1_MIN_temp + input_margin;
 2425              		.loc 1 580 23 is_stmt 0 view .LVU652
 2426 011c C4EBC402 		rsb	r2, r4, r4, lsl #3
 2427 0120 0D4B     		ldr	r3, .L161+8
 2428 0122 03EB4203 		add	r3, r3, r2, lsl #1
 2429 0126 83F80490 		strb	r9, [r3, #4]
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 78


 581:Src/util.c    ****     input1[inIdx].mid = INPUT1_MID_temp;
 2430              		.loc 1 581 5 is_stmt 1 view .LVU653
 581:Src/util.c    ****     input1[inIdx].mid = INPUT1_MID_temp;
 2431              		.loc 1 581 23 is_stmt 0 view .LVU654
 2432 012a A3F80680 		strh	r8, [r3, #6]	@ movhi
 582:Src/util.c    ****     input1[inIdx].max = INPUT1_MAX_temp - input_margin;
 2433              		.loc 1 582 5 is_stmt 1 view .LVU655
 582:Src/util.c    ****     input1[inIdx].max = INPUT1_MAX_temp - input_margin;
 2434              		.loc 1 582 23 is_stmt 0 view .LVU656
 2435 012e A3F808B0 		strh	fp, [r3, #8]	@ movhi
 583:Src/util.c    **** 
 2436              		.loc 1 583 5 is_stmt 1 view .LVU657
 583:Src/util.c    **** 
 2437              		.loc 1 583 23 is_stmt 0 view .LVU658
 2438 0132 5F81     		strh	r7, [r3, #10]	@ movhi
 585:Src/util.c    ****     input2[inIdx].min = INPUT2_MIN_temp + input_margin;
 2439              		.loc 1 585 5 is_stmt 1 view .LVU659
 585:Src/util.c    ****     input2[inIdx].min = INPUT2_MIN_temp + input_margin;
 2440              		.loc 1 585 23 is_stmt 0 view .LVU660
 2441 0134 094A     		ldr	r2, .L161+12
 2442 0136 C4EBC403 		rsb	r3, r4, r4, lsl #3
 2443 013a 02EB4303 		add	r3, r2, r3, lsl #1
 2444 013e 1871     		strb	r0, [r3, #4]
 586:Src/util.c    ****     input2[inIdx].mid = INPUT2_MID_temp;
 2445              		.loc 1 586 5 is_stmt 1 view .LVU661
 586:Src/util.c    ****     input2[inIdx].mid = INPUT2_MID_temp;
 2446              		.loc 1 586 23 is_stmt 0 view .LVU662
 2447 0140 DE80     		strh	r6, [r3, #6]	@ movhi
 587:Src/util.c    ****     input2[inIdx].max = INPUT2_MAX_temp - input_margin;
 2448              		.loc 1 587 5 is_stmt 1 view .LVU663
 587:Src/util.c    ****     input2[inIdx].max = INPUT2_MAX_temp - input_margin;
 2449              		.loc 1 587 23 is_stmt 0 view .LVU664
 2450 0142 A3F808A0 		strh	r10, [r3, #8]	@ movhi
 588:Src/util.c    **** 
 2451              		.loc 1 588 5 is_stmt 1 view .LVU665
 588:Src/util.c    **** 
 2452              		.loc 1 588 23 is_stmt 0 view .LVU666
 2453 0146 5D81     		strh	r5, [r3, #10]	@ movhi
 590:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2454              		.loc 1 590 5 is_stmt 1 view .LVU667
 590:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2455              		.loc 1 590 19 is_stmt 0 view .LVU668
 2456 0148 074B     		ldr	r3, .L161+24
 2457 014a 0122     		movs	r2, #1
 2458 014c 1A70     		strb	r2, [r3]
 2459 014e 61E7     		b	.L147
 2460              	.L162:
 2461              		.align	2
 2462              	.L161:
 2463 0150 00000000 		.word	.LANCHOR12
 2464 0154 00000000 		.word	.LANCHOR17
 2465 0158 00000000 		.word	.LANCHOR15
 2466 015c 00000000 		.word	.LANCHOR16
 2467 0160 0080FFFF 		.word	-32768
 2468 0164 00080140 		.word	1073809408
 2469 0168 00000000 		.word	.LANCHOR28
 2470              		.cfi_endproc
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 79


 2471              	.LFE76:
 2473              		.section	.text.updateCurSpdLim,"ax",%progbits
 2474              		.align	1
 2475              		.global	updateCurSpdLim
 2476              		.syntax unified
 2477              		.thumb
 2478              		.thumb_func
 2480              	updateCurSpdLim:
 2481              	.LFB77:
 612:Src/util.c    ****   calcAvgSpeed();
 2482              		.loc 1 612 28 is_stmt 1 view -0
 2483              		.cfi_startproc
 2484              		@ args = 0, pretend = 0, frame = 8
 2485              		@ frame_needed = 0, uses_anonymous_args = 0
 2486 0000 30B5     		push	{r4, r5, lr}
 2487              	.LCFI22:
 2488              		.cfi_def_cfa_offset 12
 2489              		.cfi_offset 4, -12
 2490              		.cfi_offset 5, -8
 2491              		.cfi_offset 14, -4
 2492 0002 83B0     		sub	sp, sp, #12
 2493              	.LCFI23:
 2494              		.cfi_def_cfa_offset 24
 613:Src/util.c    ****   if (speedAvgAbs > 5) {    // do not enter this mode if motors are spinning
 2495              		.loc 1 613 3 view .LVU670
 2496 0004 FFF7FEFF 		bl	calcAvgSpeed
 2497              	.LVL162:
 614:Src/util.c    ****     return;
 2498              		.loc 1 614 3 view .LVU671
 614:Src/util.c    ****     return;
 2499              		.loc 1 614 19 is_stmt 0 view .LVU672
 2500 0008 514B     		ldr	r3, .L176
 2501 000a B3F90030 		ldrsh	r3, [r3]
 614:Src/util.c    ****     return;
 2502              		.loc 1 614 6 view .LVU673
 2503 000e 052B     		cmp	r3, #5
 2504 0010 00F39680 		bgt	.L163
 624:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2505              		.loc 1 624 3 is_stmt 1 view .LVU674
 624:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2506              		.loc 1 624 40 is_stmt 0 view .LVU675
 2507 0014 4F4B     		ldr	r3, .L176+4
 2508 0016 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2509 0018 C3EBC301 		rsb	r1, r3, r3, lsl #3
 2510 001c 4E4A     		ldr	r2, .L176+8
 2511 001e 32F91120 		ldrsh	r2, [r2, r1, lsl #1]
 624:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2512              		.loc 1 624 45 view .LVU676
 2513 0022 1204     		lsls	r2, r2, #16
 624:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2514              		.loc 1 624 12 view .LVU677
 2515 0024 0192     		str	r2, [sp, #4]
 625:Src/util.c    ****   uint16_t cur_factor;    // fixdt(0,16,16)
 2516              		.loc 1 625 3 is_stmt 1 view .LVU678
 625:Src/util.c    ****   uint16_t cur_factor;    // fixdt(0,16,16)
 2517              		.loc 1 625 40 is_stmt 0 view .LVU679
 2518 0026 4D4A     		ldr	r2, .L176+12
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 80


 2519 0028 32F91130 		ldrsh	r3, [r2, r1, lsl #1]
 625:Src/util.c    ****   uint16_t cur_factor;    // fixdt(0,16,16)
 2520              		.loc 1 625 45 view .LVU680
 2521 002c 1B04     		lsls	r3, r3, #16
 625:Src/util.c    ****   uint16_t cur_factor;    // fixdt(0,16,16)
 2522              		.loc 1 625 12 view .LVU681
 2523 002e 0093     		str	r3, [sp]
 626:Src/util.c    ****   uint16_t spd_factor;    // fixdt(0,16,16)
 2524              		.loc 1 626 3 is_stmt 1 view .LVU682
 627:Src/util.c    ****   uint16_t cur_spd_timeout = 0;
 2525              		.loc 1 627 3 view .LVU683
 628:Src/util.c    ****   cur_spd_valid = 0;
 2526              		.loc 1 628 3 view .LVU684
 2527              	.LVL163:
 629:Src/util.c    **** 
 2528              		.loc 1 629 3 view .LVU685
 629:Src/util.c    **** 
 2529              		.loc 1 629 17 is_stmt 0 view .LVU686
 2530 0030 0024     		movs	r4, #0
 2531 0032 4B4B     		ldr	r3, .L176+16
 2532 0034 1C70     		strb	r4, [r3]
 632:Src/util.c    ****     readInputRaw();
 2533              		.loc 1 632 3 is_stmt 1 view .LVU687
 632:Src/util.c    ****     readInputRaw();
 2534              		.loc 1 632 9 is_stmt 0 view .LVU688
 2535 0036 1CE0     		b	.L166
 2536              	.LVL164:
 2537              	.L168:
 633:Src/util.c    ****     filtLowPass32(input1[inIdx].raw, FILTER, &input1_fixdt);
 2538              		.loc 1 633 5 is_stmt 1 view .LVU689
 2539 0038 FFF7FEFF 		bl	readInputRaw
 2540              	.LVL165:
 634:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 2541              		.loc 1 634 5 view .LVU690
 634:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 2542              		.loc 1 634 32 is_stmt 0 view .LVU691
 2543 003c 454C     		ldr	r4, .L176+4
 2544 003e 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 2545 0040 C3EBC303 		rsb	r3, r3, r3, lsl #3
 634:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 2546              		.loc 1 634 5 view .LVU692
 2547 0044 01AA     		add	r2, sp, #4
 2548 0046 41F69911 		movw	r1, #6553
 2549 004a 4348     		ldr	r0, .L176+8
 2550 004c 30F91300 		ldrsh	r0, [r0, r3, lsl #1]
 2551 0050 FFF7FEFF 		bl	filtLowPass32
 2552              	.LVL166:
 635:Src/util.c    ****     HAL_Delay(5);
 2553              		.loc 1 635 5 is_stmt 1 view .LVU693
 635:Src/util.c    ****     HAL_Delay(5);
 2554              		.loc 1 635 32 is_stmt 0 view .LVU694
 2555 0054 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 2556 0056 C3EBC303 		rsb	r3, r3, r3, lsl #3
 635:Src/util.c    ****     HAL_Delay(5);
 2557              		.loc 1 635 5 view .LVU695
 2558 005a 6A46     		mov	r2, sp
 2559 005c 41F69911 		movw	r1, #6553
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 81


 2560 0060 3E48     		ldr	r0, .L176+12
 2561 0062 30F91300 		ldrsh	r0, [r0, r3, lsl #1]
 2562 0066 FFF7FEFF 		bl	filtLowPass32
 2563              	.LVL167:
 636:Src/util.c    ****   }
 2564              		.loc 1 636 5 is_stmt 1 view .LVU696
 2565 006a 0520     		movs	r0, #5
 2566 006c FFF7FEFF 		bl	HAL_Delay
 2567              	.LVL168:
 632:Src/util.c    ****     readInputRaw();
 2568              		.loc 1 632 71 is_stmt 0 view .LVU697
 2569 0070 2C46     		mov	r4, r5
 2570              	.LVL169:
 2571              	.L166:
 632:Src/util.c    ****     readInputRaw();
 2572              		.loc 1 632 9 is_stmt 1 view .LVU698
 632:Src/util.c    ****     readInputRaw();
 2573              		.loc 1 632 11 is_stmt 0 view .LVU699
 2574 0072 0221     		movs	r1, #2
 2575 0074 3B48     		ldr	r0, .L176+20
 2576 0076 FFF7FEFF 		bl	HAL_GPIO_ReadPin
 2577              	.LVL170:
 632:Src/util.c    ****     readInputRaw();
 2578              		.loc 1 632 9 view .LVU700
 2579 007a 20B9     		cbnz	r0, .L167
 632:Src/util.c    ****     readInputRaw();
 2580              		.loc 1 632 71 discriminator 1 view .LVU701
 2581 007c 631C     		adds	r3, r4, #1
 2582 007e 9DB2     		uxth	r5, r3
 2583              	.LVL171:
 632:Src/util.c    ****     readInputRaw();
 2584              		.loc 1 632 53 discriminator 1 view .LVU702
 2585 0080 B4F5FA6F 		cmp	r4, #2000
 2586 0084 D8D3     		bcc	.L168
 2587              	.LVL172:
 2588              	.L167:
 639:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 2589              		.loc 1 639 3 is_stmt 1 view .LVU703
 639:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 2590              		.loc 1 639 16 is_stmt 0 view .LVU704
 2591 0086 334B     		ldr	r3, .L176+4
 2592 0088 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2593 008a C3EBC302 		rsb	r2, r3, r3, lsl #3
 2594 008e 3249     		ldr	r1, .L176+8
 2595 0090 01EB4201 		add	r1, r1, r2, lsl #1
 2596 0094 B1F90600 		ldrsh	r0, [r1, #6]
 2597 0098 019A     		ldr	r2, [sp, #4]
 2598 009a A2EB0042 		sub	r2, r2, r0, lsl #16
 2599 009e B1F90A10 		ldrsh	r1, [r1, #10]
 2600 00a2 091A     		subs	r1, r1, r0
 2601 00a4 92FBF1F2 		sdiv	r2, r2, r1
 639:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 2602              		.loc 1 639 14 view .LVU705
 2603 00a8 B2F5803F 		cmp	r2, #65536
 2604 00ac 4ADA     		bge	.L173
 639:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 2605              		.loc 1 639 16 discriminator 1 view .LVU706
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 82


 2606 00ae 41F69911 		movw	r1, #6553
 2607 00b2 8A42     		cmp	r2, r1
 2608 00b4 B8BF     		it	lt
 2609 00b6 0A46     		movlt	r2, r1
 639:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 2610              		.loc 1 639 14 discriminator 1 view .LVU707
 2611 00b8 94B2     		uxth	r4, r2
 2612              	.L169:
 2613              	.LVL173:
 640:Src/util.c    ****       
 2614              		.loc 1 640 3 is_stmt 1 discriminator 4 view .LVU708
 640:Src/util.c    ****       
 2615              		.loc 1 640 16 is_stmt 0 discriminator 4 view .LVU709
 2616 00ba C3EBC301 		rsb	r1, r3, r3, lsl #3
 2617 00be 2748     		ldr	r0, .L176+12
 2618 00c0 00EB4101 		add	r1, r0, r1, lsl #1
 2619 00c4 B1F90600 		ldrsh	r0, [r1, #6]
 2620 00c8 009A     		ldr	r2, [sp]
 2621 00ca A2EB0042 		sub	r2, r2, r0, lsl #16
 2622 00ce B1F90A10 		ldrsh	r1, [r1, #10]
 2623 00d2 091A     		subs	r1, r1, r0
 2624 00d4 92FBF1F2 		sdiv	r2, r2, r1
 640:Src/util.c    ****       
 2625              		.loc 1 640 14 discriminator 4 view .LVU710
 2626 00d8 B2F5803F 		cmp	r2, #65536
 2627 00dc 35DA     		bge	.L174
 640:Src/util.c    ****       
 2628              		.loc 1 640 16 discriminator 1 view .LVU711
 2629 00de 40F6CC41 		movw	r1, #3276
 2630 00e2 8A42     		cmp	r2, r1
 2631 00e4 B8BF     		it	lt
 2632 00e6 0A46     		movlt	r2, r1
 640:Src/util.c    ****       
 2633              		.loc 1 640 14 discriminator 1 view .LVU712
 2634 00e8 91B2     		uxth	r1, r2
 2635              	.L170:
 2636              	.LVL174:
 642:Src/util.c    ****     // Update current limit
 2637              		.loc 1 642 3 is_stmt 1 discriminator 4 view .LVU713
 642:Src/util.c    ****     // Update current limit
 2638              		.loc 1 642 20 is_stmt 0 discriminator 4 view .LVU714
 2639 00ea C3EBC302 		rsb	r2, r3, r3, lsl #3
 2640 00ee 1A48     		ldr	r0, .L176+8
 2641 00f0 00EB4202 		add	r2, r0, r2, lsl #1
 2642 00f4 1279     		ldrb	r2, [r2, #4]	@ zero_extendqisi2
 642:Src/util.c    ****     // Update current limit
 2643              		.loc 1 642 6 discriminator 4 view .LVU715
 2644 00f6 6AB1     		cbz	r2, .L171
 644:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 2645              		.loc 1 644 5 is_stmt 1 view .LVU716
 644:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 2646              		.loc 1 644 75 is_stmt 0 view .LVU717
 2647 00f8 40F2EE22 		movw	r2, #750
 2648 00fc 04FB02F2 		mul	r2, r4, r2
 644:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 2649              		.loc 1 644 41 view .LVU718
 2650 0100 1213     		asrs	r2, r2, #12
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 83


 644:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 2651              		.loc 1 644 39 view .LVU719
 2652 0102 1948     		ldr	r0, .L176+24
 2653 0104 A0F8CE20 		strh	r2, [r0, #206]	@ movhi
 644:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 2654              		.loc 1 644 20 view .LVU720
 2655 0108 1848     		ldr	r0, .L176+28
 2656 010a A0F8CE20 		strh	r2, [r0, #206]	@ movhi
 645:Src/util.c    ****   }
 2657              		.loc 1 645 5 is_stmt 1 view .LVU721
 645:Src/util.c    ****   }
 2658              		.loc 1 645 21 is_stmt 0 view .LVU722
 2659 010e 144A     		ldr	r2, .L176+16
 2660 0110 0120     		movs	r0, #1
 2661 0112 1070     		strb	r0, [r2]
 2662              	.L171:
 648:Src/util.c    ****     // Update speed limit
 2663              		.loc 1 648 3 is_stmt 1 view .LVU723
 648:Src/util.c    ****     // Update speed limit
 2664              		.loc 1 648 20 is_stmt 0 view .LVU724
 2665 0114 C3EBC303 		rsb	r3, r3, r3, lsl #3
 2666 0118 104A     		ldr	r2, .L176+12
 2667 011a 02EB4303 		add	r3, r2, r3, lsl #1
 2668 011e 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 648:Src/util.c    ****     // Update speed limit
 2669              		.loc 1 648 6 view .LVU725
 2670 0120 73B1     		cbz	r3, .L163
 650:Src/util.c    ****     cur_spd_valid  += 2;  // Mark update to be saved in Flash at shutdown
 2671              		.loc 1 650 5 is_stmt 1 view .LVU726
 650:Src/util.c    ****     cur_spd_valid  += 2;  // Mark update to be saved in Flash at shutdown
 2672              		.loc 1 650 62 is_stmt 0 view .LVU727
 2673 0122 4FF47A73 		mov	r3, #1000
 2674 0126 03FB01F2 		mul	r2, r3, r1
 650:Src/util.c    ****     cur_spd_valid  += 2;  // Mark update to be saved in Flash at shutdown
 2675              		.loc 1 650 41 view .LVU728
 2676 012a 1313     		asrs	r3, r2, #12
 650:Src/util.c    ****     cur_spd_valid  += 2;  // Mark update to be saved in Flash at shutdown
 2677              		.loc 1 650 39 view .LVU729
 2678 012c 0E4A     		ldr	r2, .L176+24
 2679 012e A2F8DA30 		strh	r3, [r2, #218]	@ movhi
 650:Src/util.c    ****     cur_spd_valid  += 2;  // Mark update to be saved in Flash at shutdown
 2680              		.loc 1 650 20 view .LVU730
 2681 0132 0E4A     		ldr	r2, .L176+28
 2682 0134 A2F8DA30 		strh	r3, [r2, #218]	@ movhi
 651:Src/util.c    ****   }
 2683              		.loc 1 651 5 is_stmt 1 view .LVU731
 651:Src/util.c    ****   }
 2684              		.loc 1 651 20 is_stmt 0 view .LVU732
 2685 0138 094A     		ldr	r2, .L176+16
 2686 013a 1378     		ldrb	r3, [r2]	@ zero_extendqisi2
 2687 013c 0233     		adds	r3, r3, #2
 2688 013e 1370     		strb	r3, [r2]
 2689              	.LVL175:
 2690              	.L163:
 661:Src/util.c    **** 
 2691              		.loc 1 661 1 view .LVU733
 2692 0140 03B0     		add	sp, sp, #12
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 84


 2693              	.LCFI24:
 2694              		.cfi_remember_state
 2695              		.cfi_def_cfa_offset 12
 2696              		@ sp needed
 2697 0142 30BD     		pop	{r4, r5, pc}
 2698              	.L173:
 2699              	.LCFI25:
 2700              		.cfi_restore_state
 639:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 2701              		.loc 1 639 14 view .LVU734
 2702 0144 4FF6FF74 		movw	r4, #65535
 2703 0148 B7E7     		b	.L169
 2704              	.LVL176:
 2705              	.L174:
 640:Src/util.c    ****       
 2706              		.loc 1 640 14 view .LVU735
 2707 014a 4FF6FF71 		movw	r1, #65535
 2708 014e CCE7     		b	.L170
 2709              	.L177:
 2710              		.align	2
 2711              	.L176:
 2712 0150 00000000 		.word	.LANCHOR12
 2713 0154 00000000 		.word	.LANCHOR17
 2714 0158 00000000 		.word	.LANCHOR15
 2715 015c 00000000 		.word	.LANCHOR16
 2716 0160 00000000 		.word	.LANCHOR29
 2717 0164 00080140 		.word	1073809408
 2718 0168 00000000 		.word	.LANCHOR0
 2719 016c 00000000 		.word	rtP_Left
 2720              		.cfi_endproc
 2721              	.LFE77:
 2723              		.section	.text.poweroffPressCheck,"ax",%progbits
 2724              		.align	1
 2725              		.global	poweroffPressCheck
 2726              		.syntax unified
 2727              		.thumb
 2728              		.thumb_func
 2730              	poweroffPressCheck:
 2731              	.LFB93:
1558:Src/util.c    ****   #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 2732              		.loc 1 1558 31 is_stmt 1 view -0
 2733              		.cfi_startproc
 2734              		@ args = 0, pretend = 0, frame = 0
 2735              		@ frame_needed = 0, uses_anonymous_args = 0
 2736 0000 38B5     		push	{r3, r4, r5, lr}
 2737              	.LCFI26:
 2738              		.cfi_def_cfa_offset 16
 2739              		.cfi_offset 3, -16
 2740              		.cfi_offset 4, -12
 2741              		.cfi_offset 5, -8
 2742              		.cfi_offset 14, -4
1560:Src/util.c    ****       uint16_t cnt_press = 0;
 2743              		.loc 1 1560 5 view .LVU737
1560:Src/util.c    ****       uint16_t cnt_press = 0;
 2744              		.loc 1 1560 8 is_stmt 0 view .LVU738
 2745 0002 0221     		movs	r1, #2
 2746 0004 2448     		ldr	r0, .L193
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 85


 2747 0006 FFF7FEFF 		bl	HAL_GPIO_ReadPin
 2748              	.LVL177:
1560:Src/util.c    ****       uint16_t cnt_press = 0;
 2749              		.loc 1 1560 7 view .LVU739
 2750 000a 90B9     		cbnz	r0, .L188
 2751              	.L178:
1618:Src/util.c    **** 
 2752              		.loc 1 1618 1 view .LVU740
 2753 000c 38BD     		pop	{r3, r4, r5, pc}
 2754              	.LVL178:
 2755              	.L181:
1558:Src/util.c    ****   #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 2756              		.loc 1 1558 31 view .LVU741
 2757 000e 2546     		mov	r5, r4
 2758              	.LVL179:
 2759              	.L179:
 2760              	.LBB12:
1562:Src/util.c    ****         HAL_Delay(10);
 2761              		.loc 1 1562 12 is_stmt 1 view .LVU742
1562:Src/util.c    ****         HAL_Delay(10);
 2762              		.loc 1 1562 13 is_stmt 0 view .LVU743
 2763 0010 0221     		movs	r1, #2
 2764 0012 2148     		ldr	r0, .L193
 2765 0014 FFF7FEFF 		bl	HAL_GPIO_ReadPin
 2766              	.LVL180:
1562:Src/util.c    ****         HAL_Delay(10);
 2767              		.loc 1 1562 12 view .LVU744
 2768 0018 68B1     		cbz	r0, .L191
1563:Src/util.c    ****         if (cnt_press++ == 5 * 100) { beepShort(5); }
 2769              		.loc 1 1563 9 is_stmt 1 view .LVU745
 2770 001a 0A20     		movs	r0, #10
 2771 001c FFF7FEFF 		bl	HAL_Delay
 2772              	.LVL181:
1564:Src/util.c    ****       }
 2773              		.loc 1 1564 9 view .LVU746
1564:Src/util.c    ****       }
 2774              		.loc 1 1564 22 is_stmt 0 view .LVU747
 2775 0020 6C1C     		adds	r4, r5, #1
 2776 0022 A4B2     		uxth	r4, r4
 2777              	.LVL182:
1564:Src/util.c    ****       }
 2778              		.loc 1 1564 12 view .LVU748
 2779 0024 B5F5FA7F 		cmp	r5, #500
 2780 0028 F1D1     		bne	.L181
1564:Src/util.c    ****       }
 2781              		.loc 1 1564 39 is_stmt 1 discriminator 1 view .LVU749
 2782 002a 0520     		movs	r0, #5
 2783 002c FFF7FEFF 		bl	beepShort
 2784              	.LVL183:
 2785 0030 EDE7     		b	.L181
 2786              	.LVL184:
 2787              	.L188:
1561:Src/util.c    ****       while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
 2788              		.loc 1 1561 16 is_stmt 0 view .LVU750
 2789 0032 0025     		movs	r5, #0
 2790 0034 ECE7     		b	.L179
 2791              	.LVL185:
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 86


 2792              	.L191:
1567:Src/util.c    **** 
 2793              		.loc 1 1567 7 is_stmt 1 view .LVU751
1567:Src/util.c    **** 
 2794              		.loc 1 1567 10 is_stmt 0 view .LVU752
 2795 0036 082D     		cmp	r5, #8
 2796 0038 02D9     		bls	.L183
1567:Src/util.c    **** 
 2797              		.loc 1 1567 26 is_stmt 1 discriminator 1 view .LVU753
1567:Src/util.c    **** 
 2798              		.loc 1 1567 33 is_stmt 0 discriminator 1 view .LVU754
 2799 003a 184B     		ldr	r3, .L193+4
 2800 003c 0022     		movs	r2, #0
 2801 003e 1A70     		strb	r2, [r3]
 2802              	.L183:
1569:Src/util.c    ****         HAL_Delay(1000);
 2803              		.loc 1 1569 7 is_stmt 1 view .LVU755
1569:Src/util.c    ****         HAL_Delay(1000);
 2804              		.loc 1 1569 10 is_stmt 0 view .LVU756
 2805 0040 B5F5FA7F 		cmp	r5, #500
 2806 0044 03D2     		bcs	.L192
1583:Src/util.c    ****         #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2807              		.loc 1 1583 14 is_stmt 1 view .LVU757
1583:Src/util.c    ****         #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2808              		.loc 1 1583 17 is_stmt 0 view .LVU758
 2809 0046 082D     		cmp	r5, #8
 2810 0048 E0D9     		bls	.L178
1587:Src/util.c    ****       }
 2811              		.loc 1 1587 7 is_stmt 1 view .LVU759
 2812 004a FFF7FEFF 		bl	poweroff
 2813              	.LVL186:
 2814              	.L192:
1570:Src/util.c    ****         if (HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {  // Double press: Adjust Max Current, Max 
 2815              		.loc 1 1570 9 view .LVU760
 2816 004e 4FF47A70 		mov	r0, #1000
 2817 0052 FFF7FEFF 		bl	HAL_Delay
 2818              	.LVL187:
1571:Src/util.c    ****           while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
 2819              		.loc 1 1571 9 view .LVU761
1571:Src/util.c    ****           while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
 2820              		.loc 1 1571 13 is_stmt 0 view .LVU762
 2821 0056 0221     		movs	r1, #2
 2822 0058 0F48     		ldr	r0, .L193
 2823 005a FFF7FEFF 		bl	HAL_GPIO_ReadPin
 2824              	.LVL188:
1571:Src/util.c    ****           while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
 2825              		.loc 1 1571 12 view .LVU763
 2826 005e 58B9     		cbnz	r0, .L185
1578:Src/util.c    ****           adcCalibLim();
 2827              		.loc 1 1578 11 is_stmt 1 view .LVU764
 2828 0060 1020     		movs	r0, #16
 2829 0062 FFF7FEFF 		bl	beepLong
 2830              	.LVL189:
1579:Src/util.c    ****           beepShort(5);
 2831              		.loc 1 1579 11 view .LVU765
 2832 0066 FFF7FEFF 		bl	adcCalibLim
 2833              	.LVL190:
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 87


1580:Src/util.c    ****           #endif
 2834              		.loc 1 1580 11 view .LVU766
 2835 006a 0520     		movs	r0, #5
 2836 006c FFF7FEFF 		bl	beepShort
 2837              	.LVL191:
 2838 0070 CCE7     		b	.L178
 2839              	.L187:
1572:Src/util.c    ****           beepLong(8);
 2840              		.loc 1 1572 62 discriminator 2 view .LVU767
 2841 0072 0A20     		movs	r0, #10
 2842 0074 FFF7FEFF 		bl	HAL_Delay
 2843              	.LVL192:
 2844              	.L185:
1572:Src/util.c    ****           beepLong(8);
 2845              		.loc 1 1572 16 discriminator 1 view .LVU768
1572:Src/util.c    ****           beepLong(8);
 2846              		.loc 1 1572 17 is_stmt 0 discriminator 1 view .LVU769
 2847 0078 0221     		movs	r1, #2
 2848 007a 0748     		ldr	r0, .L193
 2849 007c FFF7FEFF 		bl	HAL_GPIO_ReadPin
 2850              	.LVL193:
1572:Src/util.c    ****           beepLong(8);
 2851              		.loc 1 1572 16 discriminator 1 view .LVU770
 2852 0080 0028     		cmp	r0, #0
 2853 0082 F6D1     		bne	.L187
1573:Src/util.c    ****           updateCurSpdLim();
 2854              		.loc 1 1573 11 is_stmt 1 view .LVU771
 2855 0084 0820     		movs	r0, #8
 2856 0086 FFF7FEFF 		bl	beepLong
 2857              	.LVL194:
1574:Src/util.c    ****           beepShort(5);
 2858              		.loc 1 1574 11 view .LVU772
 2859 008a FFF7FEFF 		bl	updateCurSpdLim
 2860              	.LVL195:
1575:Src/util.c    ****         } else {                                          // Long press: Calibrate ADC Limits
 2861              		.loc 1 1575 11 view .LVU773
 2862 008e 0520     		movs	r0, #5
 2863 0090 FFF7FEFF 		bl	beepShort
 2864              	.LVL196:
 2865 0094 BAE7     		b	.L178
 2866              	.L194:
 2867 0096 00BF     		.align	2
 2868              	.L193:
 2869 0098 00080140 		.word	1073809408
 2870 009c 00000000 		.word	enable
 2871              	.LBE12:
 2872              		.cfi_endproc
 2873              	.LFE93:
 2875              		.section	.text.rateLimiter16,"ax",%progbits
 2876              		.align	1
 2877              		.global	rateLimiter16
 2878              		.syntax unified
 2879              		.thumb
 2880              		.thumb_func
 2882              	rateLimiter16:
 2883              	.LVL197:
 2884              	.LFB95:
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 88


1644:Src/util.c    ****   // Old filter
1645:Src/util.c    ****   // Inputs:       u     = int16
1646:Src/util.c    ****   // Outputs:      y     = fixdt(1,32,20)
1647:Src/util.c    ****   // Parameters:   coef  = fixdt(0,16,16) = [0,65535U]
1648:Src/util.c    ****   // yint = (int16_t)(y >> 20); // the integer output is the fixed-point ouput shifted by 20 bits
1649:Src/util.c    ****   // void filtLowPass32(int16_t u, uint16_t coef, int32_t *y) {
1650:Src/util.c    ****   //   int32_t tmp;  
1651:Src/util.c    ****   //   tmp = (int16_t)(u << 4) - (*y >> 16);  
1652:Src/util.c    ****   //   tmp = CLAMP(tmp, -32768, 32767);  // Overflow protection  
1653:Src/util.c    ****   //   *y  = coef * tmp + (*y);
1654:Src/util.c    ****   // }
1655:Src/util.c    **** 
1656:Src/util.c    **** 
1657:Src/util.c    ****   /* rateLimiter16(int16_t u, int16_t rate, int16_t *y);
1658:Src/util.c    ****   * Inputs:       u     = int16
1659:Src/util.c    ****   * Outputs:      y     = fixdt(1,16,4)
1660:Src/util.c    ****   * Parameters:   rate  = fixdt(1,16,4) = [0, 32767] Do NOT make rate negative (>32767)
1661:Src/util.c    ****   */
1662:Src/util.c    **** void rateLimiter16(int16_t u, int16_t rate, int16_t *y) {
 2885              		.loc 1 1662 57 view -0
 2886              		.cfi_startproc
 2887              		@ args = 0, pretend = 0, frame = 0
 2888              		@ frame_needed = 0, uses_anonymous_args = 0
 2889              		@ link register save eliminated.
1663:Src/util.c    ****   int16_t q0;
 2890              		.loc 1 1663 3 view .LVU775
1664:Src/util.c    ****   int16_t q1;
 2891              		.loc 1 1664 3 view .LVU776
1665:Src/util.c    **** 
1666:Src/util.c    ****   q0 = (u << 4)  - *y;
 2892              		.loc 1 1666 3 view .LVU777
 2893              		.loc 1 1666 11 is_stmt 0 view .LVU778
 2894 0000 0301     		lsls	r3, r0, #4
 2895 0002 9BB2     		uxth	r3, r3
 2896              		.loc 1 1666 20 view .LVU779
 2897 0004 1088     		ldrh	r0, [r2]
 2898              	.LVL198:
 2899              		.loc 1 1666 18 view .LVU780
 2900 0006 1B1A     		subs	r3, r3, r0
 2901              		.loc 1 1666 6 view .LVU781
 2902 0008 1BB2     		sxth	r3, r3
 2903              	.LVL199:
1667:Src/util.c    **** 
1668:Src/util.c    ****   if (q0 > rate) {
 2904              		.loc 1 1668 3 is_stmt 1 view .LVU782
 2905              		.loc 1 1668 6 is_stmt 0 view .LVU783
 2906 000a 8B42     		cmp	r3, r1
 2907 000c 04DC     		bgt	.L196
1669:Src/util.c    ****     q0 = rate;
1670:Src/util.c    ****   } else {
1671:Src/util.c    ****     q1 = -rate;
 2908              		.loc 1 1671 5 is_stmt 1 view .LVU784
 2909              		.loc 1 1671 8 is_stmt 0 view .LVU785
 2910 000e 4942     		rsbs	r1, r1, #0
 2911              	.LVL200:
 2912              		.loc 1 1671 8 view .LVU786
 2913 0010 09B2     		sxth	r1, r1
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 89


 2914              	.LVL201:
1672:Src/util.c    ****     if (q0 < q1) {
 2915              		.loc 1 1672 5 is_stmt 1 view .LVU787
 2916              		.loc 1 1672 8 is_stmt 0 view .LVU788
 2917 0012 8B42     		cmp	r3, r1
 2918 0014 00DB     		blt	.L196
1666:Src/util.c    **** 
 2919              		.loc 1 1666 6 view .LVU789
 2920 0016 1946     		mov	r1, r3
 2921              	.LVL202:
 2922              	.L196:
1673:Src/util.c    ****       q0 = q1;
1674:Src/util.c    ****     }
1675:Src/util.c    ****   }
1676:Src/util.c    **** 
1677:Src/util.c    ****   *y = q0 + *y;
 2923              		.loc 1 1677 3 is_stmt 1 view .LVU790
 2924              		.loc 1 1677 11 is_stmt 0 view .LVU791
 2925 0018 0144     		add	r1, r1, r0
 2926              	.LVL203:
 2927              		.loc 1 1677 6 view .LVU792
 2928 001a 1180     		strh	r1, [r2]	@ movhi
1678:Src/util.c    **** }
 2929              		.loc 1 1678 1 view .LVU793
 2930 001c 7047     		bx	lr
 2931              		.cfi_endproc
 2932              	.LFE95:
 2934              		.section	.text.mixerFcn,"ax",%progbits
 2935              		.align	1
 2936              		.global	mixerFcn
 2937              		.syntax unified
 2938              		.thumb
 2939              		.thumb_func
 2941              	mixerFcn:
 2942              	.LVL204:
 2943              	.LFB96:
1679:Src/util.c    **** 
1680:Src/util.c    **** 
1681:Src/util.c    ****   /* mixerFcn(rtu_speed, rtu_steer, &rty_speedR, &rty_speedL); 
1682:Src/util.c    ****   * Inputs:       rtu_speed, rtu_steer                  = fixdt(1,16,4)
1683:Src/util.c    ****   * Outputs:      rty_speedR, rty_speedL                = int16_t
1684:Src/util.c    ****   * Parameters:   SPEED_COEFFICIENT, STEER_COEFFICIENT  = fixdt(0,16,14)
1685:Src/util.c    ****   */
1686:Src/util.c    **** void mixerFcn(int16_t rtu_speed, int16_t rtu_steer, int16_t *rty_speedR, int16_t *rty_speedL) {
 2944              		.loc 1 1686 95 is_stmt 1 view -0
 2945              		.cfi_startproc
 2946              		@ args = 0, pretend = 0, frame = 0
 2947              		@ frame_needed = 0, uses_anonymous_args = 0
 2948              		.loc 1 1686 95 is_stmt 0 view .LVU795
 2949 0000 10B5     		push	{r4, lr}
 2950              	.LCFI27:
 2951              		.cfi_def_cfa_offset 8
 2952              		.cfi_offset 4, -8
 2953              		.cfi_offset 14, -4
1687:Src/util.c    ****     int16_t prodSpeed;
 2954              		.loc 1 1687 5 is_stmt 1 view .LVU796
1688:Src/util.c    ****     int16_t prodSteer;
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 90


 2955              		.loc 1 1688 5 view .LVU797
1689:Src/util.c    ****     int32_t tmp;
 2956              		.loc 1 1689 5 view .LVU798
1690:Src/util.c    **** 
1691:Src/util.c    ****     prodSpeed   = (int16_t)((rtu_speed * (int16_t)SPEED_COEFFICIENT) >> 14);
 2957              		.loc 1 1691 5 view .LVU799
 2958              	.LVL205:
1692:Src/util.c    ****     prodSteer   = (int16_t)((rtu_steer * (int16_t)STEER_COEFFICIENT) >> 14);
 2959              		.loc 1 1692 5 view .LVU800
 2960              		.loc 1 1692 17 is_stmt 0 view .LVU801
 2961 0002 4FEA610E 		asr	lr, r1, #1
 2962              	.LVL206:
1693:Src/util.c    **** 
1694:Src/util.c    ****     tmp         = prodSpeed - prodSteer;  
 2963              		.loc 1 1694 5 is_stmt 1 view .LVU802
 2964              		.loc 1 1694 17 is_stmt 0 view .LVU803
 2965 0006 A0EB6101 		sub	r1, r0, r1, asr #1
 2966              	.LVL207:
1695:Src/util.c    ****     tmp         = CLAMP(tmp, -32768, 32767);  // Overflow protection
 2967              		.loc 1 1695 5 is_stmt 1 view .LVU804
 2968              		.loc 1 1695 19 is_stmt 0 view .LVU805
 2969 000a B1F5004F 		cmp	r1, #32768
 2970 000e 26DA     		bge	.L202
 2971              		.loc 1 1695 19 discriminator 1 view .LVU806
 2972 0010 174C     		ldr	r4, .L206
 2973 0012 A142     		cmp	r1, r4
 2974 0014 B8BF     		it	lt
 2975 0016 2146     		movlt	r1, r4
 2976              	.LVL208:
 2977              	.L198:
1696:Src/util.c    ****     *rty_speedR = (int16_t)(tmp >> 4);        // Convert from fixed-point to int 
 2978              		.loc 1 1696 5 is_stmt 1 discriminator 4 view .LVU807
 2979              		.loc 1 1696 19 is_stmt 0 discriminator 4 view .LVU808
 2980 0018 0911     		asrs	r1, r1, #4
 2981              	.LVL209:
 2982              		.loc 1 1696 17 discriminator 4 view .LVU809
 2983 001a 1180     		strh	r1, [r2]	@ movhi
1697:Src/util.c    ****     *rty_speedR = CLAMP(*rty_speedR, INPUT_MIN, INPUT_MAX);
 2984              		.loc 1 1697 5 is_stmt 1 discriminator 4 view .LVU810
 2985              		.loc 1 1697 19 is_stmt 0 discriminator 4 view .LVU811
 2986 001c 154C     		ldr	r4, .L206+4
 2987 001e B4F900C0 		ldrsh	ip, [r4]
 2988              		.loc 1 1697 17 discriminator 4 view .LVU812
 2989 0022 6145     		cmp	r1, ip
 2990 0024 1EDC     		bgt	.L203
 2991              		.loc 1 1697 19 discriminator 1 view .LVU813
 2992 0026 144C     		ldr	r4, .L206+8
 2993 0028 B4F90040 		ldrsh	r4, [r4]
 2994              		.loc 1 1697 17 discriminator 1 view .LVU814
 2995 002c A142     		cmp	r1, r4
 2996 002e B8BF     		it	lt
 2997 0030 2146     		movlt	r1, r4
 2998              	.L199:
 2999              		.loc 1 1697 17 discriminator 4 view .LVU815
 3000 0032 1180     		strh	r1, [r2]	@ movhi
1698:Src/util.c    **** 
1699:Src/util.c    ****     tmp         = prodSpeed + prodSteer;
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 91


 3001              		.loc 1 1699 5 is_stmt 1 discriminator 4 view .LVU816
 3002              		.loc 1 1699 17 is_stmt 0 discriminator 4 view .LVU817
 3003 0034 7044     		add	r0, r0, lr
 3004              	.LVL210:
1700:Src/util.c    ****     tmp         = CLAMP(tmp, -32768, 32767);  // Overflow protection
 3005              		.loc 1 1700 5 is_stmt 1 discriminator 4 view .LVU818
 3006              		.loc 1 1700 19 is_stmt 0 discriminator 4 view .LVU819
 3007 0036 B0F5004F 		cmp	r0, #32768
 3008 003a 15DA     		bge	.L204
 3009              		.loc 1 1700 19 discriminator 1 view .LVU820
 3010 003c 0C4A     		ldr	r2, .L206
 3011              	.LVL211:
 3012              		.loc 1 1700 19 discriminator 1 view .LVU821
 3013 003e 9042     		cmp	r0, r2
 3014 0040 B8BF     		it	lt
 3015 0042 1046     		movlt	r0, r2
 3016              	.LVL212:
 3017              	.L200:
1701:Src/util.c    ****     *rty_speedL = (int16_t)(tmp >> 4);        // Convert from fixed-point to int
 3018              		.loc 1 1701 5 is_stmt 1 discriminator 4 view .LVU822
 3019              		.loc 1 1701 19 is_stmt 0 discriminator 4 view .LVU823
 3020 0044 0211     		asrs	r2, r0, #4
 3021              		.loc 1 1701 17 discriminator 4 view .LVU824
 3022 0046 1A80     		strh	r2, [r3]	@ movhi
1702:Src/util.c    ****     *rty_speedL = CLAMP(*rty_speedL, INPUT_MIN, INPUT_MAX);
 3023              		.loc 1 1702 5 is_stmt 1 discriminator 4 view .LVU825
 3024              		.loc 1 1702 17 is_stmt 0 discriminator 4 view .LVU826
 3025 0048 9445     		cmp	ip, r2
 3026 004a 05DB     		blt	.L201
 3027              		.loc 1 1702 19 discriminator 1 view .LVU827
 3028 004c 0A49     		ldr	r1, .L206+8
 3029 004e B1F900C0 		ldrsh	ip, [r1]
 3030              		.loc 1 1702 17 discriminator 1 view .LVU828
 3031 0052 9445     		cmp	ip, r2
 3032 0054 B8BF     		it	lt
 3033 0056 9446     		movlt	ip, r2
 3034              	.L201:
 3035              		.loc 1 1702 17 discriminator 4 view .LVU829
 3036 0058 A3F800C0 		strh	ip, [r3]	@ movhi
1703:Src/util.c    **** }
 3037              		.loc 1 1703 1 discriminator 4 view .LVU830
 3038 005c 10BD     		pop	{r4, pc}
 3039              	.LVL213:
 3040              	.L202:
1695:Src/util.c    ****     *rty_speedR = (int16_t)(tmp >> 4);        // Convert from fixed-point to int 
 3041              		.loc 1 1695 19 view .LVU831
 3042 005e 47F6FF71 		movw	r1, #32767
 3043              	.LVL214:
1695:Src/util.c    ****     *rty_speedR = (int16_t)(tmp >> 4);        // Convert from fixed-point to int 
 3044              		.loc 1 1695 19 view .LVU832
 3045 0062 D9E7     		b	.L198
 3046              	.L203:
1697:Src/util.c    **** 
 3047              		.loc 1 1697 17 view .LVU833
 3048 0064 6146     		mov	r1, ip
 3049 0066 E4E7     		b	.L199
 3050              	.LVL215:
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 92


 3051              	.L204:
1700:Src/util.c    ****     *rty_speedL = (int16_t)(tmp >> 4);        // Convert from fixed-point to int
 3052              		.loc 1 1700 19 view .LVU834
 3053 0068 47F6FF70 		movw	r0, #32767
 3054              	.LVL216:
1700:Src/util.c    ****     *rty_speedL = (int16_t)(tmp >> 4);        // Convert from fixed-point to int
 3055              		.loc 1 1700 19 view .LVU835
 3056 006c EAE7     		b	.L200
 3057              	.L207:
 3058 006e 00BF     		.align	2
 3059              	.L206:
 3060 0070 0080FFFF 		.word	-32768
 3061 0074 00000000 		.word	.LANCHOR9
 3062 0078 00000000 		.word	.LANCHOR10
 3063              		.cfi_endproc
 3064              	.LFE96:
 3066              		.section	.text.multipleTapDet,"ax",%progbits
 3067              		.align	1
 3068              		.global	multipleTapDet
 3069              		.syntax unified
 3070              		.thumb
 3071              		.thumb_func
 3073              	multipleTapDet:
 3074              	.LVL217:
 3075              	.LFB97:
1704:Src/util.c    **** 
1705:Src/util.c    **** 
1706:Src/util.c    **** 
1707:Src/util.c    **** /* =========================== Multiple Tap Function =========================== */
1708:Src/util.c    **** 
1709:Src/util.c    ****   /* multipleTapDet(int16_t u, uint32_t timeNow, MultipleTap *x)
1710:Src/util.c    ****   * This function detects multiple tap presses, such as double tapping, triple tapping, etc.
1711:Src/util.c    ****   * Inputs:       u = int16_t (input signal); timeNow = uint32_t (current time)  
1712:Src/util.c    ****   * Outputs:      x->b_multipleTap (get the output here)
1713:Src/util.c    ****   */
1714:Src/util.c    **** void multipleTapDet(int16_t u, uint32_t timeNow, MultipleTap *x) {
 3076              		.loc 1 1714 66 is_stmt 1 view -0
 3077              		.cfi_startproc
 3078              		@ args = 0, pretend = 0, frame = 0
 3079              		@ frame_needed = 0, uses_anonymous_args = 0
 3080              		@ link register save eliminated.
 3081              		.loc 1 1714 66 is_stmt 0 view .LVU837
 3082 0000 30B4     		push	{r4, r5}
 3083              	.LCFI28:
 3084              		.cfi_def_cfa_offset 8
 3085              		.cfi_offset 4, -8
 3086              		.cfi_offset 5, -4
1715:Src/util.c    ****   uint8_t 	b_timeout;
 3087              		.loc 1 1715 3 is_stmt 1 view .LVU838
1716:Src/util.c    ****   uint8_t 	b_hyst;
 3088              		.loc 1 1716 3 view .LVU839
1717:Src/util.c    ****   uint8_t 	b_pulse;
 3089              		.loc 1 1717 3 view .LVU840
1718:Src/util.c    ****   uint8_t 	z_pulseCnt;
 3090              		.loc 1 1718 3 view .LVU841
1719:Src/util.c    ****   uint8_t   z_pulseCntRst;
 3091              		.loc 1 1719 3 view .LVU842
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 93


1720:Src/util.c    ****   uint32_t 	t_time; 
 3092              		.loc 1 1720 3 view .LVU843
1721:Src/util.c    **** 
1722:Src/util.c    ****   // Detect hysteresis
1723:Src/util.c    ****   if (x->b_hysteresis) {
 3093              		.loc 1 1723 3 view .LVU844
 3094              		.loc 1 1723 8 is_stmt 0 view .LVU845
 3095 0002 5479     		ldrb	r4, [r2, #5]	@ zero_extendqisi2
 3096              		.loc 1 1723 6 view .LVU846
 3097 0004 E4B1     		cbz	r4, .L209
1724:Src/util.c    ****     b_hyst = (u > MULTIPLE_TAP_LO);
 3098              		.loc 1 1724 5 is_stmt 1 view .LVU847
 3099              		.loc 1 1724 17 is_stmt 0 view .LVU848
 3100 0006 C828     		cmp	r0, #200
 3101 0008 D4BF     		ite	le
 3102 000a 0020     		movle	r0, #0
 3103              	.LVL218:
 3104              		.loc 1 1724 17 view .LVU849
 3105 000c 0120     		movgt	r0, #1
 3106              	.LVL219:
 3107              	.L210:
1725:Src/util.c    ****   } else {
1726:Src/util.c    ****     b_hyst = (u > MULTIPLE_TAP_HI);
1727:Src/util.c    ****   }
1728:Src/util.c    **** 
1729:Src/util.c    ****   // Detect pulse
1730:Src/util.c    ****   b_pulse = (b_hyst != x->b_hysteresis);
 3108              		.loc 1 1730 3 is_stmt 1 view .LVU850
 3109              		.loc 1 1730 21 is_stmt 0 view .LVU851
 3110 000e 231A     		subs	r3, r4, r0
 3111 0010 18BF     		it	ne
 3112 0012 0123     		movne	r3, #1
 3113              	.LVL220:
1731:Src/util.c    **** 
1732:Src/util.c    ****   // Save time when first pulse is detected
1733:Src/util.c    ****   if (b_hyst && b_pulse && (x->z_pulseCntPrev == 0)) {
 3114              		.loc 1 1733 3 is_stmt 1 view .LVU852
 3115              		.loc 1 1733 6 is_stmt 0 view .LVU853
 3116 0014 18B1     		cbz	r0, .L211
 3117              		.loc 1 1733 14 discriminator 1 view .LVU854
 3118 0016 8442     		cmp	r4, r0
 3119 0018 01D0     		beq	.L211
 3120              		.loc 1 1733 30 discriminator 2 view .LVU855
 3121 001a 1479     		ldrb	r4, [r2, #4]	@ zero_extendqisi2
 3122              		.loc 1 1733 25 discriminator 2 view .LVU856
 3123 001c B4B1     		cbz	r4, .L216
 3124              	.L211:
1734:Src/util.c    ****     t_time = timeNow;
1735:Src/util.c    ****   } else {
1736:Src/util.c    ****     t_time = x->t_timePrev;
 3125              		.loc 1 1736 5 is_stmt 1 view .LVU857
 3126              		.loc 1 1736 12 is_stmt 0 view .LVU858
 3127 001e 1468     		ldr	r4, [r2]
 3128              	.LVL221:
 3129              	.L212:
1737:Src/util.c    ****   }
1738:Src/util.c    **** 
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 94


1739:Src/util.c    ****   // Create timeout boolean
1740:Src/util.c    ****   b_timeout = (timeNow - t_time > MULTIPLE_TAP_TIMEOUT);
 3130              		.loc 1 1740 3 is_stmt 1 view .LVU859
 3131              		.loc 1 1740 24 is_stmt 0 view .LVU860
 3132 0020 091B     		subs	r1, r1, r4
 3133              	.LVL222:
1741:Src/util.c    **** 
1742:Src/util.c    ****   // Create pulse counter
1743:Src/util.c    ****   if ((!b_hyst) && (x->z_pulseCntPrev == 0)) {
 3134              		.loc 1 1743 3 is_stmt 1 view .LVU861
 3135              		.loc 1 1743 6 is_stmt 0 view .LVU862
 3136 0022 10B9     		cbnz	r0, .L213
 3137              		.loc 1 1743 22 discriminator 1 view .LVU863
 3138 0024 1579     		ldrb	r5, [r2, #4]	@ zero_extendqisi2
 3139              		.loc 1 1743 17 discriminator 1 view .LVU864
 3140 0026 05B9     		cbnz	r5, .L213
1744:Src/util.c    ****     z_pulseCnt = 0U;
 3141              		.loc 1 1744 16 view .LVU865
 3142 0028 2B46     		mov	r3, r5
 3143              	.LVL223:
 3144              	.L213:
1745:Src/util.c    ****   } else {
1746:Src/util.c    ****     z_pulseCnt = b_pulse;
1747:Src/util.c    ****   }
1748:Src/util.c    **** 
1749:Src/util.c    ****   // Reset counter if we detected complete tap presses OR there is a timeout
1750:Src/util.c    ****   if ((x->z_pulseCntPrev >= MULTIPLE_TAP_NR) || b_timeout) {
 3145              		.loc 1 1750 3 is_stmt 1 view .LVU866
 3146              		.loc 1 1750 9 is_stmt 0 view .LVU867
 3147 002a 92F804C0 		ldrb	ip, [r2, #4]	@ zero_extendqisi2
 3148              		.loc 1 1750 6 view .LVU868
 3149 002e BCF1030F 		cmp	ip, #3
 3150 0032 0DD8     		bhi	.L218
 3151              		.loc 1 1750 46 discriminator 1 view .LVU869
 3152 0034 B1F5FA6F 		cmp	r1, #2000
 3153 0038 0CD9     		bls	.L214
1751:Src/util.c    ****     z_pulseCntRst = 0U;
 3154              		.loc 1 1751 19 view .LVU870
 3155 003a 4FF0000C 		mov	ip, #0
 3156 003e 09E0     		b	.L214
 3157              	.LVL224:
 3158              	.L209:
1726:Src/util.c    ****   }
 3159              		.loc 1 1726 5 is_stmt 1 view .LVU871
1726:Src/util.c    ****   }
 3160              		.loc 1 1726 17 is_stmt 0 view .LVU872
 3161 0040 B0F5167F 		cmp	r0, #600
 3162 0044 D4BF     		ite	le
 3163 0046 0020     		movle	r0, #0
 3164              	.LVL225:
1726:Src/util.c    ****   }
 3165              		.loc 1 1726 17 view .LVU873
 3166 0048 0120     		movgt	r0, #1
 3167              	.LVL226:
1726:Src/util.c    ****   }
 3168              		.loc 1 1726 17 view .LVU874
 3169 004a E0E7     		b	.L210
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 95


 3170              	.LVL227:
 3171              	.L216:
1734:Src/util.c    ****   } else {
 3172              		.loc 1 1734 12 view .LVU875
 3173 004c 0C46     		mov	r4, r1
 3174 004e E7E7     		b	.L212
 3175              	.LVL228:
 3176              	.L218:
 3177              		.loc 1 1751 19 view .LVU876
 3178 0050 4FF0000C 		mov	ip, #0
 3179              	.L214:
 3180              	.LVL229:
1752:Src/util.c    ****   } else {
1753:Src/util.c    ****     z_pulseCntRst = x->z_pulseCntPrev;
1754:Src/util.c    ****   }
1755:Src/util.c    ****   z_pulseCnt = z_pulseCnt + z_pulseCntRst;
 3181              		.loc 1 1755 3 is_stmt 1 view .LVU877
 3182              		.loc 1 1755 14 is_stmt 0 view .LVU878
 3183 0054 6344     		add	r3, r3, ip
 3184              	.LVL230:
 3185              		.loc 1 1755 14 view .LVU879
 3186 0056 DBB2     		uxtb	r3, r3
 3187              	.LVL231:
1756:Src/util.c    **** 
1757:Src/util.c    ****   // Check if complete tap presses are detected AND no timeout
1758:Src/util.c    ****   if ((z_pulseCnt >= MULTIPLE_TAP_NR) && (!b_timeout)) {
 3188              		.loc 1 1758 3 is_stmt 1 view .LVU880
 3189              		.loc 1 1758 6 is_stmt 0 view .LVU881
 3190 0058 032B     		cmp	r3, #3
 3191 005a 07D9     		bls	.L215
 3192              		.loc 1 1758 39 discriminator 1 view .LVU882
 3193 005c B1F5FA6F 		cmp	r1, #2000
 3194 0060 04D8     		bhi	.L215
1759:Src/util.c    ****     x->b_multipleTap = !x->b_multipleTap;	// Toggle output
 3195              		.loc 1 1759 5 is_stmt 1 view .LVU883
 3196              		.loc 1 1759 26 is_stmt 0 view .LVU884
 3197 0062 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 3198              	.LVL232:
 3199              		.loc 1 1759 24 view .LVU885
 3200 0064 B1FA81F1 		clz	r1, r1
 3201 0068 4909     		lsrs	r1, r1, #5
 3202              		.loc 1 1759 22 view .LVU886
 3203 006a 9171     		strb	r1, [r2, #6]
 3204              	.L215:
1760:Src/util.c    ****   }
1761:Src/util.c    **** 
1762:Src/util.c    ****   // Update states
1763:Src/util.c    ****   x->z_pulseCntPrev = z_pulseCnt;
 3205              		.loc 1 1763 3 is_stmt 1 view .LVU887
 3206              		.loc 1 1763 21 is_stmt 0 view .LVU888
 3207 006c 1371     		strb	r3, [r2, #4]
1764:Src/util.c    ****   x->b_hysteresis 	= b_hyst;
 3208              		.loc 1 1764 3 is_stmt 1 view .LVU889
 3209              		.loc 1 1764 20 is_stmt 0 view .LVU890
 3210 006e 5071     		strb	r0, [r2, #5]
 3211              	.LVL233:
1765:Src/util.c    ****   x->t_timePrev 	  = t_time;
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 96


 3212              		.loc 1 1765 3 is_stmt 1 view .LVU891
 3213              		.loc 1 1765 20 is_stmt 0 view .LVU892
 3214 0070 1460     		str	r4, [r2]
1766:Src/util.c    **** }
 3215              		.loc 1 1766 1 view .LVU893
 3216 0072 30BC     		pop	{r4, r5}
 3217              	.LCFI29:
 3218              		.cfi_restore 5
 3219              		.cfi_restore 4
 3220              		.cfi_def_cfa_offset 0
 3221              	.LVL234:
 3222              		.loc 1 1766 1 view .LVU894
 3223 0074 7047     		bx	lr
 3224              		.cfi_endproc
 3225              	.LFE97:
 3227              		.global	VirtAddVarTab
 3228              		.global	ctrlModReq
 3229              		.global	ctrlModReqRaw
 3230              		.global	timeoutFlgSerial
 3231              		.global	timeoutFlgADC
 3232              		.global	speedAvgAbs
 3233              		.global	speedAvg
 3234              		.global	input2
 3235              		.global	input1
 3236              		.global	inIdx_prev
 3237              		.global	inIdx
 3238              		.global	rtY_Right
 3239              		.global	rtU_Right
 3240              		.global	rtDW_Right
 3241              		.global	rtP_Right
 3242              		.global	rtY_Left
 3243              		.global	rtU_Left
 3244              		.global	rtDW_Left
 3245              		.global	rtM_Right
 3246              		.global	rtM_Left
 3247              		.global	rtM_Right_
 3248              		.global	rtM_Left_
 3249              		.section	.bss.INPUT_MAX,"aw",%nobits
 3250              		.align	1
 3251              		.set	.LANCHOR9,. + 0
 3254              	INPUT_MAX:
 3255 0000 0000     		.space	2
 3256              		.section	.bss.INPUT_MIN,"aw",%nobits
 3257              		.align	1
 3258              		.set	.LANCHOR10,. + 0
 3261              	INPUT_MIN:
 3262 0000 0000     		.space	2
 3263              		.section	.bss.commandL,"aw",%nobits
 3264              		.align	2
 3265              		.set	.LANCHOR18,. + 0
 3268              	commandL:
 3269 0000 00000000 		.space	8
 3269      00000000 
 3270              		.section	.bss.commandL_raw,"aw",%nobits
 3271              		.align	2
 3272              		.set	.LANCHOR27,. + 0
 3275              	commandL_raw:
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 97


 3276 0000 00000000 		.space	8
 3276      00000000 
 3277              		.section	.bss.cur_spd_valid,"aw",%nobits
 3278              		.set	.LANCHOR29,. + 0
 3281              	cur_spd_valid:
 3282 0000 00       		.space	1
 3283              		.section	.bss.inIdx,"aw",%nobits
 3284              		.set	.LANCHOR17,. + 0
 3287              	inIdx:
 3288 0000 00       		.space	1
 3289              		.section	.bss.inIdx_prev,"aw",%nobits
 3290              		.set	.LANCHOR25,. + 0
 3293              	inIdx_prev:
 3294 0000 00       		.space	1
 3295              		.section	.bss.inp_cal_valid,"aw",%nobits
 3296              		.set	.LANCHOR28,. + 0
 3299              	inp_cal_valid:
 3300 0000 00       		.space	1
 3301              		.section	.bss.old_pos.0,"aw",%nobits
 3302              		.align	2
 3303              		.set	.LANCHOR26,. + 0
 3306              	old_pos.0:
 3307 0000 00000000 		.space	4
 3308              		.section	.bss.rtDW_Left,"aw",%nobits
 3309              		.align	2
 3310              		.set	.LANCHOR2,. + 0
 3313              	rtDW_Left:
 3314 0000 00000000 		.space	172
 3314      00000000 
 3314      00000000 
 3314      00000000 
 3314      00000000 
 3315              		.section	.bss.rtDW_Right,"aw",%nobits
 3316              		.align	2
 3317              		.set	.LANCHOR6,. + 0
 3320              	rtDW_Right:
 3321 0000 00000000 		.space	172
 3321      00000000 
 3321      00000000 
 3321      00000000 
 3321      00000000 
 3322              		.section	.bss.rtM_Left_,"aw",%nobits
 3323              		.align	2
 3324              		.set	.LANCHOR1,. + 0
 3327              	rtM_Left_:
 3328 0000 00000000 		.space	16
 3328      00000000 
 3328      00000000 
 3328      00000000 
 3329              		.section	.bss.rtM_Right_,"aw",%nobits
 3330              		.align	2
 3331              		.set	.LANCHOR5,. + 0
 3334              	rtM_Right_:
 3335 0000 00000000 		.space	16
 3335      00000000 
 3335      00000000 
 3335      00000000 
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 98


 3336              		.section	.bss.rtP_Right,"aw",%nobits
 3337              		.align	2
 3338              		.set	.LANCHOR0,. + 0
 3341              	rtP_Right:
 3342 0000 00000000 		.space	256
 3342      00000000 
 3342      00000000 
 3342      00000000 
 3342      00000000 
 3343              		.section	.bss.rtU_Left,"aw",%nobits
 3344              		.align	2
 3345              		.set	.LANCHOR3,. + 0
 3348              	rtU_Left:
 3349 0000 00000000 		.space	16
 3349      00000000 
 3349      00000000 
 3349      00000000 
 3350              		.section	.bss.rtU_Right,"aw",%nobits
 3351              		.align	2
 3352              		.set	.LANCHOR7,. + 0
 3355              	rtU_Right:
 3356 0000 00000000 		.space	16
 3356      00000000 
 3356      00000000 
 3356      00000000 
 3357              		.section	.bss.rtY_Left,"aw",%nobits
 3358              		.align	2
 3359              		.set	.LANCHOR4,. + 0
 3362              	rtY_Left:
 3363 0000 00000000 		.space	16
 3363      00000000 
 3363      00000000 
 3363      00000000 
 3364              		.section	.bss.rtY_Right,"aw",%nobits
 3365              		.align	2
 3366              		.set	.LANCHOR8,. + 0
 3369              	rtY_Right:
 3370 0000 00000000 		.space	16
 3370      00000000 
 3370      00000000 
 3370      00000000 
 3371              		.section	.bss.rx_buffer_L,"aw",%nobits
 3372              		.align	2
 3373              		.set	.LANCHOR13,. + 0
 3376              	rx_buffer_L:
 3377 0000 00000000 		.space	64
 3377      00000000 
 3377      00000000 
 3377      00000000 
 3377      00000000 
 3378              		.section	.bss.speedAvg,"aw",%nobits
 3379              		.align	1
 3380              		.set	.LANCHOR11,. + 0
 3383              	speedAvg:
 3384 0000 0000     		.space	2
 3385              		.section	.bss.speedAvgAbs,"aw",%nobits
 3386              		.align	1
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 99


 3387              		.set	.LANCHOR12,. + 0
 3390              	speedAvgAbs:
 3391 0000 0000     		.space	2
 3392              		.section	.bss.timeoutFlgADC,"aw",%nobits
 3393              		.set	.LANCHOR22,. + 0
 3396              	timeoutFlgADC:
 3397 0000 00       		.space	1
 3398              		.section	.bss.timeoutFlgSerial,"aw",%nobits
 3399              		.set	.LANCHOR21,. + 0
 3402              	timeoutFlgSerial:
 3403 0000 00       		.space	1
 3404              		.section	.bss.timeoutFlgSerial_L,"aw",%nobits
 3405              		.set	.LANCHOR20,. + 0
 3408              	timeoutFlgSerial_L:
 3409 0000 00       		.space	1
 3410              		.section	.data.VirtAddVarTab,"aw"
 3411              		.align	2
 3412              		.set	.LANCHOR14,. + 0
 3415              	VirtAddVarTab:
 3416 0000 E803     		.short	1000
 3417 0002 E903     		.short	1001
 3418 0004 EA03     		.short	1002
 3419 0006 EB03     		.short	1003
 3420 0008 EC03     		.short	1004
 3421 000a ED03     		.short	1005
 3422 000c EE03     		.short	1006
 3423 000e EF03     		.short	1007
 3424 0010 F003     		.short	1008
 3425 0012 F103     		.short	1009
 3426 0014 F203     		.short	1010
 3427 0016 F303     		.short	1011
 3428 0018 F403     		.short	1012
 3429 001a F503     		.short	1013
 3430 001c F603     		.short	1014
 3431 001e F703     		.short	1015
 3432 0020 F803     		.short	1016
 3433 0022 F903     		.short	1017
 3434 0024 FA03     		.short	1018
 3435              		.section	.data.ctrlModReq,"aw"
 3436              		.set	.LANCHOR23,. + 0
 3439              	ctrlModReq:
 3440 0000 02       		.byte	2
 3441              		.section	.data.ctrlModReqRaw,"aw"
 3442              		.set	.LANCHOR24,. + 0
 3445              	ctrlModReqRaw:
 3446 0000 02       		.byte	2
 3447              		.section	.data.input1,"aw"
 3448              		.align	2
 3449              		.set	.LANCHOR15,. + 0
 3452              	input1:
 3453 0000 0000     		.short	0
 3454 0002 0000     		.short	0
 3455 0004 00       		.byte	0
 3456 0005 03       		.byte	3
 3457 0006 18FC     		.short	-1000
 3458 0008 0000     		.short	0
 3459 000a E803     		.short	1000
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 100


 3460 000c 0000     		.short	0
 3461              		.section	.data.input2,"aw"
 3462              		.align	2
 3463              		.set	.LANCHOR16,. + 0
 3466              	input2:
 3467 0000 0000     		.short	0
 3468 0002 0000     		.short	0
 3469 0004 00       		.byte	0
 3470 0005 03       		.byte	3
 3471 0006 18FC     		.short	-1000
 3472 0008 0000     		.short	0
 3473 000a E803     		.short	1000
 3474 000c 0000     		.short	0
 3475              		.section	.data.timeoutCntSerial_L,"aw"
 3476              		.align	1
 3477              		.set	.LANCHOR19,. + 0
 3480              	timeoutCntSerial_L:
 3481 0000 A000     		.short	160
 3482              		.section	.rodata.rtM_Left,"a"
 3483              		.align	2
 3486              	rtM_Left:
 3487 0000 00000000 		.word	rtM_Left_
 3488              		.section	.rodata.rtM_Right,"a"
 3489              		.align	2
 3492              	rtM_Right:
 3493 0000 00000000 		.word	rtM_Right_
 3494              		.text
 3495              	.Letext0:
 3496              		.file 2 "/opt/homebrew/Cellar/arm-none-eabi-gcc/10.3-2021.10/gcc/arm-none-eabi/include/machine/_de
 3497              		.file 3 "/opt/homebrew/Cellar/arm-none-eabi-gcc/10.3-2021.10/gcc/arm-none-eabi/include/sys/_stdint
 3498              		.file 4 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xe.h"
 3499              		.file 5 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_def.h"
 3500              		.file 6 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_gpio.h"
 3501              		.file 7 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_dma.h"
 3502              		.file 8 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_uart.h"
 3503              		.file 9 "Inc/util.h"
 3504              		.file 10 "Inc/rtwtypes.h"
 3505              		.file 11 "Inc/BLDC_controller.h"
 3506              		.file 12 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal.h"
 3507              		.file 13 "Inc/eeprom.h"
 3508              		.file 14 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_flash.h"
 3509              		.file 15 "/opt/homebrew/Cellar/arm-none-eabi-gcc/10.3-2021.10/gcc/arm-none-eabi/include/stdio.h"
 3510              		.file 16 "Inc/setup.h"
 3511              		.file 17 "<built-in>"
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 101


DEFINED SYMBOLS
                            *ABS*:0000000000000000 util.c
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:18     .text.BLDC_Init:0000000000000000 $t
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:24     .text.BLDC_Init:0000000000000000 BLDC_Init
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:134    .text.BLDC_Init:0000000000000084 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:148    .text.Input_Lim_Init:0000000000000000 $t
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:154    .text.Input_Lim_Init:0000000000000000 Input_Lim_Init
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:200    .text.Input_Lim_Init:0000000000000034 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:208    .text.UART_DisableRxErrors:0000000000000000 $t
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:214    .text.UART_DisableRxErrors:0000000000000000 UART_DisableRxErrors
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:238    .text.poweronMelody:0000000000000000 $t
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:244    .text.poweronMelody:0000000000000000 poweronMelody
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:300    .text.poweronMelody:0000000000000024 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:306    .text.beepCount:0000000000000000 $t
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:312    .text.beepCount:0000000000000000 beepCount
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:337    .text.beepCount:0000000000000010 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:344    .text.beepLong:0000000000000000 $t
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:350    .text.beepLong:0000000000000000 beepLong
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:388    .text.beepLong:0000000000000018 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:394    .text.beepShort:0000000000000000 $t
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:400    .text.beepShort:0000000000000000 beepShort
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:438    .text.beepShort:0000000000000018 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:444    .text.beepShortMany:0000000000000000 $t
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:450    .text.beepShortMany:0000000000000000 beepShortMany
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:535    .text.calcAvgSpeed:0000000000000000 $t
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:541    .text.calcAvgSpeed:0000000000000000 calcAvgSpeed
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:587    .text.calcAvgSpeed:0000000000000030 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:595    .text.standstillHold:0000000000000000 $t
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:601    .text.standstillHold:0000000000000000 standstillHold
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:614    .text.electricBrake:0000000000000000 $t
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:620    .text.electricBrake:0000000000000000 electricBrake
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:634    .text.cruiseControl:0000000000000000 $t
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:640    .text.cruiseControl:0000000000000000 cruiseControl
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:654    .text.checkInputType:0000000000000000 $t
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:660    .text.checkInputType:0000000000000000 checkInputType
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:752    .text.checkInputType:0000000000000058 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:757    .rodata.Input_Init.str1.4:0000000000000000 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:762    .text.Input_Init:0000000000000000 $t
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:768    .text.Input_Init:0000000000000000 Input_Init
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:1136   .text.Input_Init:0000000000000220 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:1149   .text.calcInputCmd:0000000000000000 $t
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:1155   .text.calcInputCmd:0000000000000000 calcInputCmd
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:1295   .text.readInputRaw:0000000000000000 $t
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:1301   .text.readInputRaw:0000000000000000 readInputRaw
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:1337   .text.readInputRaw:0000000000000028 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:1345   .text.handleTimeout:0000000000000000 $t
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:1351   .text.handleTimeout:0000000000000000 handleTimeout
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:1469   .text.handleTimeout:000000000000007c $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:1484   .text.readCommand:0000000000000000 $t
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:1490   .text.readCommand:0000000000000000 readCommand
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:1541   .text.readCommand:0000000000000044 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:1550   .text.usart3_rx_check:0000000000000000 $t
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:1556   .text.usart3_rx_check:0000000000000000 usart3_rx_check
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:1569   .text.usart_process_command:0000000000000000 $t
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:1575   .text.usart_process_command:0000000000000000 usart_process_command
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:1646   .text.usart_process_command:0000000000000044 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:1652   .text.usart2_rx_check:0000000000000000 $t
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 102


/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:1658   .text.usart2_rx_check:0000000000000000 usart2_rx_check
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:1786   .text.usart2_rx_check:0000000000000080 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:1795   .text.sideboardLeds:0000000000000000 $t
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:1801   .text.sideboardLeds:0000000000000000 sideboardLeds
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:1815   .text.sideboardSensors:0000000000000000 $t
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:1821   .text.sideboardSensors:0000000000000000 sideboardSensors
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:1835   .text.saveConfig:0000000000000000 $t
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:1841   .text.saveConfig:0000000000000000 saveConfig
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:2014   .text.saveConfig:00000000000000e4 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:2025   .text.poweroff:0000000000000000 $t
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:2031   .text.poweroff:0000000000000000 poweroff
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:2098   .text.poweroff:0000000000000034 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:2107   .text.filtLowPass32:0000000000000000 $t
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:2113   .text.filtLowPass32:0000000000000000 filtLowPass32
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:2181   .text.adcCalibLim:0000000000000000 $t
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:2187   .text.adcCalibLim:0000000000000000 adcCalibLim
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:2463   .text.adcCalibLim:0000000000000150 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:2474   .text.updateCurSpdLim:0000000000000000 $t
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:2480   .text.updateCurSpdLim:0000000000000000 updateCurSpdLim
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:2712   .text.updateCurSpdLim:0000000000000150 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:2724   .text.poweroffPressCheck:0000000000000000 $t
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:2730   .text.poweroffPressCheck:0000000000000000 poweroffPressCheck
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:2869   .text.poweroffPressCheck:0000000000000098 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:2876   .text.rateLimiter16:0000000000000000 $t
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:2882   .text.rateLimiter16:0000000000000000 rateLimiter16
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:2935   .text.mixerFcn:0000000000000000 $t
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:2941   .text.mixerFcn:0000000000000000 mixerFcn
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3060   .text.mixerFcn:0000000000000070 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3067   .text.multipleTapDet:0000000000000000 $t
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3073   .text.multipleTapDet:0000000000000000 multipleTapDet
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3415   .data.VirtAddVarTab:0000000000000000 VirtAddVarTab
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3439   .data.ctrlModReq:0000000000000000 ctrlModReq
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3445   .data.ctrlModReqRaw:0000000000000000 ctrlModReqRaw
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3402   .bss.timeoutFlgSerial:0000000000000000 timeoutFlgSerial
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3396   .bss.timeoutFlgADC:0000000000000000 timeoutFlgADC
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3390   .bss.speedAvgAbs:0000000000000000 speedAvgAbs
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3383   .bss.speedAvg:0000000000000000 speedAvg
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3466   .data.input2:0000000000000000 input2
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3452   .data.input1:0000000000000000 input1
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3293   .bss.inIdx_prev:0000000000000000 inIdx_prev
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3287   .bss.inIdx:0000000000000000 inIdx
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3369   .bss.rtY_Right:0000000000000000 rtY_Right
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3355   .bss.rtU_Right:0000000000000000 rtU_Right
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3320   .bss.rtDW_Right:0000000000000000 rtDW_Right
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3341   .bss.rtP_Right:0000000000000000 rtP_Right
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3362   .bss.rtY_Left:0000000000000000 rtY_Left
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3348   .bss.rtU_Left:0000000000000000 rtU_Left
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3313   .bss.rtDW_Left:0000000000000000 rtDW_Left
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3492   .rodata.rtM_Right:0000000000000000 rtM_Right
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3486   .rodata.rtM_Left:0000000000000000 rtM_Left
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3334   .bss.rtM_Right_:0000000000000000 rtM_Right_
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3327   .bss.rtM_Left_:0000000000000000 rtM_Left_
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3250   .bss.INPUT_MAX:0000000000000000 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3254   .bss.INPUT_MAX:0000000000000000 INPUT_MAX
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3257   .bss.INPUT_MIN:0000000000000000 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3261   .bss.INPUT_MIN:0000000000000000 INPUT_MIN
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3264   .bss.commandL:0000000000000000 $d
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 103


/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3268   .bss.commandL:0000000000000000 commandL
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3271   .bss.commandL_raw:0000000000000000 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3275   .bss.commandL_raw:0000000000000000 commandL_raw
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3281   .bss.cur_spd_valid:0000000000000000 cur_spd_valid
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3282   .bss.cur_spd_valid:0000000000000000 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3288   .bss.inIdx:0000000000000000 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3294   .bss.inIdx_prev:0000000000000000 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3299   .bss.inp_cal_valid:0000000000000000 inp_cal_valid
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3300   .bss.inp_cal_valid:0000000000000000 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3302   .bss.old_pos.0:0000000000000000 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3306   .bss.old_pos.0:0000000000000000 old_pos.0
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3309   .bss.rtDW_Left:0000000000000000 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3316   .bss.rtDW_Right:0000000000000000 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3323   .bss.rtM_Left_:0000000000000000 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3330   .bss.rtM_Right_:0000000000000000 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3337   .bss.rtP_Right:0000000000000000 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3344   .bss.rtU_Left:0000000000000000 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3351   .bss.rtU_Right:0000000000000000 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3358   .bss.rtY_Left:0000000000000000 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3365   .bss.rtY_Right:0000000000000000 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3372   .bss.rx_buffer_L:0000000000000000 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3376   .bss.rx_buffer_L:0000000000000000 rx_buffer_L
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3379   .bss.speedAvg:0000000000000000 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3386   .bss.speedAvgAbs:0000000000000000 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3397   .bss.timeoutFlgADC:0000000000000000 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3403   .bss.timeoutFlgSerial:0000000000000000 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3408   .bss.timeoutFlgSerial_L:0000000000000000 timeoutFlgSerial_L
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3409   .bss.timeoutFlgSerial_L:0000000000000000 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3411   .data.VirtAddVarTab:0000000000000000 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3448   .data.input1:0000000000000000 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3462   .data.input2:0000000000000000 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3476   .data.timeoutCntSerial_L:0000000000000000 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3480   .data.timeoutCntSerial_L:0000000000000000 timeoutCntSerial_L
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3483   .rodata.rtM_Left:0000000000000000 $d
/var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s:3489   .rodata.rtM_Right:0000000000000000 $d

UNDEFINED SYMBOLS
memcpy
BLDC_controller_initialize
rtP_Left
HAL_Delay
buzzerCount
buzzerFreq
buzzerPattern
UART2_Init
HAL_UART_Receive_DMA
HAL_FLASH_Unlock
EE_Init
EE_ReadVariable
printf
HAL_FLASH_Lock
huart2
timeoutFlgGen
EE_WriteVariable
HAL_GPIO_WritePin
enable
HAL_GPIO_ReadPin
ARM GAS  /var/folders/2w/5wbrmvx534s_vk8svtxz852c0000gn/T//cc5GyBBm.s 			page 104


